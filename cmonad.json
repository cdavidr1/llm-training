[
  {
    "instruction": "What is covered in the 'Quick Reference' section of the Developer Essentials guide?",
    "output": "<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/developer-essentials/network-information\"\n        title=\"Network Information\"\n        description=\"Links and canonical deployments\"\n    />\n        <CustomDocCard\n        icon={<Monad />}\n        link=\"/tooling-and-infra\"\n        title=\"Tooling & Infra\"\n        description=\"Third-party infra supporting Monad Testnet\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/reference\"\n        title=\"RPC Reference\"\n        description=\"JSON-RPC API\"\n    />\n</CustomDocCardContainer>"
  },
  {
    "instruction": "What is covered in the 'Optimizing for Monad' section of the Developer Essentials guide?",
    "output": "<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/developer-essentials/best-practices\"\n        title=\"Best Practices\"\n        description=\"Recommendations for building high-performance apps\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/developer-essentials/gas-on-monad\"\n        title=\"Gas on Monad\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/developer-essentials/differences\"\n        title=\"Differences between Monad & Ethereum\"\n    />\n</CustomDocCardContainer>"
  },
  {
    "instruction": "What is covered in the 'Monad's Architecture in Depth' section of the Developer Essentials guide?",
    "output": "<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/introduction/monad-for-developers\"\n        title=\"Monad for Devs\"\n        description=\"One-page summary of Monad architecture\"\n    />\n    <CustomDocCard\n        icon={<Consensus />}\n        link=\"/monad-arch/consensus\"\n        title=\"Consensus\"\n        description=\"MonadBFT, async execution, mempool, and other consensus details\"\n    />\n    <CustomDocCard\n        icon={<Execution />}\n        link=\"/monad-arch/execution\"\n        title=\"Execution\"\n        description=\"Optimistic parallel execution, MonadDB, and other execution details\"\n    />\n</CustomDocCardContainer>"
  },
  {
    "instruction": "What is covered in the 'Changelog' section of the Developer Essentials guide?",
    "output": "<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/developer-essentials/changelog\"\n        title=\"Testnet Changelog\"\n    />\n</CustomDocCardContainer>"
  },
  {
    "instruction": "What is covered in the 'Get Support' section of the Developer Essentials guide?",
    "output": "<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Discord />}\n        link=\"https://discord.gg/monaddev\"\n        title=\"Discord\"\n        description=\"Join other Monad developers on Discord\"\n    />\n    <CustomDocCard\n        icon={<Telegram />}\n        link=\"https://t.me/+06Kv7meSPn80M2U8\"\n        title=\"Telegram\"\n        description=\"Join other Monad developers on Telegram\"\n    />\n</CustomDocCardContainer>\n\n---\n\n# Best Practices for Building High Performance Apps\n\nURL: https://docs.monad.xyz/developer-essentials/best-practices.md\n\n# Best Practices for Building High Performance Apps"
  },
  {
    "instruction": "What is covered in the 'Configure web hosting to keep costs under control' section of the Developer Essentials guide?",
    "output": "- Vercel and Railway provide convenient serverless platforms for hosting your application, abstracting away the logistics of web hosting relative to using a cloud provider directly. You may end up paying a premium for the convenience, especially at higher volumes.\n- AWS and other cloud providers offer more flexibility and commodity pricing.\n- Before choosing any service, check pricing and be aware that many providers offer loss-leader pricing on lower volumes, but then charge higher rates once you hit a certain threshold.\n  - For example, suppose there is a $20 plan that includes 1 TB per month of data transfer, with $0.20 per GB beyond that. Be aware that the second TB (and onward) will cost $200. If the next tier up says \"contact us\", don't assume the next tier up will be charging $20 per TB.\n  - If you are building a high-traffic app and you aren't careful about serving static files more cheaply, it will be easy to exceed the loss-leader tier and pay much more than you expect.\n- For production deployments on AWS, consider:\n  - Amazon S3 + CloudFront for static file hosting and CDN\n  - AWS Lambda for serverless functions\n  - Amazon ECS or EKS for containerized applications\n  - Amazon RDS for database needs\n  - This setup typically provides granular cost control and scalability for high-traffic applications."
  },
  {
    "instruction": "What is covered in the 'Avoid unnecessary RPC calls to methods with static responses' section of the Developer Essentials guide?",
    "output": "- `eth_chainId` always returns `10143`\n- `eth_gasPrice` always returns `52 * 10^9`\n- `eth_maxPriorityFeePerGas` always returns `2 * 10^9`"
  },
  {
    "instruction": "What is covered in the 'Use a hardcoded value instead of `eth_estimateGas` call if gas usage is static' section of the Developer Essentials guide?",
    "output": "Many on-chain actions have a fixed gas cost. The simplest example is that a transfer of native tokens always costs 21,000 gas, but there are many others. This makes it unnecessary to call `eth_estimateGas` for each transaction.\n\nUse a hardcoded value instead, as suggested [here](docs/developer-essentials/gas-on-monad.md#set-the-gas-limit-explicitly-if-it-is-constant). Eliminating an `eth_estimateGas` call substantially speeds up the user workflow in the wallet, and avoids a potential bad behavior in some wallets when `eth_estimateGas` reverts (discussed in the linked page)."
  },
  {
    "instruction": "What is covered in the 'Reduce `eth_call` latency by submitting multiple requests concurrently' section of the Developer Essentials guide?",
    "output": "Making multiple `eth_call` requests serially will introduce unnecessary latency due to multiple round trips to an RPC node. You can make many `eth_call`s concurrently, either by condensing them into a single `eth_call` or by submitting a batch of calls. Alternatively, you might find it better to switch to an indexer.\n\n### Condensing multiple `eth_call`s into one\n- **Multicall:** Multicall is a utility smart contract that allows you to aggregate multiple read requests (`eth_call`) into a single one. This is particularly effective for fetching data points like token balances, allowances, or contract parameters simultaneously. The standard `Multicall3` contract is deployed on Monad Testnet at [`0xcA11bde05977b3631167028862bE2a173976CA11`](https://testnet.monadexplorer.com/address/0xcA11bde05977b3631167028862bE2a173976CA11). Many libraries offer helper functions to simplify multicall usage, e.g. [viem](https://viem.sh/docs/contract/multicall.html). Read more about `Multicall3` [here](https://www.multicall3.com).\n- **Custom Batching Contracts:** For complex read patterns or scenarios not easily handled by the standard multicall contract, you can deploy a custom smart contract that aggregates the required data in a single function, which can then be invoked via a single `eth_call`.\n\n:::note\nMulticall executes calls serially as you can see from the code [**here**](https://testnet.monadexplorer.com/address/0xcA11bde05977b3631167028862bE2a173976CA11?tab=Contract#file-Multicall3.sol). So while using multicall avoids multiple round trips to an RPC server, it is still inadvisable to put too many expensive calls into one multicall. A batch of calls (explained next) can be executed on the RPC in parallel.\n:::\n\n\n### Submitting a batch of calls\n\nMost major libraries support batching multiple RPC requests into a single message.\n\nFor example, `viem` handles `Promise.all()` on an array of promises by submitting them as a single batch:\n\n```\nconst resultPromises = Array(BATCH_SIZE)\n  .fill(null)\n  .map(async (_, i) => {\n    return await PUBLIC_CLIENT.simulateContract({\n        address: ...,\n        abi: ...,\n        functionName: ...,\n        args: [...],\n      })\n  })\nconst results = await Promise.all(resultPromises)\n```\n\n### Use indexers for read-heavy loads\n\nIf your application frequently queries historical events or derived state, consider using an indexer, as described next."
  },
  {
    "instruction": "What is covered in the 'Use an indexer instead of repeatedly calling `eth_getLogs` to listen for your events' section of the Developer Essentials guide?",
    "output": "Below is a quickstart guide for the most popular data indexing solutions. Please view the [indexer docs](/tooling-and-infra/indexers/) for more details.\n\n\n### Using Allium\n:::note\nSee also: [**Allium**](docs/tooling-and-infra/indexers/common-data.md#allium)\n\nYou'll need an Allium account, which you can request [here](https://www.allium.so/contact).\n:::\n\n- Allium Explorer\n    - Blockchain analytics platform that provides SQL-based access to historical blockchain data (blocks, transactions, logs, traces, and contracts).\n    - You can create Explorer APIs through the [GUI](https://app.allium.so/explorer/api) to query and analyze historical blockchain data. When creating a Query for an API [here](https://app.allium.so/explorer/queries) (using the `New` button), select `Monad Testnet` from the chain list.\n    - Relevant docs:\n        - [Explorer Documentation](https://docs.allium.so/data-products-analytics/allium-explorer)\n        - [Explorer API Tutorial](https://docs.allium.so/data-products-analytics/allium-explorer/explorer-api/explorer-api-user-tutorial)\n- Allium Datastreams\n    - Provides real-time blockchain data streams (including blocks, transactions, logs, traces, contracts, and balance snapshots) through Kafka, Pub/Sub, and Amazon SNS.\n    - [GUI](https://app.allium.so/developer/streams/new) to create new streams for onchain data. When creating a stream, select the relevant `Monad Testnet` topics from the `Select topics` dropdown.\n    - Relevant docs:\n        - [Datastreams Documentation](https://docs.allium.so/data-products-real-time/allium-datastreams)\n        - [Getting Started with Google Pub/Sub](https://docs.allium.so/data-products-real-time/allium-datastreams/kafka-pubsub/getting-started-with-google-pub-sub)\n- Allium Developers\n    - Enables fetching wallet transaction activity and tracking balances (native, ERC20, ERC721, ERC1155).\n    - For the request's body, use `monad_testnet` as the `chain` parameter.\n    - Relevant docs:\n        - [API Key Setup Guide](https://docs.allium.so/data-products-real-time/allium-developer/wallet-apis-1#getting-started)\n        - [Wallet APIs Documentation](https://docs.allium.so/data-products-real-time/allium-developer/wallet-apis)\n\n\n### Using Envio HyperIndex\n:::note\nSee also: [**Envio**](docs/tooling-and-infra/indexers/indexing-frameworks.md#envio) and [**Guide: How to use Envio HyperIndex to build a token transfer notification bot**](guides/indexers/tg-bot-using-envio.md)\n:::\n- Follow the [quick start](https://docs.envio.dev/docs/HyperIndex/contract-import) to create an indexer. In the `config.yaml` file, use network ID `10143` to select Monad Testnet.\n- Example configuration\n    - Sample `config.yaml` file\n        ```yaml\n        name: your-indexers-name\n        networks:\n        - id: 10143  # Monad Testnet\n          # Optional custom RPC configuration - only add if default indexing has issues\n          # rpc_config:\n          #   url: YOUR_RPC_URL_HERE  # Replace with your RPC URL (e.g., from Alchemy)\n          #   interval_ceiling: 50     # Maximum number of blocks to fetch in a single request\n          #   acceleration_additive: 10  # Speed up factor for block fetching\n          #   initial_block_interval: 10  # Initial block fetch interval size\n          start_block: 0  # Replace with the block you want to start indexing from\n          contracts:\n          - name: YourContract  # Replace with your contract name\n            address:\n            - 0x0000000000000000000000000000000000000000  # Replace with your contract address\n            # Add more addresses if needed for multiple deployments of the same contract\n            handler: src/EventHandlers.ts\n            events:\n            # Replace with your event signatures\n            # Format: EventName(paramType paramName, paramType2 paramName2, ...)\n            # Example: Transfer(address from, address to, uint256 amount)\n            # Example: OrderCreated(uint40 orderId, address owner, uint96 size, uint32 price, bool isBuy)\n            - event: EventOne(paramType1 paramName1, paramType2 paramName2)\n            # Add more events as needed\n        ```\n        \n    - Sample `EventHandlers.ts`\n        ```tsx\n        import {\n          YourContract,\n          YourContract_EventOne,\n        } from \"generated\";\n        \n        // Handler for EventOne\n        // Replace parameter types and names based on your event definition\n        YourContract.EventOne.handler(async ({ event, context }) => {\n          // Create a unique ID for this event instance\n          const entity: YourContract_EventOne = {\n            id: `${event.chainId}_${event.block.number}_${event.logIndex}`,\n            // Replace these with your actual event parameters\n            paramName1: event.params.paramName1,\n            paramName2: event.params.paramName2,\n            // Add any additional fields you want to store\n          };\n        \n          // Store the event in the database\n          context.YourContract_EventOne.set(entity);\n        })\n        \n        // Add more event handlers as needed\n        ```\n        \n- Important: The `rpc_config` section under a network (check `config.yaml` sample) is optional and should only be configured if you experience issues with the default Envio setup. This configuration allows you to:\n    - Use your own RPC endpoint\n    - Configure block fetching parameters for better performance\n- Relevant docs:\n    - [Overview](https://docs.envio.dev/docs/HyperIndex/overview)\n\n\n### Using GhostGraph\n:::note\nSee also: [**Ghost**](docs/tooling-and-infra/indexers/indexing-frameworks.md#ghost)\n:::\n- Relevant docs:\n    - [Getting Started](https://docs.tryghost.xyz/category/-getting-started)\n    - [Setting up a GhostGraph Indexer on Monad Testnet](/guides/indexers/ghost#setting-up-ghostgraph-indexing)\n\n\n### Using Goldsky\n:::note\nSee also: [**Goldsky**](docs/tooling-and-infra/indexers/common-data.md#goldsky)\n:::\n\n- Goldsky Subgraphs\n    - To deploy a Goldsky subgraph follow [this guide](https://docs.goldsky.com/subgraphs/deploying-subgraphs#from-source-code).\n    - As the network identifier please use `monad-testnet`. For subgraph configuration examples, refer to [The Graph Protocol section](#using-the-graphs-subgraph) below.\n    - For information about querying Goldsky subgraphs, see the [GraphQL API documentation](https://docs.goldsky.com/subgraphs/graphql-endpoints).\n- Goldsky Mirror\n    - Enables direct streaming of on-chain data to your database.\n    - For the chain name in the `dataset_name` field when creating a `source` for a pipeline, use `monad_testnet` (check below example)\n    - Example `pipeline.yaml` config file\n        ```yaml\n        name: monad-testnet-erc20-transfers\n        apiVersion: 3\n        sources:\n          monad_testnet_erc20_transfers:\n            dataset_name: monad_testnet.erc20_transfers\n            filter: address = '0x0' # Add erc20 contract address. Multiple addresses can be added with 'OR' operator: address = '0x0' OR address = '0x1'\n            version: 1.2.0\n            type: dataset\n            start_at: earliest\n        \n        # Data transformation logic (optional)\n        transforms:\n          select_relevant_fields:\n            sql: |\n              SELECT\n                  id,\n                  address,\n                  event_signature,\n                  event_params,\n                  raw_log.block_number as block_number,\n                  raw_log.block_hash as block_hash,\n                  raw_log.transaction_hash as transaction_hash\n              FROM\n                  ethereum_decoded_logs\n            primary_key: id\n        \n        # Sink configuration to specify where data goes eg. DB\n        sinks:\n          postgres:\n            type: postgres\n            table: erc20_transfers\n            schema: goldsky\n            secret_name: A_POSTGRESQL_SECRET\n            from: select_relevant_fields\n        ```\n    - Relevant docs:\n        - [Getting Started with Mirror](https://docs.goldsky.com/mirror/create-a-pipeline#goldsky-cli)\n        - [Data Streaming Guides](https://docs.goldsky.com/mirror/guides/)\n\n\n### Using QuickNode Streams\n:::note\nSee also: [**QuickNode Streams**](docs/tooling-and-infra/indexers/common-data.md#quicknode)\n:::\n\n- On your QuickNode Dashboard, select `Streams` > `Create Stream`. In the create stream UI, select Monad Testnet under Network. Alternatively, you can use the [Streams REST API](https://www.quicknode.com/docs/streams/rest-api/getting-started) to create and manage streams\u2014use `monad-testnet` as the network identifier.\n- You can consume a Stream by choosing a destination during stream creation. Supported destinations include Webhooks, S3 buckets, and PostgreSQL databases. Learn more [here](https://www.quicknode.com/docs/streams/destinations).\n- Relevant docs:\n    - [Getting Started](https://www.quicknode.com/docs/streams/getting-started)\n\n\n### Using The Graph's Subgraph\n:::note\nSee also: [**The Graph**](docs/tooling-and-infra/indexers/indexing-frameworks.md#the-graph)\n:::\n- Network ID to be used for Monad Testnet: `monad-testnet`\n- Example configuration\n    - Sample `subgraph.yaml` file\n        ```yaml\n        specVersion: 1.2.0\n        indexerHints:\n          prune: auto\n        schema:\n          file: ./schema.graphql\n        dataSources:\n          - kind: ethereum\n            name: YourContractName # Replace with your contract name\n            network: monad-testnet # Monad testnet configuration\n            source:\n              address: \"0x0000000000000000000000000000000000000000\" # Replace with your contract address\n              abi: YourContractABI # Replace with your contract ABI name\n              startBlock: 0 # Replace with the block where your contract was deployed/where you want to index from\n            mapping:\n              kind: ethereum/events\n              apiVersion: 0.0.9\n              language: wasm/assemblyscript\n              entities:\n                # List your entities here - these should match those defined in schema.graphql\n                # - Entity1\n                # - Entity2\n              abis:\n                - name: YourContractABI # Should match the ABI name specified above\n                  file: ./abis/YourContract.json # Path to your contract ABI JSON file\n              eventHandlers:\n                # Add your event handlers here, for example:\n                # - event: EventName(param1Type, param2Type, ...)\n                #   handler: handleEventName\n              file: ./src/mapping.ts # Path to your event handler implementations\n        ```\n        \n    - Sample `mappings.ts` file\n        ```tsx\n        import {\n          // Import your contract events here\n          // Format: EventName as EventNameEvent\n          EventOne as EventOneEvent,\n          // Add more events as needed\n        } from \"../generated/YourContractName/YourContractABI\" // Replace with your contract name, abi name you supplied in subgraph.yaml\n        \n        import {\n          // Import your schema entities here\n          // These should match the entities defined in schema.graphql\n          EventOne,\n          // Add more entities as needed\n        } from \"../generated/schema\"\n        \n        /**\n          * Handler for EventOne\n          * Update the function parameters and body according to your event structure\n          */\n        export function handleEventOne(event: EventOneEvent): void {\n          // Create a unique ID for this entity\n          let entity = new EventOne(\n            event.transaction.hash.concatI32(event.logIndex.toI32())\n          )\n          \n          // Map event parameters to entity fields\n          // entity.paramName = event.params.paramName\n          \n          // Example:\n          // entity.sender = event.params.sender\n          // entity.amount = event.params.amount\n        \n          // Add metadata fields\n          entity.blockNumber = event.block.number\n          entity.blockTimestamp = event.block.timestamp\n          entity.transactionHash = event.transaction.hash\n        \n          // Save the entity to the store\n          entity.save()\n        }\n        \n        /**\n          * Add more event handlers as needed\n          * Format:\n          * \n          * export function handleEventName(event: EventNameEvent): void {\n          *   let entity = new EventName(\n          *     event.transaction.hash.concatI32(event.logIndex.toI32())\n          *   )\n          *   \n          *   // Map parameters\n          *   entity.param1 = event.params.param1\n          *   entity.param2 = event.params.param2\n          *   \n          *   // Add metadata\n          *   entity.blockNumber = event.block.number\n          *   entity.blockTimestamp = event.block.timestamp\n          *   entity.transactionHash = event.transaction.hash\n          *   \n          *   entity.save()\n          * }\n          */\n        ```\n        \n    - Sample `schema.graphql` file\n        ```graphql\n        # Define your entities here\n        # These should match the entities listed in your subgraph.yaml\n        \n        # Example entity for a generic event\n        type EventOne @entity(immutable: true) {\n          id: Bytes!\n          \n          # Add fields that correspond to your event parameters\n          # Examples with common parameter types:\n          # paramId: BigInt!              # uint256, uint64, etc.\n          # paramAddress: Bytes!          # address\n          # paramFlag: Boolean!           # bool\n          # paramAmount: BigInt!          # uint96, etc.\n          # paramPrice: BigInt!           # uint32, etc.\n          # paramArray: [BigInt!]!        # uint[] array\n          # paramString: String!          # string\n          \n          # Standard metadata fields\n          blockNumber: BigInt!\n          blockTimestamp: BigInt!\n          transactionHash: Bytes!\n        }\n        \n        # Add more entity types as needed for different events\n        # Example based on Transfer event:\n        # type Transfer @entity(immutable: true) {\n        #   id: Bytes!\n        #   from: Bytes!                  # address\n        #   to: Bytes!                    # address\n        #   tokenId: BigInt!              # uint256\n        #   blockNumber: BigInt!\n        #   blockTimestamp: BigInt!\n        #   transactionHash: Bytes!\n        # }\n        \n        # Example based on Approval event:\n        # type Approval @entity(immutable: true) {\n        #   id: Bytes!\n        #   owner: Bytes!                 # address\n        #   approved: Bytes!              # address\n        #   tokenId: BigInt!              # uint256\n        #   blockNumber: BigInt!\n        #   blockTimestamp: BigInt!\n        #   transactionHash: Bytes!\n        # }\n- Relevant docs:\n    - [Quickstart](https://thegraph.com/docs/en/subgraphs/quick-start/)\n\n### Using thirdweb's Insight API\n:::note\nSee also: [**thirdweb**](docs/tooling-and-infra/indexers/common-data.md#thirdweb)\n:::\n\n- REST API offering a wide range of on-chain data, including events, blocks, transactions, token data (such as transfer transactions, balances, and token prices), contract details, and more.\n- Use chain ID `10143` for Monad Testnet when constructing request URLs.\n    - Example: `https://insight.thirdweb.com/v1/transactions?chain=10143`\n- Relevant docs:\n    - [Get started](https://portal.thirdweb.com/insight/get-started)\n    - [API playground](https://playground.thirdweb.com/insight)"
  },
  {
    "instruction": "What is covered in the 'Manage nonces locally if sending multiple transactions in quick succession' section of the Developer Essentials guide?",
    "output": ":::note\nThis only applies if you are setting nonces manually. If you are delegating this to the wallet, no need to worry about this.\n:::\n\n- `eth_getTransactionCount` only updates after a transaction is finalized. If you have multiple transactions from the same wallet in short succession, you should implement local nonce tracking."
  },
  {
    "instruction": "What is covered in the 'Submit multiple transactions concurrently' section of the Developer Essentials guide?",
    "output": "If you are submitting a series of transactions, instead submitting sequentially, implement concurrent transaction submission for improved efficiency.\n\nBefore:\n\n```jsx\nfor (let i = 0; i < TIMES; i++) {\n  const tx_hash = await WALLET_CLIENT.sendTransaction({\n    account: ACCOUNT,\n    to: ACCOUNT_1,\n    value: parseEther('0.1'),\n    gasLimit: BigInt(21000),\n    baseFeePerGas: BigInt(50000000000),\n    chain: CHAIN,\n    nonce: nonce + Number(i),\n  })\n}\n```\n\nAfter:\n\n```jsx\nconst transactionsPromises = Array(BATCH_SIZE)\n  .fill(null)\n  .map(async (_, i) => {\n    return await WALLET_CLIENT.sendTransaction({\n      to: ACCOUNT_1,\n      value: parseEther('0.1'),\n      gasLimit: BigInt(21000),\n      baseFeePerGas: BigInt(50000000000),\n      chain: CHAIN,\n      nonce: nonce + Number(i),\n    })\n  })\nconst hashes = await Promise.all(transactionsPromises)\n```\n---\n\n# Testnet Changelog"
  },
  {
    "instruction": "What is covered in the 'v0.9.0 [2025-03-14]' section of the Developer Essentials guide?",
    "output": "Notable user-facing changes:\n* Max contract size increased to 128kb from 24kb (enabled 3/14/25 19:00 GMT)\n  * [example 123 kb contract](https://testnet.monadexplorer.com/address/0x0E820425e07E4a992C661E4B970e13002d6e52B9?tab=Contract)\n\nNotable internal changes:\n* Improvements to RPC performance for `eth_call`\n* Fixed a bug in `debug_traceTransaction`. Previously, within a transaction, only the first 100 calls were being traced\n* Dataplane v2 - simpler and more efficient implementation; small performance improvement in broadcast time\n* Statesync improvements to mitigate negative performance effects on upstream validator nodes"
  },
  {
    "instruction": "What is covered in the 'v0.8.1 [2025-02-14]' section of the Developer Essentials guide?",
    "output": "Notable user-facing changes:\n* Block time reduced to 500 ms from 1s (enabled 2/14/25 19:00 GMT)\n* Block gas limit reduced to 150M from 300M (to keep gas limit consistent) (enabled 2/14/25 19:00 GMT)\n* Transactions are charged based on gas limit, not gas consumed (enabled 2/14/25 19:00 GMT)\n\nNotable internal changes:\n* UX improvements for transaction status. RPC nodes track status of transactions submitted to them in order to provide updates to users.\n---\n\n# Differences between Monad and Ethereum"
  },
  {
    "instruction": "What is covered in the 'Transactions' section of the Developer Essentials guide?",
    "output": "1. Transactions are charged based on gas limit rather than gas usage, i.e. total tokens deducted from the sender's balance is `value + gas_price * gas_limit`. As discussed in [Gas in Monad](docs/developer-essentials/gas-on-monad.md), this is a DOS-prevention measure for asynchronous execution. This may be revised before mainnet.\n\n2. Transaction type 3 (EIP-4844 type aka blob transactions) are not supported. This is temporary.\n\n3. Max contract size is 128kb (up from 24kb in Ethereum).\n\n4. There is no global mempool. For efficiency, transactions are forwarded to the next few leaders as described in [Local Mempool](/monad-arch/consensus/local-mempool)."
  },
  {
    "instruction": "What is covered in the 'RPC' section of the Developer Essentials guide?",
    "output": "See: [RPC Differences](/reference/rpc-differences)\n\n---\n\n# Faucet"
  },
  {
    "instruction": "What is covered in the 'Monad Faucet' section of the Developer Essentials guide?",
    "output": ""
  },
  {
    "instruction": "What is covered in the 'Phantom Faucet' section of the Developer Essentials guide?",
    "output": "---\n\n# Gas on Monad\n\nGas pricing is the same on Monad as on Ethereum.\n\nThere is one difference: the gas charged for a transaction is the **gas limit**, not the gas used. This behavior is on Monad Testnet and is being actively evaluated for mainnet."
  },
  {
    "instruction": "What is covered in the 'Quick Hits' section of the Developer Essentials guide?",
    "output": "| Feature | Detail |\n| --- | --- |\n| **Opcode pricing** | All opcodes cost the same amount of gas as on Ethereum, see [reference](https://www.evm.codes/).<br/> For example, `ADD` costs 3 gas. |\n| **EIP-1559** | Monad is EIP-1559-compatible; base fee and priority fee work as on Ethereum. See [this section](#gas-price-detail) for details. |\n| **Base fee** | Hard-coded to 50 monad gwei (i.e. `50 * 10^-9 MON`) per unit of gas on testnet.<br/> This will become dynamic in the future. |\n| **Transaction ordering** | Default Monad client behavior is that transactions are ordered according to a Priority Gas Auction (descending total gas price).\n| **Gas charged** | The gas charged for a transaction is the **gas limit**. That is: total tokens deducted from the sender's balance is `value + gas_price * gas_limit`. This is a DOS-prevention measure for asynchronous execution, see [discussion](#why-charge-gas-limit-rather-than-gas-used) below. |"
  },
  {
    "instruction": "What is covered in the 'Definitions' section of the Developer Essentials guide?",
    "output": "A common point of confusion among users is the distinction between **gas** of a transaction (units of work) and the **gas price** of a transaction (price in native tokens per unit of work). \n\n| Feature | Definition |\n| --- | --- |\n| **Gas** | A unit of work. Gas measures the amount of work the network has to do to process something.<br/><br/> Since the network has multiple kinds of resources (network bandwidth, CPU, SSD bandwidth, and state growth), gas is inherently a projection from many dimensions into a single one. |\n| **Gas price (price_per_gas)** | The **price** (in native tokens) paid **to process one unit** of gas. |\n| **Gas limit** | The maximum **number of units of gas** that a transaction is allowed to consume.<br/><br/> When a user signs a transaction, the transaction specifies a gas limit and a price limit (tokens-per-gas limit). Since `tokens_spent = tokens_per_gas * gas`, the user is signing off on a maximum amount of native tokens they are willing to spend on the transaction. |\n\n### Gas price detail\n\n[This](https://www.blocknative.com/blog/eip-1559-fees) article provides a good explanation of EIP-1559 gas pricing. A summary follows.\n\nGas price is expressed using three parameters: `base_price_per_gas`, `priority_price_per_gas`, and `max_price_per_gas`. \n* `base_price_per_gas` is a network-determined parameter. Every transaction in the same block will have the same `base_price_per_gas`\n* Users specify `priority_price_per_gas` and `max_price_per_gas` when signing a transaction\n* When a transaction is included, the `price_per_gas` paid is the minimum of `max_price_per_gas` and `base_price_per_gas + priority_price_per_gas`\n* Since everyone in the same block will pay the same `base_price_per_gas`, the `priority_price_per_gas` is a way for users to pay more to prioritize their transactions.\n* Since users don't determine `base_price_per_gas`, the `max_price_per_gas` is a safeguard that limits the amount they may end up paying. Of course, if that value is set too low, the transaction will not end up being chosen for inclusion.\n\nOn Monad Testnet, these dynamics still apply, but `base_price_per_gas` is set to a static value of 50 monad gwei.\n\nThis means that `price_per_gas` is the minimum of `max_price_per_gas` and `50 * 10^9 wei + priority_price_per_gas`; users can set either parameter to achieve the same effect."
  },
  {
    "instruction": "What is covered in the 'Why charge gas limit rather than gas used?' section of the Developer Essentials guide?",
    "output": "Asynchronous execution means that leaders build blocks (and validators vote on block validity) prior to executing the transactions. \n\nIf the protocol charged `gas_used`, a user could submit a transaction with a large `gas_limit` that actually consumes very little gas. This transaction would take up a lot of space toward the block gas limit but wouldn't pay very much for taking up that space, opening up a DOS vector.\n\nThe pricing formula is being actively discussed and may change before mainnet."
  },
  {
    "instruction": "What is covered in the 'Recommendations for developers' section of the Developer Essentials guide?",
    "output": "### Set the gas limit explicitly if it is constant\n\nMany on-chain actions have a fixed gas cost. The simplest example is that a transfer of native tokens always costs 21,000 gas, but there are many others.\n\nFor actions where the gas cost of the transaction is known ahead of time, it is recommended to set it directly prior to handing the transaction off to the wallet. This offers several benefits:\n* It reduces latency and gives users a better experience, since the wallet doesn't have to call `eth_estimateGas` and wait for the RPC to respond.\n* It retains greater control over the user experience, avoiding cases where the wallet sets a high gas limit in a corner case as described in the warning below.\n\n:::warning\nSome wallets, including MetaMask, are known to have the following behavior: when `eth_estimateGas` is called and the contract call reverts, they set the gas limit for this transaction to a very high value.\n\nThis is the wallet's way of giving up on setting the gas limit and accepting whatever gas usage is at execution time. However, it doesn't make sense on Monad Testnet where the gas limit is charged.\n\nContract call reversion happens whenever the user is trying to do something impossible. For example, a user might be trying to mint an NFT that has minted out.\n\nIf the gas limit is known ahead of time, setting it explicitly is best practice, since it ensures the wallet won't handle this case unexpectedly.\n:::\n---\n\n# Network Information"
  },
  {
    "instruction": "What is covered in the 'Monad Testnet' section of the Developer Essentials guide?",
    "output": "| Name               | Value                                                                  |\n| ------------------ | ---------------------------------------------------------------------- |\n| Network Name       | Monad Testnet                                                          |\n| Chain ID           | 10143                                                                  |\n| Currency Symbol    | MON                                                                    |\n| RPC Endpoint ([reference](/reference/json-rpc)) | [https://testnet-rpc.monad.xyz](https://testnet-rpc.monad.xyz)         |\n| Block Explorer     | [https://testnet.monadexplorer.com](https://testnet.monadexplorer.com) |\n\n### Helpful Links\n\n| Name                  | URL                                                                |\n| --------------------- | ------------------------------------------------------------------ |\n| Testnet Hub & Faucet  | [https://testnet.monad.xyz](https://testnet.monad.xyz)             |\n| Ecosystem Directory   | [https://www.monad.xyz/ecosystem](https://www.monad.xyz/ecosystem) |\n| Network Visualization | [https://gmonads.com](https://gmonads.com)                         |\n\n### Canonical Contracts on Testnet\n\n| Name                 | Address                                    |\n| -------------------- | ------------------------------------------ \n| CreateX      | [0xba5Ed099633D3B313e4D5F7bdc1305d3c28ba5Ed](https://testnet.monadexplorer.com/address/0xba5Ed099633D3B313e4D5F7bdc1305d3c28ba5Ed) |\n| Foundry Deterministic Deployer | [0x4e59b44847b379578588920ca78fbf26c0b4956c](https://testnet.monadexplorer.com/address/0x4e59b44847b379578588920cA78FbF26c0B4956C) |\n| EntryPoint v0.6      | [0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789](https://testnet.monadexplorer.com/address/0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789) | |\n| EntryPoint v0.7      | [0x0000000071727De22E5E9d8BAf0edAc6f37da032](https://testnet.monadexplorer.com/address/0x0000000071727De22E5E9d8BAf0edAc6f37da032) |\n| Multicall3   | [0xcA11bde05977b3631167028862bE2a173976CA11](https://testnet.monadexplorer.com/address/0xcA11bde05977b3631167028862bE2a173976CA11) |\n| Permit2              | [0x000000000022d473030f116ddee9f6b43ac78ba3](https://testnet.monadexplorer.com/address/0x000000000022d473030f116ddee9f6b43ac78ba3) |\n| SafeSingletonFactory | [0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7](https://testnet.monadexplorer.com/address/0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7) |\n| UniswapV2Factory  | [0x733e88f248b742db6c14c0b1713af5ad7fdd59d0](https://testnet.monadexplorer.com/address/0x733e88f248b742db6c14c0b1713af5ad7fdd59d0) |\n| UniswapV3Factory  | [0x961235a9020b05c44df1026d956d1f4d78014276](https://testnet.monadexplorer.com/address/0x961235a9020b05c44df1026d956d1f4d78014276) |\n| UniswapV2Router02 | [0xfb8e1c3b833f9e67a71c859a132cf783b645e436](https://testnet.monadexplorer.com/address/0xfb8e1c3b833f9e67a71c859a132cf783b645e436) |\n| Uniswap UniversalRouter   | [0x3ae6d8a282d67893e17aa70ebffb33ee5aa65893](https://testnet.monadexplorer.com/address/0x3ae6d8a282d67893e17aa70ebffb33ee5aa65893) |\n| WrappedMonad | [0x760AfE86e5de5fa0Ee542fc7B7B713e1c5425701](https://testnet.monadexplorer.com/address/0x760AfE86e5de5fa0Ee542fc7B7B713e1c5425701) |\n\nSee also:\n* [Uniswap deployments](https://github.com/Uniswap/contracts/blob/bf676eed3dc31b18c70aba61dcc6b3c6e4d0028f/deployments/10143.md)\n\n### Testnet Tokens (partial list)\n\n| Name                 | Address                                    |\n| -------------------- | ------------------------------------------ \n| USDC (testnet) | [0xf817257fed379853cDe0fa4F97AB987181B1E5Ea](https://testnet.monadexplorer.com/address/0xf817257fed379853cDe0fa4F97AB987181B1E5Ea) |\n| USDT (testnet) | [0x88b8E2161DEDC77EF4ab7585569D2415a1C1055D](https://testnet.monadexplorer.com/address/0x88b8E2161DEDC77EF4ab7585569D2415a1C1055D) |\n| WBTC (testnet) | [0xcf5a6076cfa32686c0Df13aBaDa2b40dec133F1d](https://testnet.monadexplorer.com/address/0xcf5a6076cfa32686c0Df13aBaDa2b40dec133F1d) |\n| WETH (testnet) | [0xB5a30b0FDc5EA94A52fDc42e3E9760Cb8449Fb37](https://testnet.monadexplorer.com/address/0xB5a30b0FDc5EA94A52fDc42e3E9760Cb8449Fb37) |\n| WSOL (testnet) | [0x5387C85A4965769f6B0Df430638a1388493486F1](https://testnet.monadexplorer.com/address/0x5387C85A4965769f6B0Df430638a1388493486F1) |\n\n### Supported Infrastructure on Testnet\n\nSee the [Tooling and Infrastructure](tooling-and-infra/README.md) page for a list of providers supporting testnet.\n---\n\n# Guides\n\nStart building smart contracts and applications on Monad with our quickstart guides."
  },
  {
    "instruction": "What is covered in the 'Get a wallet' section of the Developer Essentials guide?",
    "output": "<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Phantom />}\n        link=\"https://phantom.com/download\"\n        title=\"Phantom\"\n    />\n    <CustomDocCard\n        icon={<Metamask />}\n        link=\"https://metamask.io/download/\"\n        title=\"Metamask\"\n    />\n</CustomDocCardContainer>"
  },
  {
    "instruction": "What is covered in the 'Deploy Smart Contract' section of the Developer Essentials guide?",
    "output": "<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Foundry />}\n        link=\"/guides/deploy-smart-contract/foundry\"\n        title=\"Foundry\"\n        description=\"Deploy a smart contract on Monad using Foundry\"\n    />\n    <CustomDocCard\n        icon={<Hardhat />}\n        link=\"/guides/deploy-smart-contract/hardhat\"\n        title=\"Hardhat\"\n        description=\"Deploy a smart contract on Monad using Hardhat\"\n    />\n    <CustomDocCard\n        icon={<Remix />}\n        link=\"/guides/deploy-smart-contract/remix\"\n        title=\"Remix\"\n        description=\"Deploy a smart contract on Monad using Remix\"\n    />\n</CustomDocCardContainer>"
  },
  {
    "instruction": "What is covered in the 'Verify Smart Contract' section of the Developer Essentials guide?",
    "output": "<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Foundry />}\n        link=\"/guides/verify-smart-contract/foundry\"\n        title=\"Foundry\"\n        description=\"Verify a smart contract on Monad using Foundry\"\n    />\n    <CustomDocCard\n        icon={<Hardhat />}\n        link=\"/guides/verify-smart-contract/hardhat\"\n        title=\"Hardhat\"\n        description=\"Verify a smart contract on Monad using Hardhat\"\n    />\n</CustomDocCardContainer>"
  },
  {
    "instruction": "What is covered in the 'Indexing' section of the Developer Essentials guide?",
    "output": "<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/guides/indexers/ghost\"\n        title=\"GhostGraph\"\n        description=\"Index transfers with GhostGraph\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/guides/indexers/tg-bot-using-envio\"\n        title=\"Envio\"\n        description=\"Index transfers for a telegram bot using Envio\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/guides/indexers/quicknode-streams\"\n        title=\"QuickNode Streams\"\n        description=\"Index transfers using QuickNode Streams\"\n    />\n</CustomDocCardContainer>\n\n\n{/* TODO: Add Developer Tools & Infra */}\n{/* ## Developer Tools & Infra */}"
  },
  {
    "instruction": "What is covered in the 'Connectivity' section of the Developer Essentials guide?",
    "output": "<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/guides/reown-guide\"\n        title=\"Reown AppKit\"\n        description=\"Connect a wallet to your app with Reown AppKit\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/guides/blinks-guide\"\n        title=\"Blinks\"\n        description=\"Build a donation blink\"\n    />\n</CustomDocCardContainer>"
  },
  {
    "instruction": "What is covered in the 'AI' section of the Developer Essentials guide?",
    "output": "<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/guides/monad-mcp\"\n        title=\"MCP Server\"\n        description=\"Build an MCP server to interact with Monad Testnet\"\n    />\n</CustomDocCardContainer>\n---\n\n# Add Monad to Your Wallet\n---\n\n# Add Monad Testnet to MetaMask\n\nFollow this quick guide to add Monad Testnet to your MetaMask wallet.\n\n1. Open MetaMask\n\n![open metamask](/img/guides/add-monad-to-wallet/metamask/1.png)\n\n2. Click on the \"Add a Custom Network\" button.\n\n![add custom network](/img/guides/add-monad-to-wallet/metamask/2.png)\n\n3. Add the Network name, add a RPC URL by clicking the \"Add RPC URL\" button.\n\n![add network name](/img/guides/add-monad-to-wallet/metamask/3.png)\n\n4. Enter the RPC details.\n\n```\nhttps://testnet-rpc.monad.xyz\n```\n\n![add rpc details](/img/guides/add-monad-to-wallet/metamask/4.png)\n\n5. Enter the Chain ID, Currency Symbol, add the Block Explorer URL by clicking the \"Add a block explorer URL\" button.\n\n![add chain id explorer](/img/guides/add-monad-to-wallet/metamask/5.png)\n\n6. Enter the Block Explorer URL\n\n```\nhttps://testnet.monadexplorer.com\n```\n\n![add block explorer](/img/guides/add-monad-to-wallet/metamask/6.png)\n\n7. Finally you can click on the \"Save\" button.\n\n![save](/img/guides/add-monad-to-wallet/metamask/7.png)\n\n8. You should see a success message.\n\n![monad testnet sucess message](/img/guides/add-monad-to-wallet/metamask/8.png)\n\n9. You can now see and use the Monad Testnet network in your MetaMask wallet.\n\n![monad testnet](/img/guides/add-monad-to-wallet/metamask/9.png)\n\n10. You should be able to see your Monad Testnet assets.\n\n![monad testnet assets](/img/guides/add-monad-to-wallet/metamask/10.png)\n\n\nThe next step is to get MON tokens from the Monad Testnet Faucet.\n---\n\n# How to build a donation blink\n\nURL: https://docs.monad.xyz/guides/blinks-guide.md\n\nIn this guide, you will learn how to build a [Blink](https://www.dialect.to/) that allows people to donate MON with a single click."
  },
  {
    "instruction": "What is covered in the 'Prerequisites' section of the Developer Essentials guide?",
    "output": "- Code Editor of your choice ([Cursor](https://www.cursor.com/) or [Visual Studio Code](https://code.visualstudio.com/) recommended).\n- [Node](https://nodejs.org/en/download) 18.x.x or above.\n- Basic TypeScript knowledge.\n- Testnet MON ([Faucet](https://testnet.monad.xyz))."
  },
  {
    "instruction": "What is covered in the 'Initial setup' section of the Developer Essentials guide?",
    "output": "### Initialize the project\n\n```bash\nnpx create-next-app@14 blink-starter-monad && cd blink-starter-monad\n```\n\n**When prompted, configure your project with these settings:**\n\n- \u2713 Ok to proceed? \u2192 Yes\n- \u2713 Would you like to use TypeScript? \u2192 Yes\n- \u2713 Would you like to use ESLint? \u2192 Yes\n- \u2713 Would you like to use Tailwind CSS? \u2192 Yes\n- \u2713 Would you like your code inside a `src/` directory? \u2192 Yes\n- \u2713 Would you like to use App Router? \u2192 Yes\n- \u2713 Would you like to customize the import alias (`@/*` by default)? \u2192 No\n\n### Install dependencies\n\n```bash\nnpm install @solana/actions wagmi viem@2.x\n```\n\n### Start development server\n\nThe development server is used to start a local test environment that runs on your computer. It is perfect to test and develop your blink, before you ship it to production.\n\n```bash\nnpm run dev\n```"
  },
  {
    "instruction": "What is covered in the 'Building the Blink' section of the Developer Essentials guide?",
    "output": "Now that we have our basic setup finished, it is time to start building the blink.\n\n### Create an endpoint\n\nTo write a blink provider, you have to create an endpoint. Thanks to NextJS, this all works pretty straightforward. All you have to do is to create the following folder structure:\n\n```\nsrc/\n\u2514\u2500\u2500 app/\n    \u2514\u2500\u2500 api/\n            \u2514\u2500\u2500 actions/\n                \u2514\u2500\u2500 donate-mon/\n                    \u2514\u2500\u2500 route.ts\n```\n\n### Create actions.json\n\nCreate a route in `app` folder for the `actions.json` file which will be hosted in the root directory of our application. This file is needed to tell other applications which blink providers are available on your website. **Think of it as a sitemap for blinks.** \n\nYou can read more about the [actions.json](https://docs.dialect.to/documentation/actions/specification/actions.json) in the official [Dialect documentation](https://docs.dialect.to/documentation/actions/specification/actions.json).\n\n\n```\nsrc/\n\u2514\u2500\u2500 app/\n    \u2514\u2500\u2500 actions.json/\n        \u2514\u2500\u2500 route.ts\n```\n\n```js\n// src/app/actions.json/route.ts\n\nexport const GET = async () => {\n  const payload: ActionsJson = {\n    rules: [\n      // map all root level routes to an action\n      {\n        pathPattern: \"/*\",\n        apiPath: \"/api/actions/*\",\n      },\n      // idempotent rule as the fallback\n      {\n        pathPattern: \"/api/actions/**\",\n        apiPath: \"/api/actions/**\",\n      },\n    ],\n  };\n\n  return Response.json(payload, {\n    headers: ACTIONS_CORS_HEADERS,\n  });\n};\n\n// DO NOT FORGET TO INCLUDE THE `OPTIONS` HTTP METHOD\n// THIS WILL ENSURE CORS WORKS FOR BLINKS\nexport const OPTIONS = GET;\n```\n\n### Add an image for the blink\n\nEvery blink has an image that is rendered on top. If you have your image already hosted somewhere, you can skip this step but if you haven't you can just create a `public` folder in your `NextJS` project and paste an image there.\n\nIn our example we will paste a file called `donate-mon.png` into this public folder. You can right-click and save the image below.\n\n![donate-mon](/img/guides/blinks-guide/donate-mon.png)\n\n![image](/img/guides/blinks-guide/1.png)\n\n### OPTIONS endpoint and headers\n\nThis enables CORS for cross-origin requests and standard headers for the API endpoints. This is standard configuration you do for every Blink.\n\n```js\n// src/app/api/actions/donate-mon/route.ts\n\n// CAIP-2 format for Monad\nconst blockchain = `eip155:10143`;\n\n// Create headers with CAIP blockchain ID\nconst headers = {\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n  \"Access-Control-Allow-Headers\":\n  \"Content-Type, x-blockchain-ids, x-action-version\",\n  \"Content-Type\": \"application/json\",\n  \"x-blockchain-ids\": blockchain,\n  \"x-action-version\": \"2.0\",\n};\n\n// OPTIONS endpoint is required for CORS preflight requests\n// Your Blink won't render if you don't add this\nexport const OPTIONS = async () => {\n  return new Response(null, { headers });\n};\n```\n\n### GET endpoint\n\n`GET` returns the Blink metadata and UI configuration. \n\nIt describes:\n\n- How the Action appears in Blink clients\n- What parameters users need to provide\n- How the Action should be executed\n\n```js\n// src/app/api/actions/donate-mon/route.ts\n\n// GET endpoint returns the Blink metadata (JSON) and UI configuration\nexport const GET = async (req: Request) => {\n  // This JSON is used to render the Blink UI\n  const response: ActionGetResponse = {\n    type: \"action\",\n    icon: `${new URL(\"/donate-mon.png\", req.url).toString()}`,\n    label: \"1 MON\",\n    title: \"Donate MON\",\n    description:\n      \"This Blink demonstrates how to donate MON on the Monad blockchain. It is a part of the official Blink Starter Guides by Dialect Labs.  \\n\\nLearn how to build this Blink: https://dialect.to/docs/guides/donate-mon\",\n    // Links is used if you have multiple actions or if you need more than one params\n    links: {\n      actions: [\n        {\n          // Defines this as a blockchain transaction\n          type: \"transaction\",\n          label: \"0.01 MON\",\n          // This is the endpoint for the POST request\n          href: `/api/actions/donate-mon?amount=0.01`,\n        },\n        {\n          type: \"transaction\",\n          label: \"0.05 MON\",\n          href: `/api/actions/donate-mon?amount=0.05`,\n        },\n        {\n          type: \"transaction\",\n          label: \"0.1 MON\",\n          href: `/api/actions/donate-mon?amount=0.1`,\n        },\n        {\n          // Example for a custom input field\n          type: \"transaction\",\n          href: `/api/actions/donate-mon?amount={amount}`,\n          label: \"Donate\",\n          parameters: [\n            {\n              name: \"amount\",\n              label: \"Enter a custom MON amount\",\n              type: \"number\",\n            },\n          ],\n        },\n      ],\n    },\n  };\n\n  // Return the response with proper headers\n  return new Response(JSON.stringify(response), {\n    status: 200,\n    headers,\n  });\n};\n```\n\n### Testing the Blink\n\nVisit [dial.to](https://dial.to) and type in the link to your blink to see if it works. If your server runs on localhost:3000 the url should be like this: `http://localhost:3000/api/actions/donate-mon`\n\n:::info\n[dial.to](https://dial.to) currently supports only GET previews for EVM. To test your POST endpoint, we need to build a Blink Client.\n:::\n\n![testing blink](/img/guides/blinks-guide/2.png)\n\n\n### POST endpoint\n\n`POST` handles the actual MON transfer transaction.\n\n#### POST request to the endpoint\n\nCreate the post request structure and add the necessary imports as well as the `donationWallet` on top of the file.\n\n```js\n//src/app/api/actions/donate-mon/route.ts\n\n// Update the imports\n// Wallet address that will receive the donations\nconst donationWallet = `<RECEIVER_ADDRESS>`;\n\n\n// POST endpoint handles the actual transaction creation\nexport const POST = async (req: Request) => {\n  try {\n  \n  // Code that goes here is in the next step\n  \n  } catch (error) {\n    // Log and return an error response\n    console.error(\"Error processing request:\", error);\n    return new Response(JSON.stringify({ error: \"Internal server error\" }), {\n      status: 500,\n      headers,\n    });\n  }\n};\n```\n\n#### Extract data from request\n\nThe request contains the URL and the account (PublicKey) from the payer.\n\n```js\n// src/app/api/actions/donate-mon/route.ts\n\n// POST endpoint handles the actual transaction creation\nexport const POST = async (req: Request) => {\n  try {\n    // Step 1\n    // Extract amount from URL\n    const url = new URL(req.url);\n    const amount = url.searchParams.get(\"amount\");\n\n    if (!amount) {\n        throw new Error(\"Amount is required\");\n    }\n\n  } catch (error) {\n    // Error handling\n  }\n}\n```\n\n#### Create the transaction\n\nCreate a new transaction with all the necessary data and add it below in the `POST` request.\n\n```js\n// src/app/api/actions/donate-mon/route.ts\n\n// POST endpoint handles the actual transaction creation\nexport const POST = async (req: Request) => {\n  try {\n\n    // ... previous code from step\n    \n    // Build the transaction\n    const transaction = {\n        to: donationWallet,\n        value: parseEther(amount).toString(),\n        chainId: 10143,\n    };\n\n    const transactionJson = serialize(transaction);\n  \n  } catch (error) {\n    // Error handling\n  }\n}\n```\n\n#### Return the transaction in response.\n\nCreate `ActionPostResponse` and return it to the client.\n\n```ts\n// src/app/api/actions/donate-mon/route.ts\n\nexport const POST = async (req: Request) => {\n  try {\n    // ... previous code from step 1 and 2\n    \n    // Build ActionPostResponse\n    const response: ActionPostResponse = {\n        type: \"transaction\",\n        transaction: transactionJson,\n        message: \"Donate MON\",\n    };\n\n    // Return the response with proper headers\n    return new Response(JSON.stringify(response), {\n        status: 200,\n        headers,\n    });\n\n  } catch (error) {\n    // Error handling\n  }\n}\n```\n\n### Full code in `route.ts`\n\n```ts\n// CAIP-2 format for Monad\nconst blockchain = `eip155:10143`;\n\n// Wallet address that will receive the donations\nconst donationWallet = `<RECEIVER_ADDRESS>`;\n\n// Create headers with CAIP blockchain ID\nconst headers = {\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n  \"Access-Control-Allow-Headers\":\n  \"Content-Type, x-blockchain-ids, x-action-version\",\n  \"Content-Type\": \"application/json\",\n  \"x-blockchain-ids\": blockchain,\n  \"x-action-version\": \"2.0\",\n};\n\n// OPTIONS endpoint is required for CORS preflight requests\n// Your Blink won't render if you don't add this\nexport const OPTIONS = async () => {\n  return new Response(null, { headers });\n};\n\n// GET endpoint returns the Blink metadata (JSON) and UI configuration\nexport const GET = async (req: Request) => {\n  // This JSON is used to render the Blink UI\n  const response: ActionGetResponse = {\n    type: \"action\",\n    icon: `${new URL(\"/donate-mon.png\", req.url).toString()}`,\n    label: \"1 MON\",\n    title: \"Donate MON\",\n    description:\n      \"This Blink demonstrates how to donate MON on the Monad blockchain. It is a part of the official Blink Starter Guides by Dialect Labs.  \\n\\nLearn how to build this Blink: https://dialect.to/docs/guides/donate-mon\",\n    // Links is used if you have multiple actions or if you need more than one params\n    links: {\n      actions: [\n        {\n          // Defines this as a blockchain transaction\n          type: \"transaction\",\n          label: \"0.01 MON\",\n          // This is the endpoint for the POST request\n          href: `/api/actions/donate-mon?amount=0.01`,\n        },\n        {\n          type: \"transaction\",\n          label: \"0.05 MON\",\n          href: `/api/actions/donate-mon?amount=0.05`,\n        },\n        {\n          type: \"transaction\",\n          label: \"0.1 MON\",\n          href: `/api/actions/donate-mon?amount=0.1`,\n        },\n        {\n          // Example for a custom input field\n          type: \"transaction\",\n          href: `/api/actions/donate-mon?amount={amount}`,\n          label: \"Donate\",\n          parameters: [\n            {\n              name: \"amount\",\n              label: \"Enter a custom MON amount\",\n              type: \"number\",\n            },\n          ],\n        },\n      ],\n    },\n  };\n\n  // Return the response with proper headers\n  return new Response(JSON.stringify(response), {\n    status: 200,\n    headers,\n  });\n};\n\n// POST endpoint handles the actual transaction creation\nexport const POST = async (req: Request) => {\n    try {\n      // Extract amount from URL\n      const url = new URL(req.url);\n      const amount = url.searchParams.get(\"amount\");\n\n      if (!amount) {\n          throw new Error(\"Amount is required\");\n      }\n\n      // Build the transaction\n      const transaction = {\n          to: donationWallet,\n          value: parseEther(amount).toString(),\n          chainId: 10143,\n      };\n\n      const transactionJson = serialize(transaction);\n\n      // Build ActionPostResponse\n      const response: ActionPostResponse = {\n          type: \"transaction\",\n          transaction: transactionJson,\n          message: \"Donate MON\",\n      };\n\n      // Return the response with proper headers\n      return new Response(JSON.stringify(response), {\n          status: 200,\n          headers,\n      });\n    } catch (error) {\n      // Log and return an error response\n      console.error(\"Error processing request:\", error);\n      return new Response(JSON.stringify({ error: \"Internal server error\" }), {\n        status: 500,\n        headers,\n      });\n  }\n};\n```\n\nAt this point the Blink is ready, but we need a Blink client since [dial.to](https://dial.to) does not support EVM wallets."
  },
  {
    "instruction": "What is covered in the 'Implementing the Blink client' section of the Developer Essentials guide?",
    "output": "In this step you will learn to implement the blink client, which is the visual representation of a blink.\n\n### Install dependencies\n\n```bash\nnpm install connectkit @tanstack/react-query @dialectlabs/blinks\n```\n\n### Implement the provider\n\nThe provider is necessary to trigger wallet actions in the blink.\n\n### Create config for `WagmiProvider`\n\nThis file is used to set the proper configurations for the `WagmiProvider` in the next step.\n\n```ts\n// src/config.ts\n\nexport const config = createConfig({\n  chains: [monadTestnet],\n  transports: {\n    [monadTestnet.id]: http(),\n  },\n});\n```\n\n### Create the wallet connection context providers\n\nCreate the provider that we can use to wrap around our app. Don't forget to use the `\u201cuse client\u201d;` at the top of the file if you are in a NextJS project.\n\n:::info\nIn this project, we are using [ConnectKit](https://docs.family.co/connectkit) but you can use other alternatives as well (Eg: [RainbowKit](https://www.rainbowkit.com/))\n:::\n\n```tsx\n// src/provider.tsx\n\n\"use client\";\n\nconst queryClient = new QueryClient();\n\nexport const Providers = ({ children }: PropsWithChildren) => {\n  return (\n    <WagmiProvider config={config}>\n      <QueryClientProvider client={queryClient}>\n        <ConnectKitProvider>{children}</ConnectKitProvider>\n      </QueryClientProvider>\n    </WagmiProvider>\n  );\n};\n```\n\n### Wrap the app with context provider\n\nIf you want your provider to be accessible throughout your app, it is recommended to wrap it around the `children` element in your `layout.tsx`.\n\n```tsx\n// src/app/layout.tsx\n\n// additional import\n// other code in the file ...\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <html lang=\"en\">\n      <body\n      className={`${geistSans.variable} ${geistMono.variable} antialiased`}\n      >\n          <Providers>{children}</Providers>\n      </body>\n    </html>\n  );\n}\n```\n\n### Using the `Blink` component\n\nNow that we have everything wrapped, we can start with the implementation of the blink renderer.\nTo do so open the `page.tsx` file in your `/src/app` folder.\n\n```tsx\n// src/app/page.tsx\n\n\"use client\";\n\nexport default function Home() {\n  // Actions registry interval\n  useActionsRegistryInterval();\n\n  // ConnectKit modal\n  const { setOpen } = useModal();\n\n  // Wagmi adapter, used to connect to the wallet\n  const { adapter } = useEvmWagmiAdapter({\n    onConnectWalletRequest: async () => {\n      setOpen(true);\n    },\n  });\n\n  // Action we want to execute in the Blink\n  const { blink, isLoading } = useBlink({\n    url: \"evm-action:http://localhost:3000/api/actions/donate-mon\",\n  });\n\n  return (\n    <main className=\"flex flex-col items-center justify-center\">\n      <ConnectKitButton />\n      <div className=\"w-1/2 lg:px-4 lg:p-8\">\n        {isLoading || !blink ? (\n          <span>Loading</span>\n        ) : (\n          // Blink component, used to execute the action\n          <Blink blink={blink} adapter={adapter} securityLevel=\"all\" />\n        )}\n      </div>\n    </main>\n  );\n}\n```\n\n### Make a transaction\n\nThat's it. To test it, visit [localhost:3000](http://localhost:3000) and click on a button or enter a custom amount that you want to donate.\n\n![blink client](/img/guides/blinks-guide/3.png)"
  },
  {
    "instruction": "What is covered in the 'Conclusion' section of the Developer Essentials guide?",
    "output": "In this tutorial, you learned how you can create a blink that sends MON to another wallet from scratch using a `NextJS` project. Besides the basic project setup there were two important things that we built.\n\nThe first thing was the blink provider. This provider works as an API for the blink and handles how the blink is rendered in the fronend (`GET` request) and executes the blockchain transaction (`POST` request).\n\nThe second implementation was the blink client. This client serves as the visual representation of the blink and is what the user sees and uses to interact with the blink provider.\n\nThese are two separate parts, which means you can build a blink without worrying about the client implementation and you can implement clients for existing blinks without the need to build your own blink.\n---\n\n# Deploy a Contract\n\n<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Foundry />}\n        link=\"/guides/deploy-smart-contract/foundry\"\n        title=\"Foundry\"\n        description=\"Deploy a smart contract on Monad using Foundry\"\n    />\n    <CustomDocCard\n        icon={<Hardhat />}\n        link=\"/guides/deploy-smart-contract/hardhat\"\n        title=\"Hardhat\"\n        description=\"Deploy a smart contract on Monad using Hardhat\"\n    />\n    <CustomDocCard\n        icon={<Remix />}\n        link=\"/guides/deploy-smart-contract/remix\"\n        title=\"Remix\"\n        description=\"Deploy a smart contract on Monad using Remix\"\n    />\n</CustomDocCardContainer>\n\n\n---\n\n# Deploy a smart contract on Monad using Foundry\n\nURL: https://docs.monad.xyz/guides/deploy-smart-contract/foundry\n\n[Foundry](https://book.getfoundry.sh/) is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust."
  },
  {
    "instruction": "What is covered in the 'Requirements' section of the Developer Essentials guide?",
    "output": "Before you begin, you need to install the following tools:\n\n-   [Rust](https://www.rust-lang.org/)"
  },
  {
    "instruction": "What is covered in the '1. Installing `foundryup`' section of the Developer Essentials guide?",
    "output": "Foundryup is the official installer for the Foundry toolchain.\n\n```sh\ncurl -L https://foundry.paradigm.xyz | bash\n```\n\nThis will install Foundryup. Simply follow the on-screen instructions, and the `foundryup` command will become available in your CLI."
  },
  {
    "instruction": "What is covered in the '2. Installing `forge`, `cast`, `anvil` and `chisel` binaries' section of the Developer Essentials guide?",
    "output": "```sh\nfoundryup\n```\n\n:::note\nIf you're on Windows, you'll need to use WSL, since Foundry currently doesn't work natively on Windows. Please follow [this link](https://learn.microsoft.com/en-us/windows/wsl/install) to learn more about WSL.\n:::"
  },
  {
    "instruction": "What is covered in the '3. Create a new foundry project' section of the Developer Essentials guide?",
    "output": ":::tip\nYou can use `foundry-monad` template to create a new project.\n\n_[Foundry-Monad](https://github.com/monad-developers/foundry-monad) is a Foundry template with Monad configuration._\n:::\n\nThe below command uses `foundry-monad` to create a new foundry project:\n\n```sh\nforge init --template monad-developers/foundry-monad [project_name]\n```\n\nAlternatively, you can create a foundry project using the command below:\n\n```sh\nforge init [project_name]\n```"
  },
  {
    "instruction": "What is covered in the '4. Modify Foundry configuration' section of the Developer Essentials guide?",
    "output": "Update the `foundry.toml` file to add Monad Testnet configuration.\n\n```toml\n[profile.default]\nsrc = \"src\"\nout = \"out\"\nlibs = [\"lib\"]\n\n# Monad Testnet Configuration\neth-rpc-url=\"https://testnet-rpc.monad.xyz\"\nchain_id = 10143\n```"
  },
  {
    "instruction": "What is covered in the '5. Write a smart contract' section of the Developer Essentials guide?",
    "output": "You can write your smart contracts under the `src` folder. There is already a `Counter` contract in the project located at `src/Counter.sol`.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ncontract Counter {\n    uint256 public number;\n\n    function setNumber(uint256 newNumber) public {\n        number = newNumber;\n    }\n\n    function increment() public {\n        number++;\n    }\n}\n```"
  },
  {
    "instruction": "What is covered in the '6. Compile the smart contract' section of the Developer Essentials guide?",
    "output": "```sh\nforge compile\n```\n\nCompilation process output can be found in the newly created `out` directory, which includes contract ABI and bytecode."
  },
  {
    "instruction": "What is covered in the '7. Deploy the smart contract' section of the Developer Essentials guide?",
    "output": ":::note\nFor deploying contracts, we recommend using keystores instead of private keys.\n:::\n\n### Get testnet funds\n\nDeploying smart contracts requires testnet funds. Claim testnet funds via a [faucet](https://testnet.monad.xyz).\n\n### Deploy smart contract\n\n<Tabs>\n    <TabItem value=\"with-keystore\" label=\"Using a Keystore (Recommended)\" default>\n        Using a keystore is much safer than using a private key because keystore encrypts the private key and can later be referenced in any commands that require a private key.\n\n        Create a new keystore by importing a newly generated private key with the command below.\n\n        ```sh\n        cast wallet import monad-deployer --private-key $(cast wallet new | grep 'Private key:' | awk '{print $3}')\n        ```\n\n        Here is what the command above does, step by step:\n\n        -   Generates a new private key\n        -   Imports the private key into a keystore file named `monad-deployer`\n        -   Prints the address of the newly created wallet to the console\n\n        After creating the keystore, you can read its address using:\n\n        ```sh\n        cast wallet address --account monad-deployer\n        ```\n\n        Provide a password to encrypt the keystore file when prompted and do not forget it.\n\n        Run the below command to deploy your smart contracts\n\n        ```sh\n        forge create src/Counter.sol:Counter --account monad-deployer --broadcast\n        ```\n\n    </TabItem>\n\n    <TabItem value=\"with-private-key\" label=\"Using a Private Key (Not Recommended)\">\n        Use the below command to deploy a smart contract by directly pasting the private key in the terminal.\n\n        :::warning\n        Using a private key is not recommended. You should not be copying and pasting private keys into your terminal. Please use a keystore instead.\n        :::\n\n        ```sh\n        forge create --private-key <your_private_key> src/Counter.sol:Counter --broadcast\n        ```\n    </TabItem>\n\n</Tabs>\n\nOn successful deployment of the smart contract, the output should be similar to the following:\n\n```sh\n[\u280a] Compiling...\nDeployer: 0xB1aB62fdFC104512F594fCa0EF6ddd93FcEAF67b\nDeployed to: 0x67329e4dc233512f06c16cF362EC3D44Cdc800e0\nTransaction hash: 0xa0a40c299170c9077d321a93ec20c71e91b8aff54dd9fa33f08d6b61f8953ee0\n```\n\n### Next Steps\n\nCheck out [how to verify the deployed smart contract on Monad Explorer](/guides/verify-smart-contract/foundry.mdx).\n\n---\n\n# Deploy a smart contract on Monad using Hardhat\n\nURL: https://docs.monad.xyz/guides/deploy-smart-contract/hardhat\n\n[Hardhat](https://hardhat.org/docs) is a comprehensive development environment consisting of different components for editing, compiling, debugging, and deploying your smart contracts."
  },
  {
    "instruction": "What is covered in the 'Requirements' section of the Developer Essentials guide?",
    "output": "Before you begin, you need to install the following dependencies:\n\n- Node.js v18.0.0 or later\n\n:::note\nIf you are on Windows, we strongly recommend using [WSL 2](https://learn.microsoft.com/en-us/windows/wsl/about) when following this guide.\n:::"
  },
  {
    "instruction": "What is covered in the '1. Create a new Hardhat project' section of the Developer Essentials guide?",
    "output": ":::tip\nYou can use the `hardhat-monad` template to create a new project with Monad configuration already set up.\n\n_[hardhat-monad](https://github.com/monad-developers/hardhat-monad) is a Hardhat template with Monad configuration._\n:::\n\nClone the repository to your machine using the command below:\n\n```sh\ngit clone https://github.com/monad-developers/hardhat-monad.git\n```"
  },
  {
    "instruction": "What is covered in the '2. Install dependencies' section of the Developer Essentials guide?",
    "output": "```sh\nnpm install\n```"
  },
  {
    "instruction": "What is covered in the '3. Create an .env file' section of the Developer Essentials guide?",
    "output": "```sh\ncp .env.example .env\n```\n\nEdit the `.env` file with your private key.\n\n:::warning\nProtect your private key carefully. Never commit it to version control, share it in public repositories, or expose it in client-side code. Your private key provides full access to your funds.\n:::"
  },
  {
    "instruction": "What is covered in the '4. Deploy the smart contract' section of the Developer Essentials guide?",
    "output": "### Deploying to the local hardhat node\n\nRun hardhat node by running:\n\n```bash\nnpx hardhat node\n```\n\nTo deploy the example contract to the local hardhat node, run the following command in a separate terminal:\n\n```bash\nnpx hardhat ignition deploy ignition/modules/Lock.ts\n```\n\n### Deploying to Monad Testnet\n\nThe following command will deploy the example contract to the Monad Testnet using [Hardhat Ignition](https://hardhat.org/ignition/docs/getting-started#overview):\n\n```bash\nnpx hardhat ignition deploy ignition/modules/Lock.ts --network monadTestnet\n```\n\nTo redeploy the same code to a different address, use the command below:\n\n```bash\nnpx hardhat ignition deploy ignition/modules/Lock.ts --network monadTestnet --reset\n```\n\nYou can customize deployment parameters:\n\n```bash\nnpx hardhat ignition deploy ignition/modules/Lock.ts --network monadTestnet --parameters '{\"unlockTime\": 1893456000, \"lockedAmount\": \"1000000000000000\"}'\n```"
  },
  {
    "instruction": "What is covered in the 'Next Steps' section of the Developer Essentials guide?",
    "output": "Check out [how to verify the deployed smart contract on Monad Explorer](/guides/verify-smart-contract/hardhat).\n\n---\n\n# Deploy a smart contract on Monad using Remix\n\nURL: https://docs.monad.xyz/guides/deploy-smart-contract/remix\n\n[Remix IDE](https://remix.ethereum.org/) is a browser-based IDE that can be used for the entire journey of smart contract development by users at every knowledge level. It requires no setup, fosters a fast development cycle, and has a rich set of plugins with intuitive GUIs.\n\nIn this guide you will learn how to deploy and interact with a simple Greeting smart contract on Monad Testnet using [Remix IDE](https://remix.ethereum.org/)."
  },
  {
    "instruction": "What is covered in the 'Requirements' section of the Developer Essentials guide?",
    "output": "- You need to have the Monad Testnet network added to your wallet."
  },
  {
    "instruction": "What is covered in the 'Deploying the smart contract' section of the Developer Essentials guide?",
    "output": "Head over to [Remix IDE](https://remix.ethereum.org/) in your browser. Click 'Start Coding' to create a new project template.\n\n![remix-ide](/img/guides/deploy-smart-contract/remix/1.png)\n\nMake sure the 'contracts' folder is selected, then create a new file using the \"Create new file\" button on top left corner.\n\n![create-file](/img/guides/deploy-smart-contract/remix/2.png)\n\nName the new file \"Gmonad.sol\" and add the following code to it\n\n```sol\n// SPDX-License-Identifier: MIT\n\n// Make sure the compiler version is below 0.8.24 since Cancun compiler is not supported just yet\npragma solidity >=0.8.0 <=0.8.24;\n\ncontract Gmonad { \n    string public greeting;\n\n    constructor(string memory _greeting) {\n        greeting = _greeting;\n    }\n\n    function setGreeting(string calldata _greeting) external {\n        greeting = _greeting;\n    }\n}\n```\n\n**Note:** You may see a red squiggly line underneath the `pragma solidity...` line; this is because the default compiler version is outside of the range specified in the contract. We'll fix that in the next step.\n\n![code](/img/guides/deploy-smart-contract/remix/3.png)\n\nLet's compile the smart contract. Navigate to the compiler view by clicking the \"Solidity compiler\" tab on the far left. Then select the right compiler version (0.8.24).\n\n![compiler](/img/guides/deploy-smart-contract/remix/4.png)\n\nOnce you have the right compiler version selected, click on the \"Compile Gmonad.sol\" button. If succesful, you will see a green check mark on the \"Solidity compiler\" tab icon.\n\n![compile](/img/guides/deploy-smart-contract/remix/5.png)\n\nNow we can deploy the smart contract! Navigate to the deploy view using the \"Deploy & run transactions\" tab on the far left.\n\n![deploy](/img/guides/deploy-smart-contract/remix/6.png)\n\nUsing the \"Environment\" dropdown, select \"Injected Provider\" to connect to your wallet.\n\nThe screenshot below says \"Injected Provider - Metamask\"; in case you are using some wallet other than Metamask you may see an appropriate option.\n\n![environment](/img/guides/deploy-smart-contract/remix/7.png)\n\nYour wallet should pop up asking for permission to connect to Remix, click \"Connect\".\n\n![connect](/img/guides/deploy-smart-contract/remix/8.png)\n\nOnce connected you should be able to see your address with your balance in the \"Account\" dropdown.\n\nMake sure you also see the correct chain id under the \"Environment\" dropdown.\n\nNow let's deploy the contract. `Gmonad.sol` requires a greeting message to be passed to the constructor before it can be deployed; choose the greeting message of your choice (in this example it is \"gmonad\").\n\nNow you can deploy the smart contract by clicking the \"Deploy\" button.\n\n![deploy](/img/guides/deploy-smart-contract/remix/9.png)\n\nYou should see a wallet popup asking for confirmation to deploy the smart contract. Click \"Confirm\".\n\n![confirm](/img/guides/deploy-smart-contract/remix/10.png)\n\nOnce the transaction is confirmed you will see the smart contract address in the \"Deployed Contracts\" section on the bottom left.\n\n![deployed](/img/guides/deploy-smart-contract/remix/11.png)"
  },
  {
    "instruction": "What is covered in the 'Interacting with the smart contract' section of the Developer Essentials guide?",
    "output": "You can expand the smart contract to see the functions available.\n\nThere you will find a `greeting` button which can be used to read the current greeting message stored in the smart contract.\n\nClick the \"greeting\" button to call the `greeting()` method (which outputs the current greeting message). You'll need to click the expand arrow in the terminal output to see the decoded output.\n\n:::info\nThis \"greeting\" button is a getter function which is automatically created for the _public_ `greeting` state variable in the smart contract.\n:::\n\n![expand](/img/guides/deploy-smart-contract/remix/12.png)\n\nYou can change the greeting message by using the `setGreeting` function.\n\nIn this example, we will change the greeting message to \"gmonad molandak\".\n\nOnce again, click the \"transact\" button to initiate the transaction.\n\nYou should see a wallet popup asking for confirmation to change the greeting message. Click \"Confirm\".\n\n![transact](/img/guides/deploy-smart-contract/remix/13.png)\n\nOnce the transaction is confirmed you can view the updated greeting message using the `greeting` button.\n\n![updated](/img/guides/deploy-smart-contract/remix/14.png)\n\nCongratulations! You have successfully deployed and interacted with a smart contract on Monad  Testnet using Remix IDE.\n\n\n{/* TODO: Add next step to verify the contract using the explorer */}\n{/* ## Next steps\n\nCheck out how to verify your smart contract on Monad using Explorer */}\n\n---\n\n# EVM Resources\n---\n\n# EVM Behavior"
  },
  {
    "instruction": "What is covered in the 'EVM Behavioral Specification' section of the Developer Essentials guide?",
    "output": "* [Notes on the EVM](https://github.com/CoinCulture/evm-tools/blob/master/analysis/guide.md): straightforward technical specification of the EVM plus some behavioral examples\n* [EVM: From Solidity to bytecode, memory and storage](https://www.youtube.com/watch?v=RxL\\_1AfV7N4): a 90-minute talk from Peter Robinson and David Hyland-Wood\n* [EVM illustrated](https://takenobu-hs.github.io/downloads/ethereum\\_evm\\_illustrated.pdf): an excellent set of diagrams for confirming your mental model\n* [EVM Deep Dives: The Path to Shadowy Super-Coder](https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy)"
  },
  {
    "instruction": "What is covered in the 'Opcode Reference' section of the Developer Essentials guide?",
    "output": "[evm.codes](https://www.evm.codes/): opcode reference (including gas costs) and an interactive sandbox for stepping through bytecode execution"
  },
  {
    "instruction": "What is covered in the 'Solidity Storage Layout' section of the Developer Essentials guide?",
    "output": "The EVM allows smart contracts to store data in 32-byte words (\"storage slots\"), however the details of how complex datastructures such as lists or mappings is left as an implementation detail to the higher-level language.  Solidity has a specific way of assigning variables to storage slots, described below:\n\n* [Official docs on storage layout](https://docs.soliditylang.org/en/latest/internals/layout\\_in\\_storage.html)\n* [Storage patterns in Solidity](https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/)\n---\n\n# Other Languages\n---\n\n# Huff\n\n[Huff](https://docs.huff.sh/) is most closely described as EVM assembly. Unlike Yul, Huff does not provide control flow constructs or abstract away the inner working of the program stack. Only the most upmost performance sensitive applications take advantage of Huff, however it is a great educational tool to learn how the EVM interprets instructions its lowest level.\n\n* [Huff resources](https://docs.huff.sh/resources/overview/) provides additional resources\n---\n\n# Vyper\n\n[Vyper](https://www.quicknode.com/guides/ethereum-development/smart-contracts/how-to-write-an-ethereum-smart-contract-using-vyper) is a popular programming language for the EVM that is logically similar to Solidity and syntactically similar with Python.\n\nThe [Vyper documentation](https://docs.vyperlang.org/en/stable/index.html) covers installing the Vyper language, language syntax, coding examples, compilation.\n\nA typical EVM developer looking for a Python-like experience is encouraged to use Vyper as the programming language and [ApeWorx](https://docs.apeworx.io/ape/stable/userguides/quickstart.html), which leverages the Python language, as the testing and deployment framework. ApeWorx also allows for the use of typical Python libraries in analysis of testing results such as Pandas.\n\nVyper and ApeWorx can be used with [Jupyter](https://jupyter.org/), which offers an interactive environment using a web browser.  A quick setup guide for working with Vyper and Jupyter for smart contract development for the EVM can be found [here](https://medium.com/deepyr/interacting-with-ethereum-using-web3-py-and-jupyter-notebooks-e4207afa0085)."
  },
  {
    "instruction": "What is covered in the 'Resources' section of the Developer Essentials guide?",
    "output": "* [Vyper by Example](https://vyper-by-example.org/)\n* [Snekmate](https://github.com/pcaversaccio/snekmate): a Vyper library of gas-optimized smart contract building blocks\n* [Curve contracts](https://github.com/curvefi/curve-contract): the most prominent example usage of Vyper\n\n---\n\n# Yul\n\n[Yul](https://docs.soliditylang.org/en/latest/yul.html) is a intermediate language for Solidity that can generally be thought of as inline assembly for the EVM. It is not quite pure assembly, providing control flow constructs and abstracting away the inner working of the stack while still exposing the raw memory backend to developers. Yul is targeted at developers needing exposure to the EVM's raw memory backend to build high performance gas optimized EVM code.\n---\n\n# Solidity Resources\n\nMonad is fully EVM bytecode-compatible, with all supported opcodes and precompiles as of the [Cancun fork](https://www.evm.codes/?fork=cancun). Monad also preserves the standard Ethereum JSON-RPC interfaces.\n\nAs such, most development resources for Ethereum Mainnet apply to development on Monad.\n\nThis page suggests a **minimal** set of resources for getting started with building a decentralized app for Ethereum. Child pages provide additional detail or options.&#x20;\n\nAs [Solidity](https://docs.soliditylang.org/) is the most popular language for Ethereum smart contracts, the resources on this page focus on Solidity; alternatively see resources on [Vyper](/docs/guides/evm-resources/other-languages/vyper.md) or [Huff](/docs/guides/evm-resources/other-languages/huff.md). Note that since smart contracts are composable, contracts originally written in one language can still make calls to contracts in another language."
  },
  {
    "instruction": "What is covered in the '**IDEs**' section of the Developer Essentials guide?",
    "output": "-   [Remix](https://remix.ethereum.org/#lang=en&optimize=false&runs=200&evmVersion=null) is an interactive Solidity IDE. It is the easiest and fastest way to get started coding and compiling Solidity smart contracts without the need for additional tool installations.\n-   [VSCode](https://code.visualstudio.com/) + [Solidity extension](https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity)"
  },
  {
    "instruction": "What is covered in the '**Basic Solidity**' section of the Developer Essentials guide?",
    "output": "-   [CryptoZombies](https://cryptozombies.io/en/course) is a great end-to-end introduction to building dApps on the EVM. It provides resources and lessons for anyone from someone who has never coded before, to experienced developers in other disciplines looking to explore blockchain development.\n-   [Solidity by Example](https://solidity-by-example.org/) introduces concepts progressively through simple examples; best for developers who already have basic experience with other languages.\n-   [Blockchain Basics course by Cyfrin Updraft](https://updraft.cyfrin.io/courses/blockchain-basics) teaches the fundamentals of blockchain, DeFi, and smart contracts.\n-   [Solidity Smart Contract Development by Cyfrin Updraft](https://updraft.cyfrin.io/courses/solidity) will teach you how to become a smart contract developer. Learn to build with projects and get hands-on experience.\n-   [Ethereum Developer Degree by LearnWeb3](https://learnweb3.io/degrees/ethereum-developer-degree/) is the a good course to go from no background knowledge in web3 to being able to build multiple applications and understanding several key protocols, frameworks, and concepts in the web3 space."
  },
  {
    "instruction": "What is covered in the '**Intermediate Solidity**' section of the Developer Essentials guide?",
    "output": "-   [The Solidity Language](https://docs.soliditylang.org/en/v0.8.21/introduction-to-smart-contracts.html) official documentation is an end-to-end description of Smart Contracts and blockchain basics centered on EVM environments. In addition to Solidity Language documentation, it covers the basics of compiling your code for deployment on an EVM as well as the basic components relevant to deploying a Smart Contract on an EVM.\n-   [Solidity Patterns](https://github.com/fravoll/solidity-patterns) repository provides a library of code templates and explanation of their usage.&#x20;\n-   The [Uniswap V2](https://github.com/Uniswap/v2-core) contract is a professional yet easy to digest smart contract that provides a great overview of an in-production Solidity dApp. A guided walkthrough of the contract can be found [here](https://ethereum.org/en/developers/tutorials/uniswap-v2-annotated-code/).\n-   [Cookbook.dev](https://www.cookbook.dev/search?q=cookbook&categories=Contracts&sort=popular&filter=&page=1) provides a set of interactive example template contracts with live editing, one-click deploy, and an AI chat integration to help with code questions.&#x20;\n-   [OpenZeppelin](https://www.openzeppelin.com/contracts) provides customizable template contract library for common Ethereum token deployments such as ERC20, ERC712, and ERC1155. Note, they are not gas optimized.\n-   [Rareskills Blog](https://www.rareskills.io/category/solidity) has some great in-depth articles on various concepts in Solidity.\n-   [Foundry Fundamentals course by Cyfrin Updraft](https://updraft.cyfrin.io/courses/foundry) is a comprehensive web3 development course designed to teach you about Foundry the industry-standard framework to build, deploy, and test your smart contracts.\n-   [Smart Contract Programmer YT channel](https://www.youtube.com/@smartcontractprogrammer) has a plenty of in-depth videos about various Solidity concepts like ABI encoding, EVM memory, and many more."
  },
  {
    "instruction": "What is covered in the '**Advanced Solidity**' section of the Developer Essentials guide?",
    "output": "-   The [Solmate repository](https://github.com/transmissions11/solmate) and [Solady repository](https://github.com/Vectorized/solady/tree/main) provide gas-optimized contracts utilizing Solidity or Yul.\n-   [Yul](https://docs.soliditylang.org/en/latest/yul.html) is a intermediate language for Solidity that can generally be thought of as inline assembly for the EVM. It is not quite pure assembly, providing control flow constructs and abstracting away the inner working of the stack while still exposing the raw memory backend to developers. Yul is targeted at developers needing exposure to the EVM's raw memory backend to build high performance gas optimized EVM code.&#x20;\n-   [Huff](https://docs.huff.sh/get-started/overview/) is most closely described as EVM assembly. Unlike Yul, Huff does not provide control flow constructs or abstract away the inner working of the program stack. Only the most upmost performance sensitive applications take advantage of Huff, however it is a great educational tool to learn how the EVM interprets instructions its lowest level.\n-   [Advanced Foundry course by Cyfrin Updraft](https://updraft.cyfrin.io/courses/advanced-foundry) teaches you about Foundry, how to develop a DeFi protocol and a stablecoin, how to develop a DAO, advanced smart contract development, advanced smart contracts testing and fuzzing and manual verification.\n-   [Smart Contract Security course by Cyfrin Updraft](https://updraft.cyfrin.io/courses/security) will teach you everything you need to know to get started auditing and writing secure protocols.\n-   [Assembly and Formal Verification course by Cyfrin Updraft](https://updraft.cyfrin.io/courses/formal-verification) teaches you about Assembly, writing smart contracts using Huff and Yul, Ethereum Virtual Machine OPCodes, Formal verification testing, Smart contract invariant testing and tools like Halmos, Certora, Kontrol.\n-   [Smart Contract DevOps course by Cyfrin Updraft](https://updraft.cyfrin.io/courses/wallets) teaches about access control best practices when working with wallets, post-deployment security, smart contract and web3 devOps and live protocols maintenance and monitoring.\n-   [Secureum YT Channel](https://www.youtube.com/@SecureumVideos/videos) has plenty videos about Solidity from Solidity Basics to all the way to advanced concepts like Fuzzing and Solidity auditing."
  },
  {
    "instruction": "What is covered in the 'Tutorials' section of the Developer Essentials guide?",
    "output": "-   [Ethernaut](https://ethernaut.openzeppelin.com/): learn by solving puzzles\n-   [Damn Vulnerable DeFi](https://www.damnvulnerabledefi.xyz): DVD is a series of smart contract challenges which consists of vulnerable contracts and you are supposed to be able to hack it. These challenges are a good way to practice and apply the Solidity skills you have acquired."
  },
  {
    "instruction": "What is covered in the 'Best practices/patterns' section of the Developer Essentials guide?",
    "output": "-   [DeFi developer roadmap](https://github.com/OffcierCia/DeFi-Developer-Road-Map)\n-   [RareSkills Book of Gas Optimization](https://www.rareskills.io/post/gas-optimization)"
  },
  {
    "instruction": "What is covered in the 'Testing' section of the Developer Essentials guide?",
    "output": "-   [Echidna](https://github.com/crytic/echidna): fuzz testing\n-   [Slither](https://github.com/crytic/slither): static analysis for vulnerability detection\n-   [solidity-coverage](https://github.com/sc-forks/solidity-coverage/tree/master): code coverage for Solidity testing"
  },
  {
    "instruction": "What is covered in the 'Smart contract archives' section of the Developer Essentials guide?",
    "output": "-   [Smart contract sanctuary](https://github.com/tintinweb/smart-contract-sanctuary) - contracts verified on Etherscan\n-   [EVM function signature database](https://www.4byte.directory/)\n---\n\n# How to build a Farcaster Mini App\n\nURL: https://docs.monad.xyz/guides/farcaster-miniapp.md\n\nMini Apps enable developers to distribute native-like apps to [Farcaster](https://www.farcaster.xyz/) users. Mini Apps are the easiest way to deliver engaging, high-retention, and easy-to-monetize applications!\n\nMini apps are web apps built with HTML, CSS, and Javascript that can be discovered and used within Farcaster clients like [Warpcast](https://warpcast.com/).\n\nIn this guide, you will learn how to use the [Monad Farcaster Mini App Template](https://github.com/monad-developers/monad-miniapp-template) to build apps.\n\nThe template demonstrates all Mini App capabilities and lets you easily modify it, so you can build Mini Apps."
  },
  {
    "instruction": "What is covered in the 'Cloning the Template' section of the Developer Essentials guide?",
    "output": "You can the following command to clone the Mini App template to your local machine:\n\n```bash\ngit clone https://github.com/monad-developers/monad-miniapp-template.git\n```\n\n### Install the dependencies\n\n```bash\nyarn\n```\n\n### Copy `.env.example` over to `.env.local`\n\n```bash\ncp .env.example .env.local\n```\n\n### Run the template\n\n```bash\nyarn run dev\n```\n\n### View the App in Warpcast Embed tool\n\nWarpcast has a neat [Embed tool](https://warpcast.com/~/developers/mini-apps/embed) that you can use to inspect the Mini App before you publish it.\n\nUnfortunately, the embed tool can only work with remote URL. Inputting a localhost URL does not work.\n\nAs a workaround, you may make the local app accessible remotely using a tool like `cloudflared` or `ngrok`. In this guide we will use `cloudflared`.\n\n#### Install Cloudflared\n\n```bash\nbrew install cloudflared\n```\n\nFor more installation options see the [official docs](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/downloads/).\n\n#### Expose localhost\n\nRun the following command in your terminal:\n\n```bash\ncloudflared tunnel --url http://localhost:3000\n```\n\nBe sure to specify the correct port for your local server.\n\n#### Set `NEXT_PUBLIC_URL` environment variable in `.env.local` file\n\n```bash\nNEXT_PUBLIC_URL=<url-from-cloudflared-or-ngrok>\n```\n\n#### Use the provided url\n\n`cloudflared` will generate a random subdomain and print it in the terminal for you to use. Any traffic to this URL will get sent to your local server.\n\nEnter the provided URL in the [Warpcast Embed tool](https://warpcast.com/~/developers/mini-apps/embed).\n\n![embed-tool](/img/guides/farcaster-miniapp/1.png)\n\nLet's investigate the various components of the template."
  },
  {
    "instruction": "What is covered in the 'Customizing the Mini App Embed' section of the Developer Essentials guide?",
    "output": "Mini App Embed is how the Mini App shows up in the feed or in a chat conversation when the URL of the app is shared.\n\nThe Mini App Embed looks like this:\n\n![embed-preview](/img/guides/farcaster-miniapp/2.png)\n\nYou can customize this by editing the file `app/page.tsx`:\n\n```js\n...\n\nconst appUrl = env.NEXT_PUBLIC_URL;\n\nconst frame = {\n  version: \"next\",\n  imageUrl: `${appUrl}/images/feed.png`, // Embed image URL (3:2 image ratio)\n  button: {\n    title: \"Template\", // Text on the embed button\n    action: {\n      type: \"launch_frame\",\n      name: \"Monad Farcaster MiniApp Template\",\n      url: appUrl, // URL that is opened when the embed button is tapped or clicked.\n      splashImageUrl: `${appUrl}/images/splash.png`,\n      splashBackgroundColor: \"#f7f7f7\",\n    },\n  },\n};\n\n...\n```\n\nYou can either edit the URLs for the images or replace the images in `public/images` folder in the template.\n\nOnce you are happy with the changes, click `Refetch` in the Embed tool to get the latest configuration.\n\n:::note\nIf you are developing locally, ensure that your Next.js app is running locally and the cloudflare tunnel is open. \n:::"
  },
  {
    "instruction": "What is covered in the 'Customizing the Splash Screen' section of the Developer Essentials guide?",
    "output": "Upon opening the Mini App, the first thing the user will see is the Splash screen:\n\n![splash-screen](/img/guides/farcaster-miniapp/3.png)\n\nYou can edit the `app/page.tsx` file to customize the Splash screen.\n\n```js\n...\n\nconst appUrl = env.NEXT_PUBLIC_URL;\n\nconst frame = {\n  version: \"next\",\n  imageUrl: `${appUrl}/images/feed.png`,\n  button: {\n    title: \"Launch Template\",\n    action: {\n      type: \"launch_frame\",\n      name: \"Monad Farcaster MiniApp Template\",\n      url: appUrl,\n      splashImageUrl: `${appUrl}/images/splash.png`, // App icon in the splash screen (200px * 200px)\n      splashBackgroundColor: \"#f7f7f7\", // Splash screen background color\n    },\n  },\n};\n\n...\n```\n\nFor `splashImageUrl`, you can either change the URL or replace the image in `public/images` folder in the template."
  },
  {
    "instruction": "What is covered in the 'Modifying the Mini App' section of the Developer Essentials guide?",
    "output": "Upon opening the template Mini App, you should see a screen like this:\n\n![miniapp](/img/guides/farcaster-miniapp/4.png)\n\nThe code for this screen is in the `components/pages/app.tsx` file:\n\n```tsx\nexport default function Home() {\n  const { context } = useMiniAppContext();\n  return (\n    // SafeAreaContainer component makes sure that the app margins are rendered properly depending on which client is being used.\n    <SafeAreaContainer insets={context?.client.safeAreaInsets}>\n      {/* You replace the Demo component with your home component */}\n      <Demo />\n    </SafeAreaContainer>\n  )\n}\n```\n\nYou can remove or edit the code in this file to build your Mini App.\n\n### Accessing User Context\n\n![user-context](/img/guides/farcaster-miniapp/5.png)\n\nYour Mini App receives various information about the user, including `username`, `fid`, `displayName`, `pfpUrl` and other fields.\n\nThe template provides a helpful hook `useMiniAppContext` that you can use to access these fields:\n\n```js\nexport function User() {\n    const { context } = useMiniAppContext();\n    return <p>{context.user.username}</p>\n}\n```\n\nThe template also provide an example of the same in `components/Home/User.tsx` file.\n\nYou can learn more about Context [here](https://miniapps.farcaster.xyz/docs/sdk/context).\n\n### Performing App Actions\n\n<img src=\"/img/guides/farcaster-miniapp/composeCast.gif\" style={{ marginBottom: 10 }} />\n\nMini Apps have the capability to perform native actions that enhance the user experience!\n\nActions like:\n\n- `addFrame`: Allows the user to save (bookmark) the app in a dedicated section\n- `composeCast`: Allows the MiniApp to prompt the user to cast with prefilled text and media\n- `viewProfile`: Presents a profile of a Farcaster user in a client native UI\n\nLearn more about Mini App actions [here](https://miniapps.farcaster.xyz/docs/sdk/actions/add-frame)\n\nThe template provides an easy way to access the actions via the `useMiniAppContext` hook!\n\n```js\nconst { actions } = useMiniAppContext();\n```\n\nAn example for the same can be found in `components/Home/FarcasterActions.tsx` file.\n\n### Prompting Wallet Actions\n\n![wallet-actions](/img/guides/farcaster-miniapp/6.png)\n\nEvery user of Warpcast has a Warpcast wallet with Monad Testnet support.\n\n**Mini Apps can prompt the user to perform onchain actions**!\n\nThe template provides an example for the same in `components/Home/WalletActions.tsx` file.\n\n```js\nexport function WalletActions() {\n    ...\n\n    async function sendTransactionHandler() {\n        sendTransaction({\n            to: \"0x7f748f154B6D180D35fA12460C7E4C631e28A9d7\",\n            value: parseEther(\"1\"),\n        });\n    }\n\n    ...\n}\n```\n\n:::warning\nThe Warpcast wallet supports multiple networks. It is recommended that you ensure that the right network is connected before prompting wallet actions.\n\nYou can use viem's `switchChain` or equivalent to prompt a chain switch.\n\n```js\n// Switching to Monad Testnet\nswitchChain({ chainId: 10143 });\n```\n\nThe template has an example for the same in the `components/Home/WalletActions.tsx` file.\n:::"
  },
  {
    "instruction": "What is covered in the 'Modifying the `farcaster.json` file' section of the Developer Essentials guide?",
    "output": "When publishing the Mini App you will need to have a `farcaster.json` file that follows the specification.\n\nYou can edit the `app/.well-known/farcaster.json/route.ts` file with your app details before publishing the app!\n\n```ts\n...\n\nconst appUrl = process.env.NEXT_PUBLIC_URL;\nconst farcasterConfig = {\n    // accountAssociation details are required to associated the published app with it's author\n    accountAssociation: {\n        \"header\": \"\",\n        \"payload\": \"\",\n        \"signature\": \"\"\n    },\n    frame: {\n        version: \"1\",\n        name: \"Monad Farcaster MiniApp Template\",\n        iconUrl: `${appUrl}/images/icon.png`, // Icon of the app in the app store\n        homeUrl: `${appUrl}`, // Default launch URL\n        imageUrl: `${appUrl}/images/feed.png`, // Default image to show if shared in a feed.\n        screenshotUrls: [], // Visual previews of the app\n        tags: [\"monad\", \"farcaster\", \"miniapp\", \"template\"], // Descriptive tags for search\n        primaryCategory: \"developer-tools\",\n        buttonTitle: \"Launch Template\",\n        splashImageUrl: `${appUrl}/images/splash.png`, // URL of image to show on loading screen.\t\n        splashBackgroundColor: \"#ffffff\", // Hex color code to use on loading screen.\n    }\n};\n\n...\n```\n\nYou can learn more about publishing the Mini App and other manifest properties [here](https://miniapps.farcaster.xyz/docs/guides/publishing)."
  },
  {
    "instruction": "What is covered in the 'Conclusion' section of the Developer Essentials guide?",
    "output": "In this guide, you explored Farcaster Mini Apps \u2014 the simplest way to create engaging, high-retention, and easily monetizable applications!\n\nYou also discovered the key capabilities of Mini Apps and how you can use the [Monad Farcaster MiniApp Template](https://github.com/monad-developers/monad-miniapp-template) to build your own.\n\nFor more details, check out the official Mini App documentation [here](https://miniapps.farcaster.xyz/).\n---\n\n# Use an Indexer\n\n<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/guides/indexers/ghost\"\n        title=\"GhostGraph\"\n        description=\"Index transfers with GhostGraph\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/guides/indexers/tg-bot-using-envio\"\n        title=\"Envio\"\n        description=\"Index transfers for a telegram bot using Envio\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/guides/indexers/quicknode-streams\"\n        title=\"QuickNode Streams\"\n        description=\"Index transfers using QuickNode Streams\"\n    />\n</CustomDocCardContainer>\n\n---\n\n# How to index token transfers with GhostGraph\n\nURL: https://docs.monad.xyz/guides/indexers/ghost.md"
  },
  {
    "instruction": "What is covered in the 'Introduction' section of the Developer Essentials guide?",
    "output": "In this guide, you will create an ERC20 token on Monad Testnet and index its transfers with [GhostGraph](https://docs.tryghost.xyz/). You'll learn how to:\n\n- Deploy a basic ERC20 token contract\n- Test the contract locally\n- Deploy to Monad Testnet\n- Set up event tracking with GhostGraph"
  },
  {
    "instruction": "What is covered in the 'Prerequisites' section of the Developer Essentials guide?",
    "output": "Before starting, ensure you have:\n\n- Node.js installed (v16 or later)\n- Git installed\n- [Foundry](https://github.com/foundry-rs/foundry) installed\n- Some MONAD testnet tokens (for gas fees)\n- Basic knowledge of Solidity and ERC20 tokens"
  },
  {
    "instruction": "What is covered in the 'Project Setup' section of the Developer Essentials guide?",
    "output": "First, clone the starter repository:\n\n```sh\ngit clone https://github.com/chrischang/cat-token-tutorial.git\ncd cat-token-tutorial\n```"
  },
  {
    "instruction": "What is covered in the 'CatToken Contract Implementation' section of the Developer Essentials guide?",
    "output": "The `src/CatToken.sol` contract implements a basic ERC20 token with a fixed supply. Here's the code:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract CatToken is ERC20 {\n    /**\n     * @dev Constructor that gives msg.sender all existing tokens.\n     * Initial supply is 1 billion tokens.\n     */\n    constructor() ERC20(\"CatToken\", \"CAT\") {\n        // Mint initial supply of 1 billion tokens to deployer\n        // This will emit a Transfer event that GhostGraph   can index\n        _mint(msg.sender, 1_000_000_000 * 10 ** decimals());\n    }\n}\n```\n\nThis implementation:\n\n- Creates a token with name \"CatToken\" and symbol \"CAT\"\n- Mints 1 billion tokens to the deployer's address\n- Uses OpenZeppelin's battle-tested ERC20 implementation"
  },
  {
    "instruction": "What is covered in the 'Testing the Contract' section of the Developer Essentials guide?",
    "output": "Navigate to the test file `test/CatToken.t.sol`:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract CatTokenTest is Test {\n    CatToken public token;\n    address public owner;\n    address public user;\n\n    function setUp() public {\n        owner = address(this);\n        user = address(0x1);\n\n        token = new CatToken();\n    }\n\n    function testInitialSupply() public view {\n        assertEq(token.totalSupply(), 1_000_000_000 * 10**18);\n        assertEq(token.balanceOf(owner), 1_000_000_000 * 10**18);\n    }\n\n    function testTransfer() public {\n        uint256 amount = 1_000_000 * 10**18;\n        token.transfer(user, amount);\n        assertEq(token.balanceOf(user), amount);\n        assertEq(token.balanceOf(owner), 999_000_000 * 10**18);\n    }\n}\n```\n\nRun the tests:\n\n```sh\nforge test -vv\n```"
  },
  {
    "instruction": "What is covered in the 'Deployment Setup' section of the Developer Essentials guide?",
    "output": "### 1. Create a `.env` file:\n\n```sh\ncp .env.example .env\n```\n\n### 2. Add your credentials to `.env` file:\n\n```sh\nPRIVATE_KEY=your_private_key_here\nMONAD_TESTNET_RPC=https://testnet-rpc.monad.xyz\n```\n\n### 3. Create deployment script `script/DeployCatToken.s.sol`:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract DeployCatToken is Script {\n    function run() external {\n        // Retrieve private key from environment\n        uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n\n        vm.startBroadcast(deployerPrivateKey);\n        CatToken token = new CatToken();\n        vm.stopBroadcast();\n\n        // Log the token address - this will be needed for GhostGraph indexing and submit transactions\n        console.log(\"CatToken deployed to:\", address(token));\n    }\n}\n```"
  },
  {
    "instruction": "What is covered in the 'Deploying CatToken on Monad Testnet' section of the Developer Essentials guide?",
    "output": "### 1. Load environment variables:\n\n```sh\nsource .env\n```\n\n### 2. Deploy the contract:\n\n```sh\nforge script script/DeployCatToken.s.sol \\\n--rpc-url $MONAD_TESTNET_RPC \\\n--broadcast\n```\n\nSave the deployed contract address for the next steps.\n\nRemember to add `TOKEN_ADDRESS` into your `.env` file\n\nYou should now have\n\n```sh\nPRIVATE_KEY=your_private_key_here\nMONAD_TESTNET_RPC=https://testnet-rpc.monad.xyz\nTOKEN_ADDRESS=0x...\n```"
  },
  {
    "instruction": "What is covered in the 'Verify Smart Contract' section of the Developer Essentials guide?",
    "output": "### 1. Load environment variables:\n\n```sh\nsource .env\n```\n\n### 2. Verify the contract:\n\n```sh\nforge verify-contract \\\n  --rpc-url $MONAD_TESTNET_RPC \\\n  --verifier sourcify \\\n  --verifier-url 'https://sourcify-api-monad.blockvision.org' \\\n  $TOKEN_ADDRESS \\\n  src/CatToken.sol:CatToken\n```\n\nAfter verification, you should see the contract verified on the [MonadExplorer](https://testnet.monadexplorer.com). You should see a checkmark and the banner stating the contract source code verified.\n\n![Verified Contract](/img/guides/indexers/ghost/verified-contract.png)"
  },
  {
    "instruction": "What is covered in the 'Script for Token Transfers Transactions Onchain' section of the Developer Essentials guide?",
    "output": "We perform some token transfer transactions onchain to trigger the `Transfer` event that GhostGraph will index.\n\nView the transfer script `script/TransferCatTokens.s.sol`:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract TransferCatTokens is Script {\n    function run() external {\n        uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n        address token = vm.envAddress(\"TOKEN_ADDRESS\");\n\n        vm.startBroadcast(deployerPrivateKey);\n\n        // Send tokens to test addresses\n        CatToken(token).transfer(address(0x1), 1000 * 10**18);\n        CatToken(token).transfer(address(0x2), 2000 * 10**18);\n        CatToken(token).transfer(address(0x3), 3000 * 10**18);\n\n        vm.stopBroadcast();\n    }\n}\n```\n\nRun the below command to execute transfers:\n\n```sh\nforge script script/TransferCatTokens.s.sol \\\n--rpc-url $MONAD_TESTNET_RPC \\\n--broadcast\n```\n\nYou have now deployed your ERC-20 contract and submitted transactions on the Monad testnet. Let\u2019s track these onchain events with GhostGraph."
  },
  {
    "instruction": "What is covered in the 'Setting Up GhostGraph Indexing' section of the Developer Essentials guide?",
    "output": "1. Visit [GhostGraph](https://tryghost.xyz/) and click sign up for an account\n\n2. Create a new GhostGraph\n\n![create_ghost_graph](/img/guides/indexers/ghost/create_ghost_graph.png)\n\n3. Copy and paste this into `events.sol` file. We are interested in tracking token flow. Let\u2019s insert this event here. To learn more about events: https://docs.tryghost.xyz/ghostgraph/getting-started/define-events\n\n```solidity\ninterface Events {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n```\n\n4. Copy and paste this into `schema.sol` file. In this case, we are creating a few struct which we will use to save entity into the Ghost database. To learn more about schema: https://docs.tryghost.xyz/ghostgraph/getting-started/define-schema\n\n```solidity\nstruct Global {\n    string id;\n    uint256 totalHolders;\n}\n\nstruct User {\n    address id;\n    uint256 balance;\n}\n\nstruct Transfer {\n    string id;\n    address from;\n    address to;\n    uint256 amount;\n\n    uint64 block;\n    address emitter;\n    uint32 logIndex;\n    bytes32 transactionHash;\n    uint32 txIndex;\n    uint32 timestamp;\n}\n```\n\n5. Click on `generate code` button to generate `indexer.sol` file along with some other readonly files. This file will be where the logic and transformations resides.\n\n6. Copy and paste this into `indexer.sol` be sure to insert your token address to the `CAT_TESTNET_TOKEN_CONTRACT_ADDRESS` variable.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ncontract MyIndex is GhostGraph {\n    using StringHelpers for EventDetails;\n    using StringHelpers for uint256;\n    using StringHelpers for address;\n\n    address constant CAT_TESTNET_TOKEN_CONTRACT_ADDRESS = <INSERT YOUR TOKEN ADDRESS>;\n\n    function registerHandles() external {\n        graph.registerHandle(CAT_TESTNET_TOKEN_CONTRACT_ADDRESS);\n    }\n\n    function onTransfer(EventDetails memory details, TransferEvent memory ev) external {\n        // Get global state to track holder count\n        Global memory global = graph.getGlobal(\"1\");\n\n        // Handle sender balance\n        if (ev.from != address(0)) {\n            // Skip if minting\n            User memory sender = graph.getUser(ev.from);\n            if (sender.balance == ev.value) {\n                // User is transferring their entire balance\n                global.totalHolders -= 1; // Decrease holder count\n            }\n            sender.balance -= ev.value;\n            graph.saveUser(sender);\n        }\n\n        // Handle receiver balance\n        User memory receiver = graph.getUser(ev.to);\n        if (receiver.balance == 0 && ev.value > 0) {\n            // New holder\n            global.totalHolders += 1; // Increase holder count\n        }\n        receiver.balance += ev.value;\n        graph.saveUser(receiver);\n\n        // Save global state\n        graph.saveGlobal(global);\n\n        // Create and save transfer record\n        Transfer memory transfer = graph.getTransfer(details.uniqueId());\n        transfer.from = ev.from;\n        transfer.to = ev.to;\n        transfer.amount = ev.value;\n        \n        // Store transaction metadata\n        transfer.block = details.block;\n        transfer.emitter = details.emitter;\n        transfer.logIndex = details.logIndex;\n        transfer.transactionHash = details.transactionHash;\n        transfer.txIndex = details.txIndex;\n        transfer.timestamp = details.timestamp;\n        \n        graph.saveTransfer(transfer);\n    }\n}\n```\n\n7. Compile and deploy your GhostGraph. After a few seconds, you should see GhostGraph has successfully indexed your contract.\n\n![ghostgraph_playground](/img/guides/indexers/ghost/ghostgraph_playground.png)\n\n8. Clicking on the playground will take you to the GraphQL playground, where you can ensure the data is indexed correctly. Let\u2019s copy and paste this into our playground and click the play button to fetch the data from GhostGraph.\n\n```graphql\nquery FetchRecentTransfers {\n  transfers(\n    orderBy: \"block\", \n    orderDirection: \"desc\"\n    limit: 50\n  ) {\n    items {\n      amount\n      block\n      emitter\n      from\n      id\n      logIndex\n      timestamp\n      to\n      transactionHash\n      txIndex\n    }\n  }\n}\n```\n\n![graphql_playground](/img/guides/indexers/ghost/graphql_playground.png)\n\n:::tip\nTry submitting additional transactions by running the transfer script again. You should see that GhostGraph automatically indexes the new transactions.\n:::"
  },
  {
    "instruction": "What is covered in the 'Conclusion' section of the Developer Essentials guide?",
    "output": "You have now successfully created a GhostGraph to track onchain data for your contract. The next step is to connect it to your frontend.\n\nThe Ghost team has created end-to-end tutorials on how to do just that [here](https://docs.tryghost.xyz/blog/connect_ghost_graph_to_frontend/)\n\n---\n\n# How to index every WMON transfer using QuickNode Streams\n\nURL: https://docs.monad.xyz/guides/indexers/quicknode-streams.md\n\nIn this guide, you will learn how to use QuickNode Streams to index every [WMON](https://testnet.monadexplorer.com/token/0x760AfE86e5de5fa0Ee542fc7B7B713e1c5425701) transfer, including internal transactions, on Monad Testnet."
  },
  {
    "instruction": "What is covered in the 'What is QuickNode Streams?' section of the Developer Essentials guide?",
    "output": "[QuickNode Streams](https://www.quicknode.com/docs/streams/getting-started) is a web3 data streaming solution supporting real-time and historical Monad data that offers:\n\n- **Reliable Data Delivery** - Exactly-once, guaranteed delivery, seamlessly integrating with your data lake. Streams ensures every block, receipt, or trace is delivered exactly-once in the order of dataset finality, preventing issues like corrupt or missing data\n- **Real-Time Data Consistency** - Consistent, live data streaming\n- **Efficient Historical Data Handling** - Configurable date ranges and destinations for streamlined historical data management\n- **Easy Integration** - Simple setup through a user-friendly interface\n- **Transparent User Experience** - Clear logging, metrics, and usage tracking"
  },
  {
    "instruction": "What is covered in the 'Setup Guide' section of the Developer Essentials guide?",
    "output": "### 1. Initial setup\n\n1. Sign up for [QuickNode](https://dashboard.quicknode.com/?prompt=signup) and log into your dashboard.\n\n2. Click on \"Streams\" in the left sidebar.\n\n![QuickNode Dashboard](/img/guides/indexers/quicknode-streams/1.png)\n\n3. Click on \"Create Stream\".\n\n![Create Stream Button](/img/guides/indexers/quicknode-streams/2.png)\n\n### 2. Configure Stream range\n\n1. Give your stream a name. In this example we will name it `monad-quicknode-stream`.\n\n2. In the \"Network\" section, select `Monad` from the dropdown.\n\n3. In the \"Stream Start\" section you can choose to start the stream from the latest block or from a specific block number.\n\n![Stream Configuration](/img/guides/indexers/quicknode-streams/3.png)\n\n4. In the \"Stream End\" section you can choose to end the stream until manually paused or at a specific block number.\n\n5. In the \"Latest block delay\" section, you can set a block number as a delay in receiving data. For this guide we will receive data as soon as it is available.<br/><br/>For example: If the block delay is `3`, you will receive data only when there is **new data available** for `3` blocks including latest block, this helps in case there is a reorg. \n\n6. In the \"Restream on reorg\" section you can decide if you would like to get updated data restreamed in case of a reorg. For this guide we will keep this off.\n\n7. Once done click \"Next\".\n\n![Additional Settings](/img/guides/indexers/quicknode-streams/4.png)\n\n### 3. Set up dataset\n\n1. In the \"Dataset\" dropdown you can select the dataset of your choice according to the use case. For this guide we will select `Block with Receipts` since we want to filter logs with events emitted by WMON contract.\n\n- Optional: Enable \"Batch messages\" to receive multiple blocks in a single message. This can be useful when the stream is not starting from the latest block.\n\n![Dataset Selection](/img/guides/indexers/quicknode-streams/5.png)\n\n2. Feel free to test it out by entering a block number and clicking \"Fetch payload\".\n\n![Raw Payload Example](/img/guides/indexers/quicknode-streams/6.png)\n\n### 4. Create WMON Transfer filter\n\n1. In the \"Modify the stream payload\" section, you can define filters by clicking **\"Customize your payload\"**. For this guide, we will filter to only retrieve receipts involving WMON transfers.\n\n![modify stream image](/img/guides/indexers/quicknode-streams/7.png)\n\n2. QuickNode has a set of filter templates. Select the **Decoded ERC20 transfers** template:\n\n![image for filter](/img/guides/indexers/quicknode-streams/8.png)\n\n3. The editor will appear:\n\n![image of filter editor](/img/guides/indexers/quicknode-streams/9.png)\n\nThe current filter allows all ERC20 transfers through. Replace the filter code with:\n\n```js\nfunction main(stream) {  \n  const erc20Abi = `[{\n    \"anonymous\": false,\n    \"inputs\": [\n      {\"indexed\": true, \"type\": \"address\", \"name\": \"from\"},\n      {\"indexed\": true, \"type\": \"address\", \"name\": \"to\"},\n      {\"indexed\": false, \"type\": \"uint256\", \"name\": \"value\"}\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  }]`;\n  \n  const data = stream.data ? stream.data : stream;\n  \n  // Decodes logs from the receipts that match the Transfer event ABI\n  var result = decodeEVMReceipts(data[0].receipts, [erc20Abi]);\n  \n  // Filter for receipts with decoded logs\n  result = result.filter(receipt => {\n        // Check if there are any ERC20 transfers\n        if(receipt.decodedLogs) {\n            // Check if there are any WMON transfers\n            receipt.decodedLogs = receipt.decodedLogs.filter(log => log.address == \"0x760AfE86e5de5fa0Ee542fc7B7B713e1c5425701\");\n            \n            // Return receipt if there logs which indicate a WMON transfer.\n            return receipt.decodedLogs.length > 0;\n        }\n\n        // Return nothing if there are no ERC20 transfers.\n        return false;\n    });\n  \n  return { result };\n}\n```\n\n4. Test the filter with \"Run test\"\n\n![run test image](/img/guides/indexers/quicknode-streams/10.png)\n\n5. \"Save & close\" to save the filter.\n\n![save & close image](/img/guides/indexers/quicknode-streams/11.png)\n\n6. Click \"Next\"\n\n### 5. Set up Stream destination\n\nFor this guide we will keep the stream destination simple and use `Webhook` as the \"Destination Type\".\n\n1. Let's use a site like [Svix Play](https://www.svix.com/play/) to quickly get a webhook and test the stream.\n\n![svix play image](/img/guides/indexers/quicknode-streams/12.png)\n\n2. Copy the webhook url from Svix Play:\n\n![svix play copy url image](/img/guides/indexers/quicknode-streams/13.png)\n\n3. In QuickNode:\n  - Select `Webhook` as destination type\n  - Paste your webhook URL\n  - We can keep the rest of the settings as default\n\n![webhook dropdown image](/img/guides/indexers/quicknode-streams/14.png)\n\n4. Click on \"Check Connection\" to test the webhook url. Check if you received the \"PING\" message in the Svix Play dashboard.\n\n![check connection image](/img/guides/indexers/quicknode-streams/15.png)\n\n![ping message image](/img/guides/indexers/quicknode-streams/16.png)\n\n5. Click \"Send Payload\" to send a test payload to the webhook.\n\n![add send payload image](/img/guides/indexers/quicknode-streams/17.png)\n\n![svix payload image](/img/guides/indexers/quicknode-streams/18.png)\n\n6. Finally click \"Create a Stream\" to create the stream.\n\n![create stream image](/img/guides/indexers/quicknode-streams/19.png)\n\n### 6. Launch and Monitor\n\nYou should now be able to see the stream delivering the messages to the webhook!\n\n![stream delivering image](/img/guides/indexers/quicknode-streams/20.png)\n\n![svix streaming receiving message video](/img/guides/indexers/quicknode-streams/1.gif)\n\nYou can pause the stream by clicking the switch in the top right corner.\n\n![pause switch image](/img/guides/indexers/quicknode-streams/21.png)"
  },
  {
    "instruction": "What is covered in the 'Next Steps' section of the Developer Essentials guide?",
    "output": "- Monitor your stream's performance in the QuickNode dashboard\n- Adjust filter parameters as needed\n- Connect to your production webhook endpoint when ready\n\nYour stream will now track all WMON transfers until manually paused or until reaching your specified end block.\n---\n\n# How to build a transfer notification bot with Envio HyperIndex\n\nURL: https://docs.monad.xyz/guides/indexers/tg-bot-using-envio.md\n\nIn this guide, you will learn how to use [Envio](https://envio.dev/) HyperIndex to create a Telegram bot that sends notifications whenever WMON tokens are transferred on the Monad Testnet. We'll walk through setting up both the indexer and the Telegram bot.\n\nEnvio HyperIndex is an open development framework for building blockchain application backends. It offers real-time indexing, automatic indexer generation from contract addresses, and triggers for external API calls."
  },
  {
    "instruction": "What is covered in the 'Prerequisites' section of the Developer Essentials guide?",
    "output": "You'll need the following installed:\n\n- Node.js v18 or newer\n- pnpm v8 or newer\n- Docker Desktop (required for running the Envio indexer locally)"
  },
  {
    "instruction": "What is covered in the 'Setting up the project' section of the Developer Essentials guide?",
    "output": "First, create and enter a new directory:\n\n```shell\nmkdir envio-mon && cd envio-mon\n```\n\n### Get the contract ABI\n\n1. Create an `abi.json` file:\n```shell\ntouch abi.json\n```\n\n2. Copy the [WrappedMonad](https://testnet.monadexplorer.com/token/0x760AfE86e5de5fa0Ee542fc7B7B713e1c5425701?tab=Contract) ABI from the explorer\n\n![image of explorer](/img/guides/indexers/tg-bot-using-envio/1.png)\n\n3. Paste the ABI into your `abi.json` file\n\n### Initialize the project\n\nRun the initialization command:\n```shell\npnpx envio init\n```\n\nFollow the prompts:\n1. Press Enter when asked for a folder name (to use current directory)\n2. Select `TypeScript` as your language\n3. Choose `Evm` as the blockchain ecosystem\n4. Select `Contract Import` for initialization\n5. Choose `Local ABI` as the import method\n6. Enter `./abi.json` as the path to your ABI file\n7. Select only the `Transfer` event to index\n8. Choose `<Enter Network Id>` and input `10143` (Monad Testnet chain ID)\n9. Enter `WrappedMonad` as the contract name\n10. Input the contract address: `0x760AfE86e5de5fa0Ee542fc7B7B713e1c5425701`\n11. Select `I'm finished` since we're only indexing one contract\n12. Choose whether to create or add an existing API token. If you choose to create a new token, you'll be taken to a page that looks like this:\n\n<img src=\"/img/guides/indexers/tg-bot-using-envio/2.png\" alt=\"new API token view\" width=\"600\"/>\n\nOnce the project is initialized, you should see the following project structure in your project directory.\n\n<img src=\"/img/guides/indexers/tg-bot-using-envio/3.png\" alt=\"envio dashboard\" width=\"400\"/>\n\nAdd the following code to `config.yaml` file, to make transaction hash available in event handler:\n\n```yaml\n# default config...\nfield_selection:\n    transaction_fields:\n      - hash\n```\n\n*More details about the `field_selection` config [here](https://docs.envio.dev/docs/HyperIndex/configuration-file#field-selection)*"
  },
  {
    "instruction": "What is covered in the 'Starting the indexer' section of the Developer Essentials guide?",
    "output": "Start Docker Desktop.\n\nTo start the indexer run the following command in the project directory:\n\n```shell\npnpx envio dev\n```\n\nYou should see something similar to the below image in your terminal; this means that the indexer is syncing and will eventually reach the tip of the chain.\n\n<img src=\"/img/guides/indexers/tg-bot-using-envio/4.png\" alt=\"envio indexer syncing\" width=\"600\"/>\n\n\nYou will also see this page open in your browser automatically, the password is `testing`.\n<img src=\"/img/guides/indexers/tg-bot-using-envio/5.png\" alt=\"hasura local page\" width=\"600\"/>\n\nWe can use this interface to query the indexer using GraphQL. Results will depend on the sync progress:\n\n![query interface](/img/guides/indexers/tg-bot-using-envio/6.png)\n\nCurrently, the indexer is catching up to the tip of the chain. Once syncing is complete the indexer will be able to identify latest WMON transfers.\n\nWe can shut down the indexer for now, so we can proceed with Telegram integration."
  },
  {
    "instruction": "What is covered in the 'Creating the Telegram bot' section of the Developer Essentials guide?",
    "output": "1. Visit [BotFather](https://t.me/botfather) to create your bot and get an API token\n2. Add these environment variables to your `.env` file:\n```\nENVIO_BOT_TOKEN=<your_bot_token>\nENVIO_TELEGRAM_CHAT_ID=<your_chat_id>\n```\n\nTo get your chat ID:\n1. Create a Telegram group and add your bot\n2. Send `/start` to the bot: `@YourBot /start`\n3. Visit `https://api.telegram.org/bot<YourBOTToken>/getUpdates`\n4. Look for the channel chat ID (it should start with \"-\")\n\n:::note\nIf you don't see the chat ID, try removing and re-adding the bot to the group.\n:::\n\nThe Telegram bot is now ready."
  },
  {
    "instruction": "What is covered in the 'Integrating Telegram API to HyperIndex Event Handler' section of the Developer Essentials guide?",
    "output": "Create a folder `libs` inside `src` folder in the project directory, create a file inside it `telegram.ts` and add the following code\n\n```ts\n// src/libs/telegram.ts\n\nexport const sendMessageToTelegram = async (message: string): Promise<void> => {\n  try {\n    const apiUrl = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;\n\n    await axios.post(apiUrl, {\n      chat_id: CHAT_ID,\n      text: message,\n      parse_mode: \"HTML\",\n    });\n  } catch (error) {\n    console.error(\"Error sending message:\", error);\n  }\n};\n```\n\nYou will come across some errors, let's fix them.\n\nInstall `axios` package\n\n```bash\npnpm i axios\n```\n\nCreate a file in `src` folder called `constants.ts` and add the following code:\n\n```ts\n// src/constants.ts\n\nexport const EXPLORER_URL_MONAD = \"https://testnet.monadexplorer.com/\";\n\n// Threshold for WMON transfer amount above which the bot sends a notification\nexport const THRESHOLD_WEI: string = process.env.ENVIO_THRESHOLD_WEI ?? \"1000000000000000000\"; // in wei\n\nexport const BOT_TOKEN = process.env.ENVIO_BOT_TOKEN; // Telegram bot token\nexport const CHAT_ID = process.env.ENVIO_TELEGRAM_CHAT_ID; // WMON Transfers Notification Channel ID\n\n// Function to get explorer url for the provided address\nexport const explorerUrlAddress = (address: string) =>\n  EXPLORER_URL_MONAD + \"address/\" + address;\n\n// Function to get explorer url for the provided transaction hash\nexport const explorerUrlTx = (txHash: string) =>\n  EXPLORER_URL_MONAD + \"tx/\" + txHash;\n```\n\nWe can now edit the `EventHandlers.ts` in `src` folder, to add the code for sending the telegram message:\n\n```ts\n// src/EventHandlers.ts\n\n// Other event handlers can be removed...\n\nWrappedMonad.Transfer.handler(async ({ event, context }) => {\n    const from_address = event.params.src;\n    const to_address = event.params.dst;\n\n  if (isIndexingAtHead(event.block.timestamp) && event.params.wad >= BigInt(THRESHOLD_WEI)) {\n    // Only send a message when the indexer is indexing event from the time it was started and not historical transfers, and only message if the transfer amount is greater than or equal to THRESHOLD_WEI.\n\n    // Example message\n    // WMON Transfer ALERT: A new transfer has been made by 0x65C3564f1DD63eA81C11D8FE9a93F8FFb5615233 to 0xBA5Cf1c0c1238F60832618Ec49FC81e8C7C0CF01 for 2.0000 WMON! \ud83d\udd25 - View on Explorer\n\n    const msg = `WMON Transfer ALERT: A new transfer has been made by <a href=\"${explorerUrlAddress(from_address)}\">${from_address}</a> to <a href=\"${explorerUrlAddress(to_address)}\">${to_address}</a> for ${weiToEth(event.params.wad)} WMON! \ud83d\udd25 - <a href=\"${explorerUrlTx(\n      event.transaction.hash\n    )}\">View on Explorer</a>`;\n\n    await sendMessageToTelegram(msg);\n  }\n});\n```\n\nLet us now fix the import error.\n\nCreate a file called `helpers.ts` in `src/libs` folder, paste the following code in it:\n\n```ts\n// src/libs/helpers.ts\n\n// Used to ensure notifications are only sent while indexing at the head and not historical sync\nconst INDEXER_START_TIMESTAMP = Math.floor(new Date().getTime() / 1000);\n\nexport const isIndexingAtHead = (timestamp: number): boolean => {\n    return timestamp >= INDEXER_START_TIMESTAMP;\n}\n\n// Convert wei to ether for human readability\nexport const weiToEth = (bigIntNumber: bigint): string => {\n  // Convert BigInt to string\n  const numberString = bigIntNumber.toString();\n\n  const decimalPointsInEth = 18;\n\n  // Extract integer part and decimal part\n  const integerPart = numberString.substring(\n    0,\n    numberString.length - decimalPointsInEth\n  );\n\n  const decimalPart = numberString.slice(-decimalPointsInEth);\n\n  // Insert decimal point\n  const decimalString =\n    (integerPart ? integerPart : \"0\") +\n    \".\" +\n    decimalPart.padStart(decimalPointsInEth, \"0\");\n\n  // Add negative sign if necessary\n  return decimalString.slice(0, -14);\n};\n```\n\nThat's it! We can now run the indexer, and the telegram bot will start sending messages in the telegram channel when the indexer detects a WMON transfer!\n\n![example bot message](/img/guides/indexers/tg-bot-using-envio/9.png)\n*Note: Screenshot was taken before message format was changed. The message will be slightly different if you followed the guide.*\n\n:::note\nYou may not immediately start seeing messages because the indexer take some time to catch up to the tip of the the recent blocks.\n\nThe bot will only send notifications for transfers when the indexer detects a WMON transfer in finalized blocks, with timestamp greater than or equal to the indexer start time.\n:::\n---\n\n# How to build an MCP server that can interact with Monad Testnet\n\nURL: https://docs.monad.xyz/guides/monad-mcp.md\n\nIn this guide, you will learn how to build a [Model Context Protocol](https://github.com/modelcontextprotocol) (MCP) server that allows an MCP Client (Claude Desktop) to query Monad Testnet to check the MON balance of an account."
  },
  {
    "instruction": "What is covered in the 'What is MCP?' section of the Developer Essentials guide?",
    "output": "The [Model Context Protocol](https://github.com/modelcontextprotocol) (MCP) is a standard that allows AI models to interact with external tools and services."
  },
  {
    "instruction": "What is covered in the 'Prerequisites' section of the Developer Essentials guide?",
    "output": "- Node.js (v16 or later)\n- `npm` or `yarn`\n- Claude Desktop"
  },
  {
    "instruction": "What is covered in the 'Getting started' section of the Developer Essentials guide?",
    "output": "1. Clone the [`monad-mcp-tutorial`](https://github.com/monad-developers/monad-mcp-tutorial) repository. This repository has some code that can help you get started quickly.\n\n```shell\ngit clone https://github.com/monad-developers/monad-mcp-tutorial.git\n```\n\n2. Install dependencies:\n\n```\nnpm install\n```"
  },
  {
    "instruction": "What is covered in the 'Building the MCP server' section of the Developer Essentials guide?",
    "output": "Monad Testnet-related configuration is already added to `index.ts` in the `src` folder.\n\n### Define the server instance\n\n```ts\n// Create a new MCP server instance\nconst server = new McpServer({\n  name: \"monad-mcp-tutorial\",\n  version: \"0.0.1\",\n  // Array of supported tool names that clients can call\n  capabilities: [\"get-mon-balance\"]\n});\n```\n\n### Define the MON balance tool\n\nBelow is the scaffold of the `get-mon-balance` tool:\n\n```ts\nserver.tool(\n    // Tool ID \n    \"get-mon-balance\",\n    // Description of what the tool does\n    \"Get MON balance for an address on Monad testnet\",\n    // Input schema\n    {\n        address: z.string().describe(\"Monad testnet address to check balance for\"),\n    },\n    // Tool implementation\n    async ({ address }) => {\n        // code to check MON balance\n    }\n);\n```\n\nLet's add the MON balance check implementation to the tool:\n\n```ts\nserver.tool(\n    // Tool ID \n    \"get-mon-balance\",\n    // Description of what the tool does\n    \"Get MON balance for an address on Monad testnet\",\n    // Input schema\n    {\n        address: z.string().describe(\"Monad testnet address to check balance for\"),\n    },\n    // Tool implementation\n    async ({ address }) => {\n        try {\n            // Check MON balance for the input address\n            const balance = await publicClient.getBalance({\n                address: address as `0x${string}`,\n            });\n\n            // Return a human friendly message indicating the balance.\n            return {\n                content: [\n                    {\n                        type: \"text\",\n                        text: `Balance for ${address}: ${formatUnits(balance, 18)} MON`,\n                    },\n                ],\n            };\n        } catch (error) {\n            // If the balance check process fails, return a graceful message back to the MCP client indicating a failure.\n            return {\n                content: [\n                    {\n                        type: \"text\",\n                        text: `Failed to retrieve balance for address: ${address}. Error: ${\n                        error instanceof Error ? error.message : String(error)\n                        }`,\n                    },\n                ],\n            };\n        }\n    }\n);\n```\n\n### Initialize the transport and server from the `main` function\n\n```ts\nasync function main() {\n    // Create a transport layer using standard input/output\n    const transport = new StdioServerTransport();\n    \n    // Connect the server to the transport\n    await server.connect(transport);\n}\n```\n\n### Build the project\n\n```shell\nnpm run build\n```\n\nThe server is now ready to use!\n\n### Add the MCP server to Claude Desktop\n\n1. Open \"Claude Desktop\"\n\n![claude desktop](https://github.com/monad-developers/monad-mcp-tutorial/blob/main/static/1.png?raw=true)\n\n2. Open Settings\n\nClaude > Settings > Developer\n\n![claude settings](https://github.com/monad-developers/monad-mcp-tutorial/blob/main/static/claude_settings.gif?raw=true)\n\n3. Open `claude_desktop_config.json` \n\n![claude config](https://github.com/monad-developers/monad-mcp-tutorial/blob/main/static/config.gif?raw=true)\n\n4. Add details about the MCP server and save the file.\n\n```json\n{\n  \"mcpServers\": {\n    ...\n    \"monad-mcp\": {\n      \"command\": \"node\",\n      \"args\": [\n        \"/<path-to-project>/build/index.js\"\n      ]\n    }\n  }\n}\n```\n\n5. Restart \"Claude Desktop\"\n\n### Use the MCP server\n\nYou should now be able to see the tools in Claude!\n\n![tools](https://github.com/monad-developers/monad-mcp-tutorial/blob/main/static/tools.gif?raw=true)\n\nHere's the final result\n\n![final result](https://github.com/monad-developers/monad-mcp-tutorial/blob/main/static/final_result.gif?raw=true)"
  },
  {
    "instruction": "What is covered in the 'Further resources' section of the Developer Essentials guide?",
    "output": "- [Model Context Protocol Documentation](https://modelcontextprotocol.io/introduction)\n- [Monad Documentation](https://docs.monad.xyz/)\n- [Viem Documentation](https://viem.sh/)\n\n\n\n\n\n\n---\n\n# How to connect a wallet to your app with Reown AppKit\n\nURL: https://docs.monad.xyz/guides/reown-guide.md\n\nIn this guide, you'll learn how to use Reown AppKit to enable wallet connections and interact with the Monad network.\n\nWith AppKit, you can provide seamless wallet connections, including email and social logins, smart accounts, one-click authentication, and wallet notifications, all designed to deliver an exceptional user experience.\n\nIn this tutorial, you will learn how to:\n\n1. Initialize a new project using AppKit CLI and setting up the Project ID.\n2. Configure the project with Monad Testnet.\n\nThis guide takes approximately 5 minutes to complete."
  },
  {
    "instruction": "What is covered in the 'Setup' section of the Developer Essentials guide?",
    "output": "In this section, you'll set up the development environment to use AppKit with Monad. \n\nFor this tutorial, we'll be using Next.js, though you can use any other framework compatible with AppKit.\n\n:::note\nAppKit is available on eight frameworks, including React, Next.js, Vue, JavaScript, React Native, Flutter, Android, iOS, and Unity.\n:::\n\nNow, let\u2019s create a Next app using the CLI. In order to do so, please run the command given below:\n\n```bash\nnpx @reown/appkit-cli\n```\n\nThe above command uses the AppKit CLI to allow you to effortlessly set up a simple web app configured with Reown AppKit.\n\nAfter running the command, you will be prompted to confirm the installation of the CLI. Upon your confirmation, the CLI will request the following details:\n\n1. **Project Name**: Enter the name for your project. (eg: `my-monad-appkit-app`)\n2. **Framework**: Select your preferred framework or library. Currently, you have three options: `React`, `Next.js`, and `Vue`.\n3. **Network-Specific libraries**: Choose whether you want to install Wagmi, Ethers, Solana, or Multichain (EVM + Solana). In this case, you need to either pick `Wagmi` or `Ethers` since Monad is an EVM compatible blockchain. We will be choosing `Wagmi` for the sake of this tutorial.\n\nAfter providing the project name and selecting your preferences, the CLI will install a minimal example of AppKit with your preferred blockchain library. \n\nWhen the example installation is complete, you can enter the project directory by running the below command in your terminal.\n\n```bash\ncd my-monad-appkit-app\n```\n\nNow, you need to install the dependencies required to run the AppKit project. In order to do this, please run the command given below.\n\n```bash\nnpm install\n```\n\n:::note\nYou can also use other package managers such as `yarn`, `bun`, `pnpm`, etc. \n:::\n\n### Create a new project on Reown Cloud\n\nWe need to get a Project ID from Reown Cloud that we will use to set up AppKit with Wagmi config. Navigate to [cloud.reown.com](https://cloud.reown.com) and sign in. If you have not created an account yet, please do so before we proceed.\n\nAfter you have logged in, please navigate to the \"Projects\" section of the Cloud and click on \"Create Project\". \n\n![Create Project](/img/guides/reown-guide/1.png)\n\nNow, enter the name for your project and click on \"Continue\".\n\n![Enter Project Name](/img/guides/reown-guide/2.png)\n\nSelect the product as \"AppKit\" and click on \"Continue\". \n\n![Select Product](/img/guides/reown-guide/3.png)\n\nSelect the framework as \"Next.js\" and click on \"Create\". Reown Cloud will now create a new project for you which will also generate a Project ID. \n\n![Select Framework](/img/guides/reown-guide/4.png)\n\nYou will notice that your project was successfully created. On the top left corner, you will be able to find your Project ID. Please copy that as you will need that later. \n\n![Project ID](/img/guides/reown-guide/5.png)\n\n### Set up the Project ID\n\nBefore we build the app, let\u2019s first configure our `.env` file. Open the project that you created using the AppKit CLI in your preferred code editor.\n\nOn the root level of your code directory, create a new file named `.env`.\n\nOpen that file and create a new variable `NEXT_PUBLIC_PROJECT_ID`. We will assign the project Id that we copied in the previous step to this environment variable that we just created. This is what it will look like:\n\n```js\nNEXT_PUBLIC_PROJECT_ID =\"YOUR_PROJECT_ID_HERE\"\n```\n\n:::warning\nNote: Please make sure you follow the best practices when you are working with secret keys and other sensitive information. Environment variables that start with `NEXT_PUBLIC` will be exposed by your app which can be misused by bad actors. \n:::"
  },
  {
    "instruction": "What is covered in the 'Configure AppKit with Monad Testnet' section of the Developer Essentials guide?",
    "output": "Navigate to `/src/config/index.ts` file.\n\nWithin this code file, you can notice that the networks configured with AppKit are being pulled from `@reown/appkit/networks`. Please update the corresponding import statement as shown below.\n\n```ts\n<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Foundry />}\n        link=\"/guides/verify-smart-contract/foundry\"\n        title=\"Foundry\"\n        description=\"Verify a smart contract on Monad using Foundry\"\n    />\n    <CustomDocCard\n        icon={<Hardhat />}\n        link=\"/guides/verify-smart-contract/hardhat\"\n        title=\"Hardhat\"\n        description=\"Verify a smart contract on Monad using Hardhat\"\n    />\n</CustomDocCardContainer>\n\n\n---\n\n# Verify a smart contract on Monad Explorer using Foundry\n\nURL: https://docs.monad.xyz/guides/verify-smart-contract/foundry\n\nOnce your contract is deployed to a live network, the next step is to verify its source code on the block explorer.\n\nVerifying a contract means uploading its source code, along with the settings used to compile the code, to a\nrepository (typically maintained by a block explorer). This allows anyone to compile it and compare the generated\nbytecode with what is deployed on chain. Doing this is extremely important in an open platform like Monad.\n\nIn this guide we'll explain how to do this on [MonadExplorer](https://testnet.monadexplorer.com) using [Foundry](https://getfoundry.sh/).\n\n<Tabs>\n    <TabItem\n        value=\"with-foundry-monad\"\n        label=\"Foundry Monad template (Recommended)\"\n        default\n    >\n        If you are using [`foundry-monad`](https://github.com/monad-developers/foundry-monad) template, you can simply run the below command:\n\n        ```sh\n        forge verify-contract \\\n            <contract_address> \\\n            <contract_name> \\\n            --chain 10143 \\\n            --verifier sourcify \\\n            --verifier-url https://sourcify-api-monad.blockvision.org\n        ```\n\n        Example:\n\n        ```sh\n        forge verify-contract \\\n            0x195B9401D1BF64D4D4FFbEecD10aE8c41bEBA453 \\\n            src/Counter.sol:Counter \\\n            --chain 10143 \\\n            --verifier sourcify \\\n            --verifier-url https://sourcify-api-monad.blockvision.org\n        ```\n    </TabItem>\n    <TabItem value=\"default-foundry-project\"\n        label=\"Default Foundry Project\">\n        :::tip\n        If you use [`foundry-monad`](https://github.com/monad-developers/foundry-monad) you can skip the configuration step\n        :::\n\n        ## 1. Update `foundry.toml` with Monad Configuration\n\n        ```toml\n        [profile.default]\n        src = \"src\"\n        out = \"out\"\n        libs = [\"lib\"]\n        metadata = true\n        metadata_hash = \"none\"  # disable ipfs\n        use_literal_content = true # use source code\n\n        # Monad Configuration\n        eth-rpc-url=\"https://testnet-rpc.monad.xyz\"\n        chain_id = 10143\n        ```\n\n        ## 2. Verify the contract using the command below:\n\n        ```sh\n        forge verify-contract \\\n            <contract_address> \\\n            <contract_name> \\\n            --verify \\\n            --verifier sourcify \\\n            --verifier-url https://sourcify-api-monad.blockvision.org\n        ```\n\n        Example:\n\n        ```sh\n        forge verify-contract \\\n            0x195B9401D1BF64D4D4FFbEecD10aE8c41bEBA453 \\\n            src/Counter.sol:Counter \\\n            --verify \\\n            --verifier sourcify \\\n            --verifier-url https://sourcify-api-monad.blockvision.org\n        ```\n    </TabItem>\n\n</Tabs>\n\nOn successful verification of smart contract, you should get a similar output in your terminal:\n\n```sh\nStart verifying contract `0x195B9401D1BF64D4D4FFbEecD10aE8c41bEBA453` deployed on 10143\n\nSubmitting verification for [Counter] \"0x195B9401D1BF64D4D4FFbEecD10aE8c41bEBA453\".\nContract successfully verified\n```\n\nNow check the contract on [Monad Explorer](https://testnet.monadexplorer.com/).\n---\n\n# Verify a smart contract on Monad Explorer using Hardhat\n\nURL: https://docs.monad.xyz/guides/verify-smart-contract/hardhat\n\nOnce your contract is deployed to a live network, the next step is to verify its source code on the block explorer.\n\nVerifying a contract means uploading its source code, along with the settings used to compile the code, to a\nrepository (typically maintained by a block explorer). This allows anyone to compile it and compare the generated\nbytecode with what is deployed on chain. Doing this is extremely important in an open platform like Monad.\n\nIn this guide we'll explain how to do this on [MonadExplorer](https://testnet.monadexplorer.com) using [Hardhat](https://hardhat.org/)."
  },
  {
    "instruction": "What is covered in the '1. Update your `hardhat.config.ts` file to include the `monadTestnet` configuration if not already present' section of the Developer Essentials guide?",
    "output": "```ts\nconst config: HardhatUserConfig = {\n  solidity: {\n    version: \"0.8.28\",\n    settings: {\n      metadata: {\n        bytecodeHash: \"none\", // disable ipfs\n        useLiteralContent: true, // use source code\n      },\n    },\n  },\n  networks: {\n    monadTestnet: {\n      url: \"https://testnet-rpc.monad.xyz\",\n      chainId: 10143,\n    },\n  },\n  sourcify: {\n    enabled: true,\n    apiUrl: \"https://sourcify-api-monad.blockvision.org\",\n    browserUrl: \"https://testnet.monadexplorer.com\",\n  },\n  // To avoid errors from Etherscan\n  etherscan: {\n    enabled: false,\n  },\n};\n\nexport default config;\n```"
  },
  {
    "instruction": "What is covered in the '3. Verify the smart contract' section of the Developer Essentials guide?",
    "output": "Use the following command to verify the smart contract:\n\n```sh\nnpx hardhat verify <contract_address> --network monadTestnet\n```\n\nOn successful verification of smart contract, the output should be similar to the following:\n\n```\nSuccessfully verified contract Lock on Sourcify.\nhttps://testnet.monadexplorer.com/contracts/full_match/10143/<contract_address>/\n```\n\nUsing the link in the output above, you can view the verified smart contract on the explorer.\n\nNow check the contract on [Monad Explorer](https://testnet.monadexplorer.com/).\n\n---\n\n\n# Introduction\n\nMonad is a high-performance Ethereum-compatible L1. Monad materially advances the efficient frontier in the balance between decentralization and scalability.\n\nMonad introduces optimizations in four major areas, resulting in a blockchain with throughput of over 10,000 transactions per second (tps):\n\n-   [MonadBFT](monad-arch/consensus/monad-bft.mdx)\n-   [Asynchronous Execution](monad-arch/consensus/asynchronous-execution.mdx)\n-   [Parallel Execution](monad-arch/execution/parallel-execution.md)\n-   [MonadDb](monad-arch/execution/monaddb.md)\n\nMonad's improvements address existing bottlenecks while preserving seamless compatibility for application developers (full EVM bytecode equivalence) and users (Ethereum [RPC API](reference/json-rpc) compatibility).\n\nFor an executive summary, see [Monad for Users](/introduction/monad-for-users) or [Monad for Developers](/introduction/monad-for-developers)."
  },
  {
    "instruction": "What is covered in the 'Architecture' section of the Developer Essentials guide?",
    "output": "The Monad client is built with a focus on performance and is written from scratch in C++ and Rust. \n\nThe subsequent pages survey the major [architectural changes](monad-arch) in Monad as well as the interface for users."
  },
  {
    "instruction": "What is covered in the 'Testnet' section of the Developer Essentials guide?",
    "output": "Monad's public testnet is live! Head to [Network information](developer-essentials/network-information) to get started.\n\nMany leading Ethereum developer tools support Monad testnet. See the [Tooling and Infrastructure](tooling-and-infra/README.md) page for a list of supported providers by category.\n\n---\n\n\n# Monad for Developers\n\nMonad is an Ethereum-compatible Layer-1 blockchain with 10,000 tps of throughput, 500ms block frequency, and 1s finality.\n\nMonad's implementation of the Ethereum Virtual Machine complies with the [Cancun fork](https://www.evm.codes/?fork=cancun); simulation of historical Ethereum transactions with the Monad execution environment produces identical outcomes. Monad also offers full Ethereum RPC compatibility so that users can interact with Monad using familiar tools like Etherscan, Phantom, or MetaMask.\n\nMonad accomplishes these performance improvements, while preserving backward compatibility, through the introduction of several major innovations:\n\n-   [MonadBFT](monad-arch/consensus/monad-bft.mdx) (pipelined HotStuff consensus with additional research improvements)\n-   [Asynchronous Execution](monad-arch/consensus/asynchronous-execution.mdx) (pipelining between consensus and execution to significantly increase the execution budget)\n-   [Parallel Execution](monad-arch/execution/parallel-execution.md)\n-   [MonadDb](monad-arch/execution/monaddb.md) (high-performance state backend)\n\nAlthough Monad features parallel execution and pipelining, it's important to note that blocks in Monad are linear, and transactions are linearly ordered within each block."
  },
  {
    "instruction": "What is covered in the 'Transactions' section of the Developer Essentials guide?",
    "output": "<table data-header-hidden>\n    <thead>\n        <tr>\n            <th width=\"248.5\"></th>\n            <th></th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>Address space</td>\n            <td>Same address space as Ethereum (20-byte addresses using ECDSA)</td>\n        </tr>\n        <tr>\n            <td>Transaction format/types</td>\n            <td>[Same as Ethereum](https://ethereum.org/en/developers/docs/transactions/). Monad transactions use the same typed transaction envelope introduced in [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718), encoded with [RLP](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).<br/><br/>Transaction type 0 (\"legacy\"), 1 (\"EIP-2930\"), and 2 (\"EIP-1559\"; now the default in Ethereum) are supported. See [transaction type reference](https://ethereum.org/en/developers/docs/transactions/#typed-transaction-envelope).<br/><br/>Transaction type 3 (\"EIP-4844\") is not yet supported in testnet.</td>\n        </tr>\n        <tr>\n            <td>Wallet compatibility</td>\n            <td>Monad is compatible with standard Ethereum wallets such as Phantom or MetaMask. The only change required is to alter the RPC URL and chain id.</td>\n        </tr>\n        <tr>\n            <td>Gas pricing</td>\n            <td>Monad is EIP-1559-compatible; base fee and priority fee work as in Ethereum.<br/>\n            <br/>Transactions are ordered according to a Priority Gas Auction (descending total gas price).<br/>\n            <br/>In testnet, base fee is hard-coded to 50 gwei, although it will become dynamic in the future.<br/>\n            <br/>In testnet, **transactions are charged based on gas limit rather than gas usage**, i.e. total tokens deducted from the sender's balance is `value + gas_price * gas_limit`. This is a DOS-prevention measure for asynchronous execution.<br/>\n            <br/>See [Gas in Monad](/developer-essentials/gas-on-monad.md) for more details.</td>\n        </tr>\n    </tbody>\n</table>"
  },
  {
    "instruction": "What is covered in the 'Smart contracts' section of the Developer Essentials guide?",
    "output": "<table data-header-hidden>\n    <thead>\n        <tr>\n            <th width=\"248.5\"></th>\n            <th></th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>Opcodes</td>\n            <td>Monad supports EVM bytecode, and is bytecode-equivalent to Ethereum. All [opcodes](https://www.evm.codes/?fork=cancun) (as of the Cancun fork, e.g. TLOAD, TSTORE, and MCOPY) are supported.</td>\n        </tr>\n        <tr>\n            <td>Opcode pricing</td>\n            <td>Opcode pricing matches Ethereum as of the Cancun fork.</td>\n        </tr>\n        <tr>\n            <td>Max contract size</td>\n            <td>128 kb (up from 24 kb in Ethereum)</td>\n        </tr>\n    </tbody>\n</table>"
  },
  {
    "instruction": "What is covered in the 'Consensus' section of the Developer Essentials guide?",
    "output": "<table data-header-hidden>\n    <thead>\n        <tr>\n            <th width=\"191.5\"></th>\n            <th></th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>Sybil resistance mechanism</td>\n            <td>Proof-of-Stake (PoS)</td>\n        </tr>\n        <tr>\n            <td>Delegation</td>\n            <td>Allowed (in-protocol)</td>\n        </tr>\n        <tr>\n            <td>Consensus mechanism and pipelining</td>\n            <td>[MonadBFT](monad-arch/consensus/monad-bft.mdx) is a leader-based algorithm for reaching agreement about transaction order and inclusion under partially synchronous conditions. Broadly characterized, it is a derivative of HotStuff with additional research improvements.<br/><br/>MonadBFT is a pipelined 2-phase BFT algorithm with linear communication overhead in the common case. As in most BFT algorithms, communication proceeds in phases. At each phase, the leader sends a signed message to the voters, who send back signed responses.  Pipelining allows the quorum certificate (QC) or timeout certificate (TC) for block <code>k</code> to piggyback on the proposal for block <code>k+1.</code> Timeouts incur quadratic messaging.</td>\n        </tr>\n        <tr>\n            <td>Block Frequency</td>\n            <td>500 ms</td>\n        </tr>\n        <tr>\n            <td>Finality</td>\n            <td>1 second</td>\n        </tr>\n        <tr>\n            <td>Mempool</td>\n            <td>Leaders maintain a local mempool. When an RPC receives a transaction, it forwards it to the next 3 leaders who keep it in their local mempool. Additional forwarding may be added at a later time.</td>\n        </tr>\n        <tr>\n            <td>Consensus participants</td>\n            <td>Direct consensus participants vote on block proposals and serve as leaders. To serve as a direct participant, a node must have at least <code>MinStake</code> staked and be in the top <code>MaxConsensusNodes</code> participants by stake weight. These parameters are set in code.</td>\n        </tr>\n        <tr>\n            <td>Transaction hashing</td>\n            <td>For efficiency, block proposals refer to transactions by hash only.  If a node does not have a transaction, it will request the transaction by hash from a neighbor.</td>\n        </tr>\n        <tr>\n            <td>Asynchronous execution</td>\n            <td>\n                <p>In Monad, consensus and execution occur in a pipelined fashion.  Nodes come to consensus on the official transaction order <em>prior</em> to executing that ordering ([Asynchronous Execution](monad-arch/consensus/asynchronous-execution.mdx)); the outcome of execution is <em>not</em> a prerequisite to consensus.</p>\n                <p></p>\n                <p>In blockchains where execution <em>is</em> a prerequisite to consensus, the time budget for execution is a small fraction of the block time.  Pipelining consensus and execution allows Monad to expend the full block time on <em>both</em> consensus and execution.<br/></p>\n                <p>Block proposals consist of an ordered list of transaction hashes and a state merkle root from <code>D</code> blocks ago.  The delay parameter <code>D</code> is set in code; it is expected that <code>D = 3</code> initially.</p>\n                <p></p>\n                <p>To prevent spam, nodes validate that the account balance is sufficient to pay for `value + gas_price * gas_limit` for transactions submitted during the delay period of <code>D</code> blocks.</p>\n                <p></p>\n                <p>An account's available balance computed by consensus (as of <code>D</code> blocks ago) is effectively a budget for \"in-flight\" orders; it exists to ensure that the account can pay for all submitted transactions.</p>\n            </td>\n        </tr>\n        <tr>\n            <td>State determinism </td>\n            <td>Finality occurs at consensus time; the official ordering of transactions is enshrined at this point, and the outcome is fully deterministic for any full node, who will generally execute the transactions for that new block in under 1 second.<br/><br/>The <code>D</code>-block delay for state merkle roots is only for state root verification, for example for allowing a node to ensure that it didn't make a computation error.</td>\n        </tr>\n    </tbody>\n</table>"
  },
  {
    "instruction": "What is covered in the 'Execution' section of the Developer Essentials guide?",
    "output": "The execution phase for each block begins after consensus is reached on that block, allowing the node to proceed with consensus on subsequent blocks.\n\n### Parallel Execution\n\nTransactions are linearly ordered; the job of execution is to arrive at the state that results from executing that list of transactions serially. The naive approach is just to execute the transactions one after another. Can we do better? Yes we can!\n\nMonad implements [parallel execution](monad-arch/execution/parallel-execution.md):\n\n-   An executor is a virtual machine for executing transactions. Monad runs many executors in parallel.\n-   An executor takes a transaction and produces a **result**. A result is a list of **inputs** to and **outputs** of the transactions, where inputs are (ContractAddress, Slot, Value) tuples that were SLOADed in the course of execution, and outputs are (ContractAddress, Slot, Value) tuples that were SSTOREd as a result of the transaction.\n-   Results are initially produced in a pending state; they are then committed in the original order of the transactions. When a result is committed, its outputs update the current state. When it is a result\u2019s turn to be committed, Monad checks that its inputs still match the current state; if they don\u2019t, Monad reschedules the transaction. As a result of this concurrency control, Monad\u2019s execution is guaranteed to produce the same result as if transactions were run serially.\n-   When transactions are rescheduled, many or all of the required inputs are cached, so re-execution is generally relatively inexpensive. Note that upon re-execution, a transaction may produce a different set of Inputs than the previous execution did;\n\n### MonadDb: high-performance state backend\n\nAll active state is stored in [MonadDb](monad-arch/execution/monaddb.md), a storage backend for solid-state drives (SSDs) that is optimized for storing merkle trie data. Updates are batched so that the merkle root can be updated efficiently.\n\nMonadDb implements in-memory caching and uses [asio](https://think-async.com/Asio/) for efficient asynchronous reads and writes. Nodes should have 32 GB of RAM for optimal performance."
  },
  {
    "instruction": "What is covered in the 'Comparison to Ethereum: User's Perspective' section of the Developer Essentials guide?",
    "output": "<table>\n    <thead>\n        <tr>\n            <th width=\"218\">Attribute</th>\n            <th width=\"264.3333333333333\">Ethereum</th>\n            <th width=\"255\">Monad</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><strong>Transactions/second</strong> (smart contract calls and transfers)</td>\n            <td>~10</td>\n            <td>~10,000</td>\n        </tr>\n        <tr>\n            <td><strong>Block Frequency</strong></td>\n            <td>12s</td>\n            <td>500 ms</td>\n        </tr>\n        <tr>\n            <td><strong>Finality</strong></td>\n            <td>[2 epochs](https://hackmd.io/@prysmaticlabs/finality) (12-18 min)</td>\n            <td>1s</td>\n        </tr>\n        <tr>\n            <td><strong>Bytecode standard</strong></td>\n            <td>EVM ([Cancun fork](https://www.evm.codes/?fork=cancun))</td>\n            <td>EVM ([Cancun fork](https://www.evm.codes/?fork=cancun))</td>\n        </tr>\n        <tr>\n            <td><strong>Max contract size</strong></td>\n            <td>24 kb</td>\n            <td>128 kb</td>\n        </tr>\n        <tr>\n            <td><strong>RPC API</strong></td>\n            <td>[Ethereum RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/)</td>\n            <td>[Monad RPC API](/reference/json-rpc) (generally identical to Ethereum RPC API, see [differences](reference/rpc-differences.md))</td>\n        </tr>\n        <tr>\n            <td><strong>Cryptography</strong></td>\n            <td>ECDSA</td>\n            <td>ECDSA</td>\n        </tr>\n        <tr>\n            <td><strong>Accounts</strong></td>\n            <td>Last 20 bytes of keccak-256 of public key under ECDSA</td>\n            <td>Last 20 bytes of keccak-256 of public key under ECDSA</td>\n        </tr>\n        <tr>\n            <td><strong>Consensus mechanism</strong></td>\n            <td>Gasper <br/>(Casper-FFG finality gadget + <br/>LMD-GHOST fork-choice rule)</td>\n            <td>[MonadBFT](monad-arch/consensus/monad-bft.mdx) (pipelined HotStuff with additional research improvements)</td>\n        </tr>\n        <tr>\n            <td><strong>Mempool</strong></td>\n            <td>Yes</td>\n            <td>Yes</td>\n        </tr>\n        <tr>\n            <td><strong>Transaction ordering</strong></td>\n            <td>Leader's discretion (in practice, PBS)</td>\n            <td>Leader's discretion (default behavior: priority gas auction)</td>\n        </tr>\n        <tr>\n            <td><strong>Sybil-resistance mechanism</strong></td>\n            <td>PoS</td>\n            <td>PoS</td>\n        </tr>\n        <tr>\n            <td><strong>Delegation allowed</strong></td>\n            <td>No; pseudo-delegation through LSTs</td>\n            <td>Yes</td>\n        </tr>\n        <tr>\n            <td><strong>Hardware Requirements</strong> (full node)</td>\n            <td>4-core CPU<br/>16 GB RAM<br/>1 TB SSD<br/>25 Mbit/s bandwidth</td>\n            <td>16-core CPU<br/>32 GB RAM<br/>2 x 2 TB SSD (one dedicated for MonadDB)<br/>100 Mbit/s bandwidth</td>\n        </tr>\n    </tbody>\n</table>"
  },
  {
    "instruction": "What is covered in the 'Testnet' section of the Developer Essentials guide?",
    "output": "Monad's public testnet is live. Head to [Network Information](developer-essentials/network-information.md) to get started.\n\nMany leading Ethereum developer tools support Monad testnet. See the [Tooling and Infrastructure](tooling-and-infra/README.md) for a list of supported providers by category.\n\n---\n\n\n# Monad for Users\n\nMonad is a high-performance Ethereum-compatible L1, offering users the best of both worlds: **portability** and **performance**.\n\nFrom a portability perspective, Monad offers **full bytecode compatibility** for the Ethereum Virtual Machine (EVM), so that applications built for Ethereum can be ported to Monad without code changes, and **full Ethereum RPC compatibility**, so that infrastructure like Etherscan or The Graph can be used seamlessly.\n\nFrom a performance perspective, Monad offers **10,000 tps** of throughput, i.e. 1 billion transactions per day, while offering **500ms block frequency** and **1 second finality**. This allows Monad to support many more users and far more interactive experiences than existing blockchains, while offering far cheaper per-transaction costs."
  },
  {
    "instruction": "What is covered in the 'What's familiar about Monad?' section of the Developer Essentials guide?",
    "output": "From a user perspective, Monad behaves very similarly to Ethereum. You can use the same wallets (e.g. Phantom, MetaMask) or block explorers (e.g. Etherscan) to sign or view transactions. The same apps built for Ethereum can be ported to Monad without code changes, so it is expected that you'll be able to use many of your favorite apps from Ethereum on Monad. The address space in Monad is the same as in Ethereum, so you can reuse your existing keys.\n\nLike Ethereum, Monad features linear blocks, and linear ordering of transactions within a block.&#x20;\n\nLike Ethereum, Monad is a proof-of-stake network maintained by a decentralized set of validators. Anyone can run a node to independently verify transaction execution, and significant care has been taken to keep hardware requirements minimal."
  },
  {
    "instruction": "What is covered in the 'What's different about Monad?' section of the Developer Essentials guide?",
    "output": "Monad makes exceptional performance possible by introducing **parallel execution** and **superscalar pipelining** to the Ethereum Virtual Machine.\n\n**Parallel execution** is the practice of utilizing multiple cores and threads to strategically execute work in parallel while still committing the results in the original order. Although transactions are executed in parallel \"under the hood\", from the user and developer perspective they are executed serially; the result of a series of transactions is always the same as if the transactions had been executed one after another.\n\n**Superscalar pipelining** is the practice of creating stages of work and executing the stages in parallel. A simple diagram tells the story:\n\n<figure>\n    <img src=\"/img/pipelining.png\" alt=\"Pipelining, Laundry Day\" class=\"center\"> </img>\n    <figcaption id=\"center\">Pipelining laundry day. Top: Naive; Bottom: Pipelined. Credit: [Prof. Lois Hawkes, FSU](https://www.cs.fsu.edu/~hawkes/cda3101lects/chap6/index.html?$$$F6.1.html$$$)</figcaption>\n</figure>\n\nWhen doing four loads of laundry, the naive strategy is to wash, dry, fold, and store the first load of laundry before starting on the second one. The pipelined strategy is to start washing load 2 when load 1 goes into the dryer. Pipelining gets work done more efficiently by utilizing multiple resources simultaneously.\n\n**Monad** introduces pipelining to address existing bottlenecks in state storage, transaction processing, and distributed consensus. In particular, Monad introduces pipelining and other optimizations in four major areas:\n\n-   [MonadBFT](/monad-arch/consensus/monad-bft.mdx) (pipelined HotStuff consensus with additional research improvements)\n-   [Asynchronous Execution](/monad-arch/consensus/asynchronous-execution.mdx) (pipelining between consensus and execution to significantly increase the execution budget)\n-   [Parallel Execution](/monad-arch/execution/parallel-execution.md)\n-   [MonadDb](/monad-arch/execution/monaddb.md) (high-performance state backend)\n\nMonad's client, which was written from scratch in C++ and Rust, reflect these architectural improvements and result in a platform for decentralized apps that can truly scale to world adoption."
  },
  {
    "instruction": "What is covered in the 'Why should I care?' section of the Developer Essentials guide?",
    "output": "Decentralized apps are replacements for centralized services with several significant advantages:\n\n-   **Open APIs / composability**: decentralized apps can be called atomically by other decentralized apps, allowing developers to build more complex functionality by stacking existing components.\n-   **Transparency**: app logic is expressed purely through code, so anyone can review the logic for side effects. State is transparent and auditable; proof of reserves in DeFi is the default.\n-   **Censorship-resistance and credible neutrality:** anyone can submit transactions or upload applications to a permissionless network.\n-   **Global reach**: anyone with access to the internet can access crucial financial services, including unbanked/underbanked users.\n\nHowever, decentralized apps need cheap, performant infrastructure to reach their intended level of impact. A single app with 1 million daily active users (DAUs) and 10 transactions per user per day would require 10 million transactions per day, or 100 tps. A quick glance at [L2Beat](https://l2beat.com/scaling/activity) - a useful website summarizing the throughput and decentralization of existing EVM-compatible L1s and L2s - shows that no EVM blockchain supports even close to that level of throughput right now.\n\nMonad materially improves on the performance of an EVM-compatible blockchain network, pioneering several innovations that will hopefully become standard in Ethereum in the years to come.\n\nWith Monad, developers, users, and researchers can reuse the wealth of existing applications, libraries, and applied cryptography research that have all been built for the EVM."
  },
  {
    "instruction": "What is covered in the 'Testnet' section of the Developer Essentials guide?",
    "output": "Monad's public testnet is live. Head to [Network Information](developer-essentials/network-information.md) to get started.\n\n---\n\n\n# Why Blockchain?\n\nA blockchain is decentralized agreement among a diverse set of participants about two things:\n\n1. An official **ordering** (ledger) of transactions\n2. An official **state of the world**, including balances of accounts and the state of various programs.\n\nIn modern blockchains such as Ethereum, transactions consist of balance transfers, creation of new programs, and function calls against existing programs. The aggregate result of all transactions up to now produces the current state, which is why _agreement about (1) above implies agreement about (2)._\n\nA blockchain system has a set of protocol rules, also known as a consensus mechanism, which describe how a distributed set of nodes which are currently in sync will communicate with each other to agree upon additional transactions to add to the ledger. ([MonadBFT](/monad-arch/consensus/monad-bft.mdx) is an example of a consensus mechanism.)\n\nInduction keeps the nodes in sync: they start with the same state and apply the same transactions, so at the end of applying a new list of transactions, they still have consistent state.\n\nShared global state enables the development of decentralized apps - apps that live \"on the blockchain\", i.e. on each of the nodes in the blockchain system. A decentralized app is a chunk of code (as well as persistent, app-specific state) that can get invoked by any user, who does so by submitting a transaction pointing to a function on that app. Each of the nodes in the blockchain is responsible for correctly executing the bytecode being called; duplication keeps each node honest."
  },
  {
    "instruction": "What is covered in the 'An example app' section of the Developer Essentials guide?",
    "output": "Decentralized apps can implement functionality that we might otherwise expect to be implemented in a centralized fashion. For example, a very simple example of a decentralized app is a _Virtual Bank_ (typically referred to in crypto as a Lending Protocol).\n\nIn the physical world, a bank is a business that takes deposits and loans them out at a higher rate. The bank makes the spread between the high rate and the low rate; the borrower gets a loan to do something economically productive; and you earn interest on your deposits. Everyone wins!\n\nA Virtual Bank is simply an app with four major methods: `deposit`, `withdraw`, `borrow`, and `repay`. The logic for each of those methods is mostly bookkeeping to ensure that deposits and loans are being tracked correctly:\n\n```\nclass VirtualBank:\n  def deposit(sender, amount):\n    # transfer amount from sender to myself (the bank)\n    # do internal bookkeeping to credit the sender\n\n  def withdraw(sender, amount):\n    # ensure the sender had enough on deposit\n    # do internal bookkeeping to debit the sender\n    # transfer amount from myself (the bank) to sender\n\n  def borrow(sender, amount):\n    # ...\n\n  def repay(sender, amount);\n    # ...\n```\n\nIn Ethereum, or in Monad, someone can write code for this Virtual Bank and upload it; then anyone can utilize it for borrowing and lending, potentially far more easily than when trying to get access to banking services in their home country.\n\nThis simple example shows the power of decentralized apps. Here are a few other benefits to call out:\n\n-   **Open APIs / composability**: decentralized apps can be called atomically by other decentralized apps, allowing developers to build more complex functionality by stacking existing components.\n-   **Transparency**: app logic is expressed purely through code, so anyone can review the logic for side effects. State is transparent and auditable; proof of reserves in DeFi is the default.\n-   **Censorship-resistance and credible neutrality:** anyone can submit transactions or upload applications to a permissionless network.\n-   **Global reach**: anyone with access to the internet can access crucial financial services, including unbanked/underbanked users.\n\n---\n\n# Why Monad: Decentralization + Performance"
  },
  {
    "instruction": "What is covered in the 'Decentralization matters' section of the Developer Essentials guide?",
    "output": "A blockchain has several major components:\n\n-   Consensus mechanism for achieving agreement on transactions to append to the ledger\n-   Execution/storage system for maintaining the active state\n\nIn increasing the performance of these components, one could cut corners, for example by requiring all of the nodes to be physically close to each other (to save on the overhead of consensus), or by requiring a huge amount of RAM (to keep much or all of the state in memory), but it would be at a significant cost to decentralization.\n\nAnd decentralization is the whole point!\n\nAs discussed in [Why Blockchain?](/introduction/why-blockchain.md), decentralized shared global state allows many parties to coordinate while relying on a single, shared, objective source of truth. Decentralization is key to the matter; a blockchain maintained by a small group of node operators (or in the extreme case, a single operator!) would not offer benefits such as trustlessness, credible neutrality, and censorship-resistance.\n\nFor any blockchain network, decentralization should be the principal concern. Performance improvements should not come at the expense of decentralization."
  },
  {
    "instruction": "What is covered in the 'Today's performance bottlenecks' section of the Developer Essentials guide?",
    "output": "Ethereum's current execution limits (1.25M gas per second) are set conservatively, but for several good reasons:\n\n-   Inefficient storage access patterns\n-   Single-threaded execution\n-   Very limited execution budget, because consensus can't proceed without execution\n-   Concerns about state growth, and the effect of state growth on future state access costs\n\nMonad addresses these limitations through algorithmic improvements and architectural changes, pioneering several innovations that will hopefully become standard in Ethereum in the years to come. Maintaining a high degree of decentralization, while making material performance improvements, is the key consideration."
  },
  {
    "instruction": "What is covered in the 'Addressing these bottlenecks through optimization' section of the Developer Essentials guide?",
    "output": "Monad enables pipelining and other optimizations in four major areas to enable exceptional Ethereum Virtual Machine performance and materially advance the decentralization/scalability tradeoff. Subsequent pages describe these major areas of improvement:\n\n-   [MonadBFT](/monad-arch/consensus/monad-bft.mdx)\n-   [Asynchronous Execution](/monad-arch/consensus/asynchronous-execution.mdx)\n-   [Parallel Execution](/monad-arch/execution/parallel-execution.md)\n-   [MonadDb](/monad-arch/execution/monaddb.md)\n\n---\n\n# Monad Architecture\n\n<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/monad-arch/concepts\"\n        title=\"Concepts\"\n        description=\"Explaining high level themes (async io and pipelining) that recur in Monad\"\n    />\n    <CustomDocCard\n        icon={<Consensus />}\n        link=\"/monad-arch/consensus\"\n        title=\"Consensus\"\n        description=\"Algorithms for maintaining a globally distributed, decentralized validator set\"\n    />\n    <CustomDocCard\n        icon={<Execution />}\n        link=\"/monad-arch/execution\"\n        title=\"Execution\"\n        description=\"Algorithms for executing EVM transactions efficiently\"\n    />\n    <CustomDocCard\n        icon={<TransactionLifecycle />}\n        link=\"/monad-arch/transaction-lifecycle\"\n        title=\"Transaction Lifecycle\"\n        description=\"Mapping the path of a transaction in Monad\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/monad-arch/hardware-requirements\"\n        title=\"Hardware Requirements\"\n        description=\"A core principle has been high performance on reasonable hardware\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/monad-arch/other-details\"\n        title=\"Other Details\"\n        description=\"\"\n    />\n</CustomDocCardContainer>\n\n\n---\n\n# Concepts\n\n---\n\n# Asynchronous I/O\n\n_Asynchronous I/O_ is a form of input/output processing that allows the CPU to continue executing concurrently while communication is in progress.\n\nDisk and network are orders of magnitude slower than the CPU.  Rather than initiating an I/O operation and waiting for the result, the CPU can initiate the I/O operation as soon as it's known that the data will be needed, and continue executing other instructions which do not depend on the result of the I/O operation.\n\nSome rough comparisons for illustration purposes:\n\n<table>\n    <thead>\n        <tr>\n            <th width=\"260\">Device</th>\n            <th width=\"191.33333333333331\">Latency</th>\n            <th>Bandwidth</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>CPU L3 Cache</td>\n            <td>10 ns</td>\n            <td>>400 GB/s</td>\n        </tr>\n        <tr>\n            <td>Memory</td>\n            <td>100 ns</td>\n            <td>100 GB/s</td>\n        </tr>\n        <tr>\n            <td>Disk (NVMe SSD)</td>\n            <td>400 us</td>\n            <td>380 MB/s</td>\n        </tr>\n        <tr>\n            <td>Network</td>\n            <td>50 - 200 ms</td>\n            <td>1 Gb/s (125 MB/s)</td>\n        </tr>\n    </tbody>\n</table>\n\n\n(actual disk stats as reported by fio for random reads of size 2KB - \\~190k IOPS)\n\nFortunately, SSD drives can perform operations concurrently, so the CPU can initiate several requests at the same time, continue executing, and then receive the results of multiple operations around the same time.\n\nSome databases (such as lmdb / mdbx) use memory-mapped storage to read and write to disk. Unfortunately, memory-mapped storage is implemented by the kernel (mmap) and is not asynchronous, so execution is blocked while waiting for the operation to complete.\n\nMore about asynchronous I/O can be read [here](https://en.wikipedia.org/wiki/Asynchronous\\_I/O).\n---\n\n# Pipelining\n\n_Pipelining_ is a technique for implementing parallelism by dividing tasks into a series of smaller tasks which can be processed in parallel.\n\nPipelining is used in computer processors to increase the throughput of executing a series of instructions sequentially at the same clock rate. (There are other techniques used in processors to increase throughput as well.)  More about instruction-level parallelism (ILP) can be read [here](https://en.wikipedia.org/wiki/Instruction\\_pipelining).\n\nA simple example of pipelining:\n\n<figure>\n    <img src=\"/img/pipelining.png\" alt=\"Pipelining, Laundry Day\" class=\"center\"> </img>\n    <figcaption id=\"center\">Pipelining laundry day. Top: Naive; Bottom: Pipelined. Credit: [Prof. Lois Hawkes, FSU](https://www.cs.fsu.edu/~hawkes/cda3101lects/chap6/index.html?$$$F6.1.html$$$)</figcaption>\n</figure>\n\nWhen doing four loads of laundry, the naive strategy is to wash, dry, fold, and store the first load of laundry before starting on the second one.  The pipelined strategy is to start washing load 2 when load 1 goes into the dryer.  Pipelining gets work done more efficiently by utilizing multiple resources simultaneously.\n---\n\n# Consensus\n\n<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/monad-arch/consensus/monad-bft\"\n        title=\"MonadBFT\"\n        description=\"High-performance consensus: pipelined 2-phase HotStuff\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/monad-arch/consensus/local-mempool\"\n        title=\"Local Mempool\"\n        description=\"Policies for sharing pending transactions to leaders while minimizing bandwidth\"\n    />\n    <CustomDocCard\n        icon={<AsyncronousExecution />}\n        link=\"/monad-arch/consensus/asynchronous-execution\"\n        title=\"Asynchronous Execution\"\n        description=\"Moving execution out of the hot path of consensus so it can use the full block time\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/monad-arch/consensus/raptorcast\"\n        title=\"RaptorCast\"\n        description=\"Efficient block propagation of large blocks that retains BFT\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/monad-arch/consensus/statesync\"\n        title=\"Statesync\"\n        description=\"Algorithms for bootstrapping a node from peers\"\n    />\n    <CustomDocCard\n        icon={<Monad />}\n        link=\"/monad-arch/consensus/blocksync\"\n        title=\"Blocksync\"\n        description=\"Algorithms for catching up on missed traffic\"\n    />\n</CustomDocCardContainer>\n\n\n---\n\n\n bottom: asynchronous.*\n</center>"
  },
  {
    "instruction": "What is covered in the 'Determined ordering implies state determinism' section of the Developer Essentials guide?",
    "output": "Although execution lags consensus, the true state of the world is determined as soon as the ordering is determined. Execution is required to unveil the truth, but the truth is already determined.\n\nIt's worth noting that in Monad, like in Ethereum, it is fine for transactions in a block to \"fail\" in the sense that the intuitive outcome did not succeed.(For example, there could be a transaction included in a block in which Bob tries to send 10 tokens to Alice but only has 1 token in his account. The transfer 'fails' but the transaction is still valid.\n\nThe outcome of any transaction, including failure, is deterministic.\n\n\n\n<center>\n<img src={TransactionOrdering} style={{width: 800}}/>\n*Example of transaction determinism even when some transactions fail*\n</center>"
  },
  {
    "instruction": "What is covered in the 'Finer details' section of the Developer Essentials guide?",
    "output": "### Delayed Merkle Root\n\nAs mentioned above, Monad block proposals don't include the merkle root of the state trie, since that would require execution to have already completed.\n\nAll nodes should stay in sync because they're all doing the same work. But it'd be nice to be sure! As a precaution, proposals also includes a merkle root from `D` blocks ago, allowing nodes to detect if they're diverging. `D` is a systemwide parameter (currently set in the testnet to `3`).\n\nDelayed merkle root validity is part of block validity, so if the leader proposes a block but the delayed merkle root is wrong, the block will be rejected.\n\nAs a result of this delayed merkle root:\n\n1. After the network comes to consensus (2/3 majority vote) on block `N` (typically upon receiving block `N+2`, which contains a QC-on-QC for block `N`), it means that the network has agreed that the official consequence of block `N-D` is a state rooted in merkle root `M`. Light clients can then query full nodes for merkle proofs of state variable values at block `N-D`.\n2. Any node with an error in execution at block `N-D` will fall out of consensus starting at block `N`. This will trigger a rollback on that node to the end state of block `N-D-1`, followed by re-execution of the transactions in block `N-D` (hopefully resulting in the merkle root matching), followed by re-execution of the transactions in block `N-D+1`, `N-D+2`, etc.\n\nEthereum's approach uses consensus to enforce _state machine replication_ in a very strict way: after nodes come to consensus, we know that the supermajority agrees about the official ordering and the state resulting from that ordering. However, this strictness comes at great cost because interleaved execution limits execution throughput. Asynchronous execution achieves state machine replication without this limitation, and the delayed merkle root serves an additional precaution.\n\n<center>\n<img src={DelayedMerkleRoot} style={{width: 700}}/>\n*Delayed merkle root*\n</center>\n\n### Balance validation at time of consensus\n\nLeaders build blocks with a delayed view of the state.\n\nTo defend against a Denial-of-Service attack where someone submitting a bunch of transactions from an account with a zero balance, Monad nodes validate that the balance of the account is sufficient to fullfill the maximum debit in the user's account associated with in-flight transactions.\n\nFor each transaction, the max expenditure is:\n\n```\nmax_expenditure = value + gas_limit * max_fee_per_gas\n```\n\nAvailable balance is tracked at consensus time and is decremented as transactions are included in blocks. If the available balance is insufficient to pay for `max_expenditure`, the transaction is not included in a block.\n\nYou can think of the available balance tracked by consensus as decrementing in realtime as transactions are included in blocks. Although the node's view of the full state is lagged, the available balance always reflects up-to-date expenditures.\n\n\n### Speculative execution\n\nIn MonadBFT, nodes receive a proposed block `N` at slot `N`, but it is not finalized until slot `N+2`. During the intervening time, a node can still locally execute the proposed block (without the guarantee that it will become voted or finalized). This allows a few nice properties:\n1. In the likely event that the proposed block is finalized, the validator node has already done the work and can immediately update its merkle root pointer to the result.\n2. Transactions can be simulated (in `eth_call` or `eth_estimateGas`) against the speculative state which is likely more up-to-date.\n\n\n### Transactions from newly-funded accounts\n\nBecause consensus runs slightly ahead of execution, newly-funded accounts which previously had zero balance cannot send transactions until the transfer that credits them with tokens has proceeded to the [`Verified` state](#block-states).\n\nIn practice, this means that if you send tokens from account `A` into an account `B` (which has 0 balance), then you should wait until seeing the transaction receipt (indicative that that block has reached `Finalized` stage), and then wait another 1.5 seconds.\n\nAlternatively, depending on the nature of intended transaction from `B`, it may be possible to write a smart contract callable by `A` which combines the funding operation and whatever `B` was intending to do, requiring no delay between funding and spending."
  },
  {
    "instruction": "What is covered in the 'Block states' section of the Developer Essentials guide?",
    "output": "To summarize, Monad blocks can be in one of the following states:\n\n1. **Proposed** - The block has been proposed by a leader but has not been voted upon. If execution is not lagging behind consensus, a node may speculatively execute the proposed block.\n2. **Voted** - After a supermajority of validator nodes have voted affirmatively for a proposed block, it is considered **voted**. It has a Quorum Certificate (QC).\n3. **Finalized** - A block becomes **finalized** when a supermajority of validator nodes successfully vote on the **next** block. At this point, there is no chance of a reversion.\n4. **Verified** - A **verified** block has execution outputs and a state root produced by a supermajority of validator nodes. Concretely, the latest verified block will be the latest_finalized_block - execution_delay.\n\n<center>\n<img src={BlockStates} style={{width: 400}}/>\n*Classification of historical blocks based on the latest **proposed** block N.*\n</center>\n\n---\n\n\n# Blocksync"
  },
  {
    "instruction": "What is covered in the 'Summary' section of the Developer Essentials guide?",
    "output": "Blocksync is a mechanism that nodes can use to acquire missing blocks. A block is considered missing when a Quorum Certificate is observed that references an unknown block.\n\nBlocks can be missing from a node in one of two scenarios:\n\n1. After the node completes statesync and its local block height is close enough to the network tip.\n2. During ordinary consensus operations, the node does not receive enough RaptorCast chunks to decode the block. This can be due to packet loss or a network partition."
  },
  {
    "instruction": "What is covered in the 'Blocksync procedure' section of the Developer Essentials guide?",
    "output": "1. A single header request is made for a range of `num_blocks` blocks, starting with `last_block_id`.\n2. A chain of `num_blocks` headers are received, forming a cryptographically verifiable chain back to `last_block_`.\n3. For each of the `num_blocks` headers received, concurrent (up to a max concurrency factor) body requests are made containing the `body_id` included in the header.\n4. Each body response is cryptographically verifiable by comparing against the corresponding header `body_id`.\n\n![Blocksync procedure](/img/monad-arch/consensus/blocksync/blocksync_procedure.svg)\n\n---\n\n\n# Local Mempool"
  },
  {
    "instruction": "What is covered in the 'Summary' section of the Developer Essentials guide?",
    "output": "Most blockchains use a global mempool with peer-to-peer gossipping for transaction propagation. This approach is not suitable for high-performance distributed consensus for a few reasons:\n1. It is slow because it may involve many hops for a transaction to reach a leader, increasing time to inclusion.\n2. It is wasteful on bandwidth because the gossip protocol involves many retransmissions.\n3. It ignores the leader schedule which is typically known well in advance.\n\nIn Monad, there is no global mempool; instead, each validator maintains a local mempool, and RPC nodes forward transactions to the next few leaders for inclusion in their local mempool. This is much more efficient on bandwidth usage and allows transactions to be included more quickly."
  },
  {
    "instruction": "What is covered in the 'Background' section of the Developer Essentials guide?",
    "output": "A mempool is a collection of pending transactions. Many blockchain networks use a global mempool design, using peer-to-peer gossip protocols to keep roughly the same mempool state across all nodes in the network. A primary motivation of a global mempool design is that no matter who is leader, they will have access to the same set of pending transactions to include in the next block.\n\nA global mempool is effective for low-throughput networks, where network bandwidth is typically not a bottleneck. However, at thousands of transactions per second, the gossip protocols (and especially the required retransmission at each node) can easily consume the entire network bandwidth budget. Moreover, a global mempool is wasteful since the leader schedule is typically known well in advance."
  },
  {
    "instruction": "What is covered in the 'Transaction Lifecycle in Monad' section of the Developer Essentials guide?",
    "output": "There is no global mempool in Monad. Validators maintain local mempools; RPC nodes forward transactions to upcoming leaders to ensure that those transactions are available for inclusion.\n\nMore precisely, transaction flow is as follows:\n1. A transaction is submitted to the RPC process of a node (typically a full non-validator node). We'll call this node the **\"owner node\"** of the transaction, since it assumes responsibility for communicating the status with the user.\n2. The RPC process performs some static checks on the transaction.\n3. The RPC process passes the transaction to the consensus process.\n4. The consensus process performs static checks and dynamic checks against local state in MonadDb, such as checking the sender's account balance and nonce.\n5. If the transaction is valid, the consensus process forwards the transaction to `N` upcoming leader validator nodes. Currently, `N` is set to 3 in Monad Testnet.\n6. Each of those `N` validators performs the same checks before inserting valid transactions into their local mempools.\n7. When it is a leader's turn to create a proposal, it selects transactions from its local mempool.\n8. The owner node of the transaction monitors for that transaction in subsequent blocks. If it doesn't see the transaction in the next `N` blocks, it will re-send to the next `N` leaders. It repeats this behavior for a total of `K` times. Currently `K` is set to 3 in Monad Testnet.\n\n The behavior of this transaction flow is chosen to reduce time-to-inclusion while minimizing the number of messages.\n\n\n<figure>\n    <img src=\"/img/monad-arch/consensus/local-mempool/tx_path.png\" alt=\"Transaction path to leader\" class=\"center\"> </img>\n    <figcaption id=\"center\">Transaction path from RPC to leader (through the local mempool).</figcaption>\n</figure>"
  },
  {
    "instruction": "What is covered in the 'Local mempool eviction' section of the Developer Essentials guide?",
    "output": "Transactions are evicted from a validator's local mempool for the following reasons:\n1. Whenever a validator finalizes a block, any replicas of transactions in that block are pruned from the local mempool.\n2. Validators periodically check the validity of each transaction in the mempool and evict invalid transactions (e.g. nonces are too low, account balances are insufficient).\n3. If the local mempool's size reaches a soft limit, older transactions will be evicted.\n\n---\n\n\n validators directly message to the next leader.*\n</center>\n\nMonadBFT is a pipelined consensus mechanism that proceeds in rounds. The below description gives a high-level intuitive understanding of the protocol.\n\nAs is customary, let there be `n = 3f+1` nodes, where `f` is the max number of Byzantine nodes, i.e. `2f+1` (i.e. 2/3) of the nodes are non-Byzantine. In the discussion below, let us also treat all nodes as having equal stake weight; in practice all thresholds can be expressed in terms of stake weight rather than in node count.\n\n-   In each round, the leader sends out a new block as well as either a QC or a TC (more on this shortly) for the previous round.\n-   Each validator reviews that block for adherence to protocol and, if they agree, send signed YES votes to the leader of the next round. That leader derives a QC (quorum certificate) by aggregating (via threshold signatures) YES votes from `2f+1` validators. Note that communication in this case is _linear_: leader sends block to validators, validators send votes directly to next leader.\n    -   Alternatively, if the validator does not receive a valid block within a pre-specified amount of time, it multicasts a signed timeout message to _all_ of its peers. This timeout message also includes the highest QC that the validator has observed. If any validator accumulates `2f+1` timeout messages, it assembles these (again via threshold signatures) into a TC (timeout certificate) which it then sends directly to the next leader.\n-   Each validator finalizes the block proposed in round `k` upon receiving a QC for round `k+1` (i.e. in the communication from the leader of round `k+2`). Specifically:\n    -   Alice, the leader of round `k`, sends a new block to everyone[^1].\n    -   If `2f+1` validators vote YES on that block by sending their votes to Bob (leader of round `k+1`), then the block in `k+1` will include a QC for round `k`. However, seeing the QC for round `k` _at this point_ is not enough for Valerie the validator to know that the block in round `k` has been enshrined, because (for example) Bob could have been malicious and only sent the block to Valerie. All that Valerie can do is vote on block `k+1`, sending her votes to Charlie (leader of round `k+2`).\n    -   If `2f+1` validators vote YES on block `k+1`, then Charlie publishes a QC for round `k+1` as well as a block proposal for round `k+2`. As soon as Valerie receives this block, she knows that the block from round `k` (Alice's block) is finalized.\n    -   Say that Bob had acted maliciously, either by sending an invalid block proposal at round `k+1`, or by sending it to fewer than `2f+1` validators. Then at least `f+1` validators will timeout, triggering the other non-Byzantine validators to timeout, leading to at least one of the validators to produce a TC for round `k+1`. Then Charlie will publish the TC for round `k+1` in his proposal - no QC will be available for inclusion.\n    -   We refer to this commitment procedure as a 2-chain commit rule, because as soon as a validator sees 2 adjacent certified blocks `B` and `B'`, they can commit `B` and all of its ancestors.\n\n[^1]: The block is also sent with a QC or TC for round `k-1`, but this is irrelevant for this example.\n\n<center>\n<img src={MonadBFTPipelining} style={{width: 800}}/>\n*Block proposals in MonadBFT are pipelined. Same diagram as the previous, but zoomed out to include one more round.*\n</center>\n\nReferences:\n\n-   Maofan Yin, Dahlia Malkhi, Michael K. Reiter, Guy Golan Gueta, and Ittai Abraham. [HotStuff: BFT Consensus in the Lens of Blockchain](https://arxiv.org/abs/1803.05069), 2018.\n-   Mohammad M. Jalalzai, Jianyu Niu, Chen Feng, Fangyu Gai. [Fast-HotStuff: A Fast and Resilient HotStuff Protocol](https://arxiv.org/abs/2010.11454), 2020.\n-   Rati Gelashvili, Lefteris Kokoris-Kogias, Alberto Sonnino, Alexander Spiegelman, and Zhuolun Xiang. [Jolteon and ditto: Network-adaptive efficient consensus with asynchronous fallback](https://arxiv.org/pdf/2106.10362.pdf). arXiv preprint arXiv:2106.10362, 2021.\n-   The Diem Team. [DiemBFT v4: State machine replication in the diem blockchain](https://developers.diem.com/papers/diem-consensus-state-machine-replication-in-the-diem-blockchain/2021-08-17.pdf). 2021."
  },
  {
    "instruction": "What is covered in the 'BLS Multi-Signatures' section of the Developer Essentials guide?",
    "output": "Certificates (QCs and TCs) can be naively implemented as a vector of ECDSA signatures on the secp256k1 curve. These certificates are explicit and easy to construct and verify. However, the size of the certificate is linear with the number of signers. It poses a limit to scaling because the certificate is included in almost every consensus message, except vote message.\n\nPairing-based BLS signature on the BLS12-381 curve helps with solving the scaling issue. The signatures can be incrementally aggregated into one signature. Verifying the single valid aggregated signature provides proof that the stakes associated with the public keys have all signed on the message.\n\nBLS signature is much slower than ECDSA signature. So for performance reasons, MonadBFT adopts a blended signature scheme where BLS signature is only used on aggregatable message types (votes and timeouts). Message integrity and authenticity is still provided by ECDSA signatures.\n\n---\n\n\n# RaptorCast"
  },
  {
    "instruction": "What is covered in the 'Summary' section of the Developer Essentials guide?",
    "output": "RaptorCast is a specialized multicast message delivery protocol used in MonadBFT to send block proposals from leaders to validators. Block proposals are converted into erasure-coded chunks using the Raptor code in [RFC 5053](https://datatracker.ietf.org/doc/html/rfc5053). Each chunk is sent to all validators through a two-level broadcast tree, where the first level is a single non-leader node. Each non-leader node is responsible for serving as the first-level node for a different set of chunks; the proportion of chunk assignments is equal to the validator's stake weight.\n\nRaptorCast thus utilizes the full upload bandwidth of the entire network to propagate block proposals to all validators, while preserving Byzantine fault tolerance."
  },
  {
    "instruction": "What is covered in the 'Introduction' section of the Developer Essentials guide?",
    "output": ":::info\nThe technical description of RaptorCast below relates to block propagation amongst **validator** nodes participating in consensus. In particular, [block propagation to full nodes](#full-node-dissemination) is handled differently.\n:::\n\nIn MonadBFT, leaders need to send block proposals to every validator. Getting block proposals from a leader to the rest of the network is one of the challenging problems in high-performance distributed consensus because block proposals are large and the network is not reliable.\n\nConsider the following two naive approaches to addressing this problem:\n1. Sending messages directly from the leader to each validator. This is the simplest approach, but it would impose very high upload bandwidth requirements for a leader because block proposals are large - for example, 10,000 transactions at 200 bytes per transaction is 2MB.\n\n2. Sending messages from the leader to a few peers, who each re-broadcast to a few peers. This approach would reduce the upload bandwidth requirements for the leader, but it would increase maximum latency to all of the nodes, and it risks message loss if some of the peers are Byzantine and fail to forward the message.\n\nRaptorCast is the multicast message delivery protocol that solves this problem, offering the best tradeoff between bandwidth requirements, latency, and fault-tolerance. RaptorCast was developed specifically for MonadBFT, and satisfies the following requirements.\n\nIn the below discussion, the \"message\" is the block proposal, and the \"message originator\" is the leader."
  },
  {
    "instruction": "What is covered in the 'Design requirements' section of the Developer Essentials guide?",
    "output": "- Reliable message delivery to all participating consensus nodes is guaranteed if a `2/3` supermajority of the stake weight is non-faulty (honest and online).\n\n- Upload bandwidth requirements for a validator are linearly proportional to message size and are independent of the total number of participating validators.[^1]\n\n[^1]: This holds when participating validators are (approximately) equally staked. In situations with (very) unevenly distributed stake weights, we need to deviate from the equal-upload property in order to maintain reliable message delivery for every possible scenario where two-thirds of the stake weight corresponds to non-faulty nodes. \n\n- The worst-case message propagation time is twice the worst-case one-way latency between any two nodes. In other words, the propagation of a message to all intended recipients happens within the round-trip time (RTT) between the two most distant nodes in the network.\n\n- Messages are transmitted with a configurable amount of redundancy (chosen by the node operator). Increased redundancy mitigates packet loss and reduces message latency (recipient can decode sooner and more quickly)."
  },
  {
    "instruction": "What is covered in the 'How RaptorCast works' section of the Developer Essentials guide?",
    "output": "### Erasure coding\n\nMessages are erasure-coded by the message originator. Erasure coding means that the message is encoded into a set of chunks, and the message can be decoded from any sufficiently-large subset of the chunks.\n\nThe specific code used by RaptorCast is a variant of the Raptor code documented in [RFC 5053](https://datatracker.ietf.org/doc/html/rfc5053), with some Monad-specific modifications to \n\n- improve the encoding efficiency of small messages\n- reduce the computational complexity of message encoding (at the cost of a slight increase in decoding complexity)\n\n### Message and chunk distribution model\n\nRaptorCast uses a two-level broadcast tree for each chunk. The message originator is the root of the tree, a single non-originator node lives at level 1, and every other node lives at level 2.\n\nEach chunk of the encoded message potentially corresponds to a different broadcast tree, but the current implementation uses the same broadcast tree for contiguous ranges of the encoded message chunk space.\n\nThe following diagram illustrates this chunk distribution model:\n\n<figure>\n    <img src=\"/img/monad-arch/consensus/raptorcast/raptorcast_generic.png\" alt=\"RaptorCast Broadcast Tree\" class=\"center\"> </img>\n    <figcaption id=\"center\">Generic view of the two-hop Raptorcast broadcast tree.</figcaption>\n</figure>\n\n\nUsing a two-level broadcast tree minimizes latency for message delivery. Each level of the tree has worst-case latency of the one-way latency between any two nodes in the network (the network\u2019s \u201clatency diameter\u201d), so the worst case delivery time under RaptorCast is the round-trip-time of the network.\n\n### Fault tolerance\n\n:::info\nRaptorCast runs directly over UDP, with a single message chunk per UDP packet.\n:::\n\nNote that the broadcast tree is unidirectional. Unlike TCP, RaptorCast does not include a recovery mechanism for downstream nodes in the tree to detect packet loss and request retransmission, since this would violate latency expectations. To compensate, RaptorCast transmits the message in a redundant fashion, with a redundancy factor chosen by the message originator based on the network\u2019s expected packet loss.\n\nFor example, under the following assumptions:\n\n- 20% network packet loss\n- maximum 33% of the network is faulty or malicious\n\nthen the message originator should expect in the worst case that (1 - 0.2) * (1 - 0.33) or ~53.6% of chunks reach the intended destination. To offset that worst case loss, the originator should send 1 / 0.536 - 1 or roughly 87% *additional* chunks. \n\nThe default [MTU](https://en.wikipedia.org/wiki/Maximum_transmission_unit) used is 1480 bytes. After subtracting RaptorCast header overhead for the default Merkle tree depth of 6, this leaves 1220 bytes per packet for an encoded Raptor payload.  A 2.000.000 byte block maps to 2e6 / 1220 = 1640 source chunks. Using the current redundancy factor of 3, 4920 encoded chunk will then be distributed to other validators by proportionate stake weight. \n\nIf there are 100 validators, those 4920 encoded chunks will be divided into 99 (the originator is excluded) distinct chunk ranges and the leader will initiate a broadcast tree for each validator corresponding to its unique chunk range (and payload). If the validators had equal stake, each would receive 4920 / 99 = 50 chunks in contiguous ranges.\n\n<figure>\n    <img src=\"/img/monad-arch/consensus/raptorcast/raptorcast_expansion.png\" alt=\"RaptorCast encoding and redundancy\" class=\"center\"> </img>\n    <figcaption id=\"center\">A 2 MB block is split into chunks, expanded and disseminated.</figcaption>\n</figure>\n\nNote that the two-stage distribution model allows participating consensus nodes to receive a copy of a message even if direct network connectivity with the message originator is intermittently or entirely faulty.\n\n<figure>\n    <img src=\"/img/monad-arch/consensus/raptorcast/raptorcast_monad.png\" alt=\"Block proposal\" class=\"center\"> </img>\n    <figcaption id=\"center\">RaptorCast used to send erasure-encoded chunks from a leader to each validator.</figcaption>\n</figure>\n\nThe message originator (leader) typically[^2] distributes generated chunks to the first-hop recipients according to stake weight. For example:\n\n* Validator 1 has stake 1\n* Validator 2 has stake 2\n* Validator 3 has stake 3\n* Validator 4 has stake 4\n\nWhen Validator 1 is the leader, they will send:\n* 2 / (2 + 3 + 4) of generated chunks to validator 2\n* 3 / (2 + 3 + 4) of generated chunks to validator 3\n* 4 / (2 + 3 + 4) of generated chunks to validator 4\n\nThe leader _currently_ sends chunks in contiguous ranges but development work is currently being done to enable dissemination at a more granular level. With the new algorithm, individual or much smaller sets of chunks would be sent randomly to first-hop validators without replacement, weighted by stake. This approach produces better utilization of the network as all validators can start processing chunks as they arrive and send for redistribution (start the second-hop).\n\n[^2]: The pure stake-weighted distribution scheme can break down when the number of required chunks is sufficiently small, e.g. 12 chunks distributed to 100 validators. This corner case is actively being addressed.\n\n### Chunk transport integrity\n\nThe originator signs every encoded chunk, so intermediate nodes (level one) in the broadcast tree can verify the integrity of an encoded chunk before forwarding it.\n\nFurthermore, the number of source chunks `K` is encoded in the message. For given `K`, the recipient currently accepts encoded chunks in the range of 0 to `7 * K - 1`. This gives the originator sufficient freedom to specify a high degree of redundancy (up to 7), while also limiting the potential for network spam by a rogue validator.\n\nTo amortize the cost of generating and verifying these signatures over many chunks, RaptorCast aggregates contiguous ranges of encoded message chunks in variable-depth Merkle trees, and produces a single signature for every Merkle tree root.\n\n### Other uses of RaptorCast\n\nRaptorCast is not only used for broadcasting a block (in chunks) from the leader. Transaction forwarding, e.g. from a full node to the next three validator hosts, is also performed via RaptorCast, benefiting from its properties of speed and robustness. In this context, only one hop is required - the receiver should not rebroadcast.\n\n### Full node dissemination\n\nCurrently, validator nodes configure a list of downstream full nodes. A given validator will send every valid chunk it originates or receives to every full node in this list. \n\n<figure>\n    <img src=\"/img/monad-arch/consensus/raptorcast/raptorcast_full_node.png\" alt=\"Dissemination to full nodes\" class=\"center\"> </img>\n    <figcaption id=\"center\">Each node in the broadcast tree disseminates all received (or produced) chunks to configured full nodes.</figcaption>\n</figure>\n\nDesign and implementation for full node peer discovery and more efficient and scalable dissemination is underway.\n---\n\n\n# Statesync"
  },
  {
    "instruction": "What is covered in the 'Summary' section of the Developer Essentials guide?",
    "output": "Statesync is the process for synchronizing state to a target block close to the current tip. A synchronizing node (\"client\") requests data from other up-to-date validators (\"servers\") to help it progress from its current view to its target view; the servers rely on metadata in MonadDb to efficiently respond to the request.\n\nSince the current tip is a moving target, following completion of statesync, the client makes another statesync request to get closer to the current tip, or replays queued blocks if within striking distance."
  },
  {
    "instruction": "What is covered in the 'Approach' section of the Developer Essentials guide?",
    "output": "Statesync is the process of synchronizing state stored in [MonadDb](/monad-arch/execution/monaddb) to a target block close to the current tip.\n\nThe current tip is a moving target, so as statesync is running, the syncing node stores new blocks beyond the target block and, upon completion of statesync, replays these additional blocks through normal execution to catch up to the current tip. The target block may be updated several times during this process.\n\nStatesync follows a client-server model, where the statesync requester is the client and the validator node servicing a statesync request is the server."
  },
  {
    "instruction": "What is covered in the 'Data included in statesync' section of the Developer Essentials guide?",
    "output": "MonadDb stores a variety of data relating to the execution of blocks. However, only a subset is required for full participation in the active set and thus included in statesync:\n\n- accounts, including balances, code, and storage\n- the last 256 block headers (to verify correctness)\n\nIn an effort to evenly distribute load, each of the aforementioned is spliced into chunks. The client assigns each chunk to a server who remains the peer for that chunk until synchronization is complete.\n\nServers are randomly selected from the list of available peers. The client maintains a certain number of sessions up to a configured maximum. In the event that servers are unresponsive, the client\u2019s statesync request will timeout and request from a different server."
  },
  {
    "instruction": "What is covered in the 'Versioning and verification' section of the Developer Essentials guide?",
    "output": "For efficiency, the client requests state from least- to most-recently updated, converging on the tip near the end of the process. Servers serve diffs relative to the client's latest block.\n\n\n![statesync_requests](/img/monad-arch/consensus/statesync/statesync_requests.png)\n\nIn the example above, the statesync client makes three consecutive requests to the statesync server assigned to prefix p. For each request, there are five parameters specified:\n\n- `prefix` - the prefix of the Merkle Patricia Trie\n- `i` - the start block number\n- `j` - the end block number\n- `target` - the target block number\n- `last_target` - last target block number, this is used to deduce deletions to send\n\nBecause there may be multiple rounds of statesync (as statesync occurs, the chain is progressing and the target block may need to adjust), `j` is buffered by some offset B from the target block to avoid retransmitting most recently used nodes in the MPT.  When `i` and `target` block are sufficiently close, as in the last round above, the statesync client will request `j = target`.\n\nAt this point, if `target` is less than 500 blocks from the tip of the chain, statesync is concluded and the state root will be validated and then the satisfied statesync client will begin [blocksync](./blocksync). If `target` is greater than 500 blocks from the tip of the chain, a new round of statesync will begin.\n\nDuring block execution, the server stores the version alongside node contents. As such, upon receipt of a statesync request, the server is able to quickly narrow down the relevant subtrie and submit read requests, which are embarrassingly parallel."
  },
  {
    "instruction": "What is covered in the 'Trust assumptions' section of the Developer Essentials guide?",
    "output": "Statesync clients trust that the requested data (including state root and parent hash) from statesync servers is correct. This is currently sampled randomly from the validator set according to stakeweight, but clients can optionally whitelist specific known providers as statesync servers.\n\nThe current implementation validates the data transmitted when the whole transfer is complete by comparing the state root. Because the work is split between multiple servers, a single server sending invalid data can cause a state root mismatch, without attribution to the faulty server. The only recourse in this situation is to retry the whole transfer, giving the faulty server an opportunity to fail the operation again.\n\nChanges are currently being implemented to verify the data transmitted on a per-server basis. In the event of a faulty server sending invalid data, the statesync client can discard and retry *only* the affected prefix. Further, it can identify the faulty server, log the error and potentially blacklist it from subsequent requests.\n\n---\n\n# Execution\n\n<CustomDocCardContainer>\n    <CustomDocCard\n        icon={<ParallelExecution />}\n        link=\"/monad-arch/execution/parallel-execution\"\n        title=\"Parallel Execution\"\n        description=\"Optimistic parallel execution\"\n    />\n    <CustomDocCard\n        icon={<MonadDb />}\n        link=\"/monad-arch/execution/monaddb\"\n        title=\"MonadDb\"\n        description=\"Custom database for storing the Ethereum Merkle Patricia Trie natively on SSD\"\n    />\n</CustomDocCardContainer>\n\n\n---\n\n\n# MonadDb"
  },
  {
    "instruction": "What is covered in the 'Summary' section of the Developer Essentials guide?",
    "output": "MonadDb is a critical component in Monad for maintaining full Ethereum compatibility while delivering high performance. It is a custom-built key-value database designed for storing authenticated blockchain data. MonadDb, specifically, is optimized for efficiently storing Merkle Patricia Trie nodes on disk."
  },
  {
    "instruction": "What is covered in the 'Merkle Patricia Trie Structured Database' section of the Developer Essentials guide?",
    "output": "Most Ethereum clients use generic key-value databases that are implemented as either B-Tree (e.g. [LMDB](https://www.symas.com/lmdb)) or LSM-Tree (e.g. [LevelDB,](https://github.com/google/leveldb) [RocksDB](https://rocksdb.org/)) data structures. However Ethereum uses the [Merkle Patricia Trie](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/) (MPT) data structure for storing state and other authenticated fields like receipts and transactions. This results in a suboptimal solution where one data structure is embedded into another data structure. MonadDb implements a [Patricia Trie](https://en.wikipedia.org/wiki/Radix_tree) (a specific variant of radix tree) data structure natively, both on-disk and in-memory. Despite the opinionated design, MonadDb is a flexible key-value store capable of storing any type of data. For instance, MonadDb is also used to store block headers and payloads for Monad."
  },
  {
    "instruction": "What is covered in the 'Asynchronous IO' section of the Developer Essentials guide?",
    "output": "Monad executes multiple transactions in [parallel](/monad-arch/execution/parallel-execution). In order to enable this, reads should not block continued operation, and this goal motivates [asynchronous I/O](/monad-arch/concepts/asynchronous-io) (async I/O) for the database. The above-mentioned key-value databases lack proper async I/O support (although there are some efforts to improve in this area). MonadDb fully utilizes the latest kernel support for async I/O (on Linux this is [io_uring](https://unixism.net/loti/index.html)). This avoids spawning a large number of kernel threads to handle pending I/O requests in an attempt to perform work asynchronously."
  },
  {
    "instruction": "What is covered in the 'Filesystem bypass' section of the Developer Essentials guide?",
    "output": "Modern filesystems provide a convenient abstraction for applications, but introduce overhead when building high-throughput I/O software. These often hidden costs include block allocation, fragmentation, read/write amplification, and metadata management. The abstraction of files and a set of system calls allows applications to interact with the file data as if it were stored contiguously. The complexity of managing exact physical disk locations is abstracted away from the applications (and their developers). However, the actual content on disk might be fragmented into multiple non-contiguous pieces.\u00a0 Accessing or writing to such a file usually involves more than one simple I/O operation.\n\nTo minimize overhead, MonadDb provides operators the option to bypass the filesystem. MonadDb implements its own indexing system based on the Patricia trie data structure, eliminating filesystem dependencies. Users have the flexibility to operate MonadDb on either regular files or block devices. For optimal performance, it is recommended to run MonadDb directly on block devices. This approach avoids all filesystem-related overhead, allowing MonadDb to fully unlock SSD performance."
  },
  {
    "instruction": "What is covered in the 'Concurrency Control' section of the Developer Essentials guide?",
    "output": "The Monad blockchain consists of multiple clients, each interacting with the database as either reader or writer. To support this functionality, MonadDb must efficiently synchronize between a single writer (execution) and multiple readers (consensus and RPC).\n\nMonadDb implements a persistent (or immutable) Patricia trie. When a branch in the trie is updated, new versions of the nodes on that branch are created, and the previous version of the trie is preserved. This approach facilitates versioning within the database and significantly simplifies synchronization between readers and the writer. It ensures that all reads are accurate and consistent while guaranteeing that writes are both complete and atomic from the perspective of the readers."
  },
  {
    "instruction": "What is covered in the 'Write Performance on Modern SSD' section of the Developer Essentials guide?",
    "output": "The usage of a persistent data structure also allows us to perform sequential writes, which offers better performance than random writes on modern SSDs. Modern SSD garbage collection occurs at the block level. On sequential writes, an entire block gets filled before the next one, which dramatically simplifies garbage collection. Garbage collection is much more expensive for random writes. Sequential writes also distribute data more efficiently, thereby reducing write amplification and increasing SSD longevity."
  },
  {
    "instruction": "What is covered in the 'Compaction' section of the Developer Essentials guide?",
    "output": "As historical versions accumulate, the amount of data written to disk will grow. Given the limited disk capacity it operates on, it is impossible to retain complete historical records. MonadDb stores recent versions of blockchain data and state and dynamically adjusts the history length based on available disk space. As newer versions are stored and older versions are pruned, the underlying storage space becomes fragmented. To address this, MonadDb performs compaction inline with updates, consolidating active data and releasing unused storage for recycling. This reduces fragmentation while maintaining performance and data integrity.\n---\n\n# Parallel Execution"
  },
  {
    "instruction": "What is covered in the 'Summary' section of the Developer Essentials guide?",
    "output": "Monad executes transactions in parallel.  While at first it might seem like this implies different execution semantics than exist in Ethereum, it actually does not.  Monad blocks are the same as Ethereum blocks - a linearly ordered set of transactions.  The result of executing the transactions in a block is identical between Monad and Ethereum."
  },
  {
    "instruction": "What is covered in the 'Optimistic Execution' section of the Developer Essentials guide?",
    "output": "At a base level, Monad uses optimistic execution. This means that Monad will start executing transactions before earlier transactions in the block have completed.  Sometimes (but not always) this results in incorrect execution.\n\nConsider two transactions (in this order in the block):\n\n1. Transaction 1 reads and updates the balance of account A (for example, it receives a transfer from account B).\n2. Transaction 2 also reads and updates the balance of account A (for example, it makes a transfer to account C).\n\nIf these transactions are run in parallel and transaction 2 starts running before transaction 1 has completed, then the balance it reads for account A may be different than if they were run sequentially.  This could result in incorrect execution.\n\nThe way optimistic execution solves this is by tracking the inputs used while executing transaction 2 and comparing them to the outputs of transaction 1.  If they differ, we have detected that transaction 2 used incorrect data while executing and it needs to be executed again with the correct data.\n\nWhile Monad executes transactions in parallel, the updated state for each transaction is \"merged\" sequentially in order to check the condition mentioned above.\n\nRelated computer science topics are [optimistic concurrency control](https://en.wikipedia.org/wiki/Optimistic\\_concurrency\\_control) (OCC) and [software transactional memory](https://en.wikipedia.org/wiki/Software\\_transactional\\_memory) (STM)."
  },
  {
    "instruction": "What is covered in the 'Optimistic Execution Implications' section of the Developer Essentials guide?",
    "output": "In a na\u00efve implementation of optimistic execution, one doesn't detect that a transaction needs to be executed again until earlier transactions in the block have completed.  At that time, the state updates for all the earlier transactions have been merged so it's not possible for the transaction to fail due to optimistic execution a second time.\n\nThere are steps in executing a transaction that do not depend on state. An example is signature recovery, which is an expensive computation.  This work does not need to be repeated when executing the transaction again.\n\nFurthermore, when executing a transaction again due to failure to merge, often the account(s) and storage accessed will not change.  This state is still be cached in memory, so again this is expensive work that does not need to be repeated."
  },
  {
    "instruction": "What is covered in the 'Scheduling' section of the Developer Essentials guide?",
    "output": "A na\u00efve implementation of optimistic execution will try to start executing the next transaction when the processor has available resources.  There may be long \"chains\" of transactions which depend on each other in the block.  Executing these transactions in parallel would result in a significant number of failures.\n\nDetermining dependencies between transactions ahead of time allows Monad to avoid this wasted effort by only scheduling transactions for execution when prerequisite transactions have completed.  Monad has a static code analyzer that tries to make such predictions.  In a good case Monad can predict many dependencies ahead of time; in the worst case Monad falls back to the na\u00efve implementation."
  },
  {
    "instruction": "What is covered in the 'Further Work' section of the Developer Essentials guide?",
    "output": "There are other opportunities to avoid re-executing transactions which are still being explored.\n---\n\n# Hardware Requirements\n\nThe following hardware requirements are expected to run a Monad full node:\n\n* CPU: 16 core CPU with 4.5 ghz+ base clock speed, e.g. AMD Ryzen 7950X\n* Memory: 32 GB RAM\n* Storage: 2 x 2 TB NVMe SSDs (one dedicated to MonadDB)\n* Bandwidth: 100 Mb/s\n---\n\n# Other Details"
  },
  {
    "instruction": "What is covered in the 'Accounts' section of the Developer Essentials guide?",
    "output": "Accounts in Monad are identical to [Ethereum accounts](https://ethereum.org/en/developers/docs/accounts/).  Accounts use the same address space (20-byte addresses using ECDSA).  As in Ethereum, there are Externally-Owned Accounts (EOAs) and Contract Accounts."
  },
  {
    "instruction": "What is covered in the 'Transactions' section of the Developer Essentials guide?",
    "output": "The transaction format in Monad [matches Ethereum](https://ethereum.org/en/developers/docs/transactions/), i.e. it complies with [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718), and transactions are encoded with [RLP](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).\n\nAccess lists ([EIP-2930](https://eips.ethereum.org/EIPS/eip-2930)) are supported but not required."
  },
  {
    "instruction": "What is covered in the 'Linearity of Blocks and Transactions' section of the Developer Essentials guide?",
    "output": "Blocks are still linear, as are transactions within a block.  Parallelism is utilized strictly for efficiency; it never affects the true outcome or end state of a series of transactions."
  },
  {
    "instruction": "What is covered in the 'Gas' section of the Developer Essentials guide?",
    "output": "[Gas](https://ethereum.org/en/developers/docs/gas/)\u00a0(perhaps more clearly named \"compute units\") functions as it does in Ethereum, i.e. each opcode costs a certain amount of gas. Gas costs per opcode are identical to Ethereum in Monad, although this is subject to change in the future.\n\nWhen a user submits a transaction, they include a gas limit (a max number of units of gas that this function call can consume before erroring) as well as a gas price (a bid, in units of native token, per unit of gas).\n\nLeaders in the default Monad client use a priority gas auction (PGA) to order transactions, i.e. they order transactions by descending (effective) priority fee per gas. Currently, baseFeePerGas on Monad is hardcoded to 50 gwei.  As a consequence of Monad\u2019s [delayed execution](./consensus/asynchronous-execution), block gas limits and base fees are both applied to the gasLimit parameter of transactions rather than the actual gas used by execution.  As with EIP-1559, base fees are burned.\n\nA finalized transaction fee mechanism is still under active development.\n---\n\n# Transaction Lifecycle in Monad"
  },
  {
    "instruction": "What is covered in the 'Transaction Submission' section of the Developer Essentials guide?",
    "output": "The lifecycle of a transaction starts with a user preparing a signed transaction and submitting it to an RPC node.\n\nTransactions are typically prepared by an application frontend, then presented to the user's wallet for signing. Most wallets make an `eth_estimateGas` RPC call to populate the gas **limit** for this transaction, although the user can also override this in their wallet. The user is also typically asked to choose a gas **price** for the transaction, which is a number of NativeTokens per unit of gas.\n\nAfter the user approves the signing in their wallet, the signed transaction is submitted to an RPC node using the `eth_sendTransaction` or `eth_sendRawTransaction` API call."
  },
  {
    "instruction": "What is covered in the 'Mempool Propagation' section of the Developer Essentials guide?",
    "output": "As described in [Local Mempool](/monad-arch/consensus/local-mempool.md):\n\nThe RPC node performs validity checks:\n- signature verification\n- nonce not too low\n- gas limit below block gas limit\n\nbefore forwarding the pending transaction to the next `N` leaders.\n\nEach of those leaders replicate those validity checks before adding the pending transaction to their local mempool.\n\nIf the transaction isn't included in any of the blocks proposed by those leaders, the RPC node repeats this process, sending to the next `N` leaders. The process is repeated up to `K` times."
  },
  {
    "instruction": "What is covered in the 'Block Inclusion' section of the Developer Essentials guide?",
    "output": "Pending transactions are included in a block only if further dynamic checks pass:\n - account balance is sufficient to pay for gas (see: [Balance Validation at Time of Consensus](/monad-arch/consensus/asynchronous-execution.mdx#balance-validation-at-time-of-consensus))\n - nonce is contiguous\n - there is space in the block and the leader has chosen to include this transaction"
  },
  {
    "instruction": "What is covered in the 'Block Propagation' section of the Developer Essentials guide?",
    "output": "Blocks are propagated through the network as discussed in [MonadBFT](/monad-arch/consensus/monad-bft.mdx), using the [RaptorCast](/monad-arch/consensus/raptorcast.md) messaging protocol for outbound messages from the leader.\n\nUnder MonadBFT, a block progresses from the Proposed phase to the Voted phase (after 1 block) and then to the Finalized phase (after 2 blocks).\n\nOnce the block is Finalized, the transaction has officially \"occurred\" in the history of the blockchain. Since its order is determined, its truth value (i.e., whether it succeeds or fails, and what the outcome is immediately after that execution) is determined."
  },
  {
    "instruction": "What is covered in the 'Local Execution' section of the Developer Essentials guide?",
    "output": "As soon as a node finalizes a block, it begins executing the transactions from that block. For efficiency reasons, transactions are executed [optimistically in parallel](/monad-arch/execution/parallel-execution.md), but it is as if the transactions were executed serially, since results are always committed in the original order."
  },
  {
    "instruction": "What is covered in the 'Querying the Outcome' section of the Developer Essentials guide?",
    "output": "The user can query the result of the transaction by calling `eth_getTransactionByHash` or `eth_getTransactionReceipt` on any RPC node. The RPC node will return as soon as execution completes locally on the node.\n\n---\n\n\n# Official Links\n\n| What                     | Where                                                                                  |\n| ------------------------ | -------------------------------------------------------------------------------------- |\n| Website                  | [https://monad.xyz](https://monad.xyz)                                                 |\n| Testnet Hub              | [https://testnet.monad.xyz](https://testnet.monad.xyz)                                 |\n| Ecosystem Directory      | [https://monad.xyz/ecosystem](https://monad.xyz/ecosystem)                             |\n| Testnet Block Explorer   | [https://testnet.monadexplorer.com](https://testnet.monadexplorer.com)                 |\n| X                        | [https://x.com/monad\\_xyz](https://x.com/monad\\_xyz)                                   |\n| Monad Eco X              | [https://x.com/monad\\_eco](https://x.com/monad\\_eco)                                   |\n| DevNads on X             | [https://x.com/monad\\_dev](https://x.com/monad\\_dev)                                   |\n| The Pipeline on X        | [https://x.com/pipeline\\_xyz](https://x.com/pipeline\\_xyz)                             |\n| Substack                 | [https://monadxyz.substack.com](https://monadxyz.substack.com)                         |\n| Discord                  | [https://discord.gg/monad](https://discord.gg/monad)                                   |\n| Developer Discord        | [https://discord.gg/monaddev](https://discord.gg/monaddev)                             |\n| Monad Foundation Jobs    | [https://jobs.ashbyhq.com/monad.foundation](https://jobs.ashbyhq.com/monad.foundation) |\n\n\n\n\n---\n\n\n# RPC Reference\n\nMonad supports a [JSON-RPC](https://www.jsonrpc.org/specification) interface for interacting with the blockchain. \n\n* [RPC Differences](rpc-differences.md)\n* [RPC Error Codes](rpc-error-codes.md)\n* [RPC API Reference](/reference/json-rpc)\n---\n\n\n# JSON-RPC API\n\nThis section provides an interactive reference for the Monad's JSON-RPC API.\n\nView the JSON-RPC API methods by selecting a method in the left sidebar. You can test the methods directly in the page using the API playground, with pre-configured examples or custom parameters.\n---\n\n\n# RPC Differences\n\nMonad aims to match the RPC behavior as close as possible to Geth\u2019s behavior, but due to fundamental architectural differences, there are some discrepancies listed below.\n\n1. `eth_getLogs` currently have a maximum block range of 100 blocks. Because Monad blocks are much larger than Ethereum blocks, we recommend using small block ranges (e.g. 1-10 blocks) for optimal performance. When requesting more, requests can take a long time to be fulfilled and may timeout.\n2. `eth_sendRawTransaction` may not immediately reject transactions with a nonce gap or insufficient gas balance. Due to asynchronous execution, the RPC server may not have the latest world view. Thus these transactions are allowed as they may become valid transactions during block creation.\n3. `eth_call` and `eth_estimateGas` do not accept EIP-4844 transaction type yet. This is temporary.\n4. `eth_maxPriorityFeePerGas` currently returns a hardcoded suggested fee of 2 gwei. This is temporary.\n5. `eth_feeHistory` currently also returns default values as the base fee in testnet is hardcoded. This is temporary.\n6. Websockets are not yet supported. This is temporary.\n---\n\n\n# RPC Error Codes\n\nMonad supports a [JSON-RPC](https://www.jsonrpc.org/specification) interface for interacting with the blockchain.\n Monad JSON-RPC aims to be equivalent to Ethereum JSON-RPC, however some error codes slightly deviate due to lack of standardization across Ethereum clients."
  },
  {
    "instruction": "What is covered in the 'Monad Error Codes Reference' section of the Developer Essentials guide?",
    "output": "<table>\n   <thead>\n      <tr>\n         <th width=\"218\">Error Code</th>\n         <th width=\"264.3333333333333\">Message</th>\n         <th width=\"255\">Explanation</th>\n      </tr>\n   </thead>\n   <tbody>\n      <tr>\n         <td><strong>-32601</strong></td>\n         <td>Parse error</td>\n         <td>Unable to parse JSON-RPC request</td>\n      </tr>\n      <tr>\n         <td><strong>-32601</strong></td>\n         <td>Invalid request</td>\n         <td>Invalid request such as request that exceeds size limit</td>\n      </tr>\n      <tr>\n         <td><strong>-32601</strong></td>\n         <td>Method not found</td>\n         <td>Method that is not part of the JSON-RPC spec</td>\n      </tr>\n      <tr>\n         <td><strong>-32601</strong></td>\n         <td>Method not supported</td>\n         <td>Method that is part of the JSON-RPC spec but not yet supported by Monad</td>\n      </tr>\n      <tr>\n         <td><strong>-32602</strong></td>\n         <td>Invalid block range</td>\n         <td>eth_getLogs filter range is limited to 100 blocks</td>\n      </tr>\n      <tr>\n         <td><strong>-32602</strong></td>\n         <td>Invalid params</td>\n         <td>Request contains incorrect parameters associated to the particular method</td>\n      </tr>\n      <tr>\n         <td><strong>-32603</strong></td>\n         <td>Internal error</td>\n         <td>Request that cannot be fulfilled due to internal error</td>\n      </tr>\n      <tr>\n         <td><strong>-32603</strong></td>\n         <td>Execution reverted</td>\n         <td>eth_call and eth_estimateGas simulates transaction to revert</td>\n      </tr>\n      <tr>\n         <td><strong>-32603</strong></td>\n         <td>Transaction decoding error</td>\n         <td>Request contains raw transaction that cannot be decoded</td>\n      </tr>\n   </tbody>\n</table>\n\n\n---\n\n# Tooling and Infrastructure\n\nMany leading Ethereum developer tools support Monad Testnet. The enclosing pages survey each category of tools and attempt a feature comparison.\n\n* [Account Abstraction](account-abstraction/README.md)\n  * [AA Infrastructure](account-abstraction/infra-providers.md)\n  * [Wallet-as-a-Service](account-abstraction/wallet-providers.md)\n* [Block Explorers](block-explorers.md)\n* [Cross-Chain](cross-chain.md)\n* [Indexers](indexers/README.md)\n  * [Common Data](indexers/common-data.md)\n  * [Indexing Frameworks](indexers/indexing-frameworks.md)\n* [Oracles](oracles.md)\n* [RPC Providers](rpc-providers.md)\n* [Toolkits](toolkits.md)\n* [Wallets](wallets.md)\n\n---\n\n# Account Abstraction\n\nAccount Abstraction means utilizing smart contract wallets in place of EOAs. Subproblems include:\n1. how UserOperations get submitted (and paid for)\n2. the authentication mechanism\n3. the SDK for interacting with the wallet\n4. the UI of the wallet\n\nRoughly speaking, subproblem (1) is handled by bundlers and paymasters, while subproblems (2) through (4) are handled by Wallet-as-a-Service (WaaS) providers."
  },
  {
    "instruction": "What is covered in the 'UserOperation Submission' section of the Developer Essentials guide?",
    "output": "Under ERC-4337, transactions (actually UserOperations) get submitted via a bundler and may be paid for by a paymaster.\n\nSee **[AA Infra Providers](infra-providers.md)** for a list of providers supporting the Monad Testnet."
  },
  {
    "instruction": "What is covered in the 'Wallet Mechanics' section of the Developer Essentials guide?",
    "output": "Wallet-as-a-Service (WaaS) providers offer modular components that allow application developers to customize how transactions will be signed and submitted.\n\nSee **[AA Wallet Providers](wallet-providers.md)** for a list of WaaS providers supporting the Monad Testnet.\n\n\n---\n\n# AA Infra Providers\n\nAA Providers provide bundler and paymaster services, enabling features like sponsored transactions or payment via custom tokens."
  },
  {
    "instruction": "What is covered in the 'Definitions' section of the Developer Essentials guide?",
    "output": "| Service | Description |\n| --------- | --------- |\n| Bundler   | Operates a custom mempool for UserOperations; simulates and assembles bundles of UserOperations |\n| Paymaster | Enables sponsored transactions; enables users to pay for gas with a custom token                |"
  },
  {
    "instruction": "What is covered in the 'Provider Summary' section of the Developer Essentials guide?",
    "output": "These providers support Monad Testnet:\n\n<table>\n  <thead>\n    <tr>\n      <th>Provider</th>\n      <th>Docs</th>\n      <th>Supported services</th>\n      <th>How to get started</th>\n    </tr>\n  </thead>\n  <tbody>   \n    \n    <tr>\n      <td>[Alchemy](https://www.alchemy.com/smart-wallets)</td>\n      <td>[Docs](https://accountkit.alchemy.com/)</td>\n      <td>[Gas Manager](https://docs.alchemy.com/docs/gas-manager-services) (aka Paymaster)<br/>\n          [Bundler](https://docs.alchemy.com/docs/bundler-services)</td>\n      <td>[Dashboard](https://dashboard.alchemy.com/accounts?a=smart-wallets)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Biconomy](https://biconomy.io)</td>\n      <td>[Docs](https://docs.biconomy.io)</td>\n      <td>[Paymaster](https://docs.biconomy.io/infra/paymaster/integration)<br/>\n        [Bundler](https://docs.biconomy.io/infra/bundler/integration)</td>\n      <td>[Quickstart](https://docs.biconomy.io/tutorials/simple)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[FastLane](https://www.fastlane.xyz/)</td>\n      <td>[Docs](https://docs.shmonad.xyz/)</td>\n      <td>[Paymaster and Bundler](https://github.com/FastLane-Labs/4337-bundler-paymaster-script/tree/main)</td>\n      <td>[Dashboard](https://shmonad.xyz/)</td>\n    </tr>\n\n        \n    <tr>\n      <td>[Gelato Relay](https://docs.gelato.network/web3-services/relay)</td>\n      <td>[Docs](https://docs.gelato.network/web3-services/relay)</td>\n      <td>Gelato [Relay](https://docs.gelato.network/web3-services/relay)</td>\n      <td>[Quickstart](https://docs.gelato.network/web3-services/relay/quick-start)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Openfort](https://openfort.io/)</td>\n      <td>[Docs](https://www.openfort.io/docs)</td>\n      <td>[Paymaster and Bundler](https://www.openfort.io/docs/overview/infrastructure)</td>\n      <td>[Quickstart](https://www.openfort.io/docs/overview/start)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Pimlico](https://pimlico.io/)</td>\n      <td>[Docs](https://docs.pimlico.io/)</td>\n      <td>[Paymaster](https://docs.pimlico.io/infra/paymaster)<br/>\n        [Bundler](https://docs.pimlico.io/infra/bundler)</td>\n      <td>[Tutorial](https://docs.pimlico.io/permissionless/tutorial/tutorial-1)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[thirdweb](https://thirdweb.com/)</td>\n      <td>[Docs](https://portal.thirdweb.com/)</td>\n      <td>[Paymaster and Bundler](https://portal.thirdweb.com/connect/account-abstraction/infrastructure)</td>\n      <td>[Quickstart](https://portal.thirdweb.com/typescript/v5/account-abstraction/get-started)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[ZeroDev](https://zerodev.app/)</td>\n      <td>[Docs](https://docs.zerodev.app/)</td>\n      <td>[Meta AA infrastructure](https://docs.zerodev.app/meta-infra/intro) for bundlers and paymasters</td>\n      <td>[Dashboard](https://dashboard.zerodev.app/)</td>\n    </tr>\n  </tbody>\n</table>"
  },
  {
    "instruction": "What is covered in the 'Provider Details' section of the Developer Essentials guide?",
    "output": "### Alchemy\n\nAlchemy powers the [#1 most used](https://www.bundlebear.com/factories/all) smart accounts today with account abstraction that eliminates gas fees and signing for users. Their accounts support ERC-4337, EIP-7702, and ERC-6900, a modular account standard co-authored with the Ethereum Foundation, Circle, and Trust Wallet.\n\nTo get started, sign up for an [Alchemy account](https://dashboard.alchemy.com/accounts), visit the [documentation](https://accountkit.alchemy.com/), follow the [quickstart](https://accountkit.alchemy.com/react/quickstart) guide. To learn more, check out their [smart wallets](https://www.alchemy.com/smart-wallets) and demo [here](https://demo.alchemy.com/).\n\nSupported Networks\n- Monad Testnet\n\n\n### Biconomy\n\n[Biconomy](https://biconomy.io) is the most comprehensive smart account and execution infrastructure platform that enables seamless, user-friendly experiences across single or multiple chains. With Biconomy, developers can build superior onchain UX through gas abstraction, sessions, batching, and one-click signatures for complex actions on any number of networks.\n\nTo get started, visit the [documentation](https://docs.biconomy.io/) or follow the [simple tutorial](https://docs.biconomy.io/tutorials/simple).\n\nSupported Networks\n- Monad Testnet\n\n\n### FastLane\n\n[FastLane](https://www.fastlane.xyz/) is an MEV protocol for validators + apps with an integrated 4337 bundler, an on-chain task scheduler, and the first holistic LST.\n\nTo get started, vist the [shMonad](https://docs.shmonad.xyz/) Documentation or try the shMonad bundler using the following example [project](https://github.com/FastLane-Labs/4337-bundler-paymaster-script/tree/main).\n\nSupported Networks\n- Monad Testnet\n\n\n### Gelato Relay\n\n[Gelato Relay](https://docs.gelato.network/web3-services/relay) allows you to sponsor gas cost on behalf of the user, enable gasless cross-chain transactions and Account Abstraction.\n\n\n\n\nTo get started, visit the [documentation](https://docs.gelato.network/web3-services/relay/what-is-relaying) or follow the [quickstart](https://docs.gelato.network/web3-services/relay/quick-start) guide.\n\nSupported Networks:\n- Monad Testnet\n\n\n### Openfort\n\n[Openfort](https://openfort.io) is a developer platform that helps projects onboard and and activates wallets. It does so by creating wallets with it\u2019s SSS and passkeys,sending transactions via sponsored paymasters and session keys or directly using backend wallets for automated onchain actions.\n\nTo get started, visit the [documentation](https://www.openfort.io/docs/overview/start) or follow the [quickstart](https://www.openfort.io/docs/guides/react) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### Pimlico\n\n[Pimlico](https://pimlico.io/) is the world's most advanced ERC-4337 account abstraction infrastructure platform. Pimlico provides a suite of tools and services to help you build, deploy, and manage smart accounts on Ethereum and other EVM-compatible chains.\n\nTo get started, visit the [documentation](https://docs.pimlico.io/) or follow the [quickstart](https://docs.pimlico.io/permissionless/tutorial/tutorial-1) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### thirdweb\n\n[thirdweb](https://portal.thirdweb.com/connect/account-abstraction/overview) offers a complete platform to leverage account abstraction.\n\nRemove the clunky user experience of requiring gas & signatures for every onchain action:\n\n* Abstract away gas\n* Pre-audited account factory contracts\n* Built-in infra:\n* Sponsorship policies\n\nTo get started:\n\n1. Sign up for a [free thirdweb account](https://thirdweb.com/team)\n2. Visit [Account Abstraction Documentation](https://portal.thirdweb.com/connect/account-abstraction/how-it-works) and [Account Abstraction Playground](https://playground.thirdweb.com/connect/account-abstraction/connect)\n\nSupported Networks\n- Monad Testnet\n\n\n### Zerodev\n\n[ZeroDev](https://zerodev.app) is the most powerful smart account development platform. With ZeroDev, you can build Web3 experiences without gas, confirmations, seed phrases, and bridging.\n\nTo get started, visit the [documentation](https://docs.zerodev.app/) or follow the [quickstart](https://docs.zerodev.app/sdk/getting-started/quickstart) guide.\n\nSupported Networks\n- Monad Testnet\n---\n\n# AA Wallet Providers\n\nUnder ERC-4337, smart wallets perform authentication (signature verification) inside of a smart contract. \nDepending on the signature scheme, signing may be done locally (on the user's computer) or in a remote environment (e.g. TEEs).\n\nFull-stack Wallet-as-a-Service (WaaS) providers offer a smart contract wallet, the associated infrastructure for signing UserOperations, an SDK for interacting with the wallet, and UI components for sign-in and for authorizing transactions."
  },
  {
    "instruction": "What is covered in the 'Authentication Features' section of the Developer Essentials guide?",
    "output": "| Features | Description |\n| --------- | --------- |\n| Passkey sign-in | Authentication with [WebAuthn](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API) (passkey) |\n| Social sign-in | Authentication with social accounts (google, X, etc) |\n| Email sign-in | Authentication with OTP via email |\n| SMS sign-in | Authentication with OTP via SMS |"
  },
  {
    "instruction": "What is covered in the 'Key Management Features' section of the Developer Essentials guide?",
    "output": "| Features  | Description |\n| --------- | ----------- |\n| MPC | Multi-party computation |\n| SSS | Shamir's Secret Sharing |\n| TEE | Storage of private keys in a cloud-based Trusted Execution Environment, like AWS Nitro Enclaves |\n| TSS | Threshold Signature Scheme |\n| Embedded wallet | A wallet interface local to a website or mobile app, utilizing browser session keys for signing |\n| Server-delegated actions | Allow app to request permission to sign on the user's behalf |\n| Session keys | Scoped keys that grant access only for specific apps, useful for bots/AI agents |"
  },
  {
    "instruction": "What is covered in the 'Provider Summary' section of the Developer Essentials guide?",
    "output": "These WaaS providers support the Monad Testnet:\n\n<table>\n  <thead>\n    <tr>\n      <th>Provider</th>\n      <th>Docs</th>\n      <th>Supported services</th>\n      <th>Security Method</th>\n      <th>How to get started</th>\n    </tr>\n  </thead>\n  <tbody>   \n    \n    <tr>\n      <td>[Alchemy](https://www.alchemy.com/smart-wallets)</td>\n      <td>[Docs](https://accountkit.alchemy.com/)</td>\n      <td>[Embedded wallets](https://accountkit.alchemy.com/react/quickstart)<br/>\n      Auth: [passkey](https://accountkit.alchemy.com/signer/authentication/passkey-signup), [social](https://accountkit.alchemy.com/signer/authentication/social-login), [email](https://accountkit.alchemy.com/signer/authentication/email-otp) sign-in</td>\n      <td></td>\n      <td>[Quickstart](https://accountkit.alchemy.com/react/quickstart)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Biconomy](https://biconomy.io)</td>\n      <td>[Docs](https://docs.biconomy.io)</td>\n      <td>[Nexus: Smartest & most gas-efficient smart account](https://docs.biconomy.io/overview)<br/>\n      Auth: [passkey](https://docs.biconomy.io/modules/validators/passkeyValidator), [multisig](https://docs.biconomy.io/modules/validators/ownableValidator), [ECDSA](https://docs.biconomy.io/modules/validators/k1Validator#k1validator-overview) sign-in; [session keys](https://docs.biconomy.io/modules/validators/smartSessions)</td>\n      <td>Bring Your Own Signer</td>\n      <td>[Quickstart](https://docs.biconomy.io/tutorials/smart-sessions)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Dynamic](https://dynamic.xyz/)</td>\n      <td>[Docs](https://docs.dynamic.xyz/)</td>\n      <td>[Embedded wallets](https://docs.dynamic.xyz/wallets/embedded-wallets/dynamic-embedded-wallets)<br/>\n      Auth: [passkey](https://docs.dynamic.xyz/wallets/v1-embedded/transactional-mfa/passkeys#passkeys), [email/social/SMS](https://docs.dynamic.xyz/authentication-methods/email-social-sms) sign-in</td>\n      <td>TEE; TSS-MPC (just added)</td>\n      <td>[Get started](https://www.dynamic.xyz/get-started)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Openfort](https://openfort.io/)</td>\n      <td>[Docs](https://www.openfort.io/docs)</td>\n      <td>[Embedded wallets](https://www.openfort.io/docs/guides/react/configuration), [Backend wallets](https://www.openfort.io/docs/guides/server/dev), [Ecosystem wallets](https://www.openfort.io/docs/guides/ecosystem)<br/>\n      Auth: [passkeys](https://www.openfort.io/docs/guides/javascript/auth), [social](https://www.openfort.io/docs/guides/javascript/auth), [email](https://www.openfort.io/docs/guides/javascript/auth)</td>\n      <td>SSS</td>\n      <td>[Quickstart](https://www.openfort.io/docs/guides/react)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Para](https://www.getpara.com/)</td>\n      <td>[Docs](https://docs.getpara.com/)</td>\n      <td>[Embedded wallets](https://docs.getpara.com/getting-started/initial-setup/react-nextjs); robust policy engine for sessions<br/>\n      Auth: [email](https://docs.getpara.com/customize-para/email-login), [social](https://docs.getpara.com/customize-para/oauth-social-logins), [SMS](https://docs.getpara.com/customize-para/phone-login) sign-in</td>\n      <td>MPC + DKG</td>\n      <td>[Quickstart](https://docs.getpara.com/integration-guides/overview-evm)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Phantom](https://phantom.com/learn/developers)</td>\n      <td>[Docs](https://docs.phantom.com/)</td>\n      <td>[Embedded wallets](https://github.com/phantom/wallet-sdk) (Web SDK & Native Mobile SDK)<br/>\n      Auth: [Google](https://phantom.com/learn/blog/deep-dive-log-in-to-phantom-with-email) sign-in</td>\n      <td>SSS</td>\n      <td>[Quickstart](https://docs.phantom.com/embedded/getting-started-with-phantom-embedded-wallets)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Pimlico](https://pimlico.io/)</td>\n      <td>[Docs](https://docs.pimlico.io/)</td>\n      <td>[permissionless.js](https://docs.pimlico.io/permissionless), a flexible SDK for interfacing with various smart accounts, bundlers/paymasters, and signers.</td>\n      <td></td>\n      <td>[Tutorial](https://docs.pimlico.io/permissionless/tutorial/tutorial-1)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Privy](https://privy.io/)</td>\n      <td>[Docs](https://docs.privy.io/)</td>\n      <td>[Embedded wallets](https://docs.privy.io/guide/embedded-wallets), [server wallets](https://docs.privy.io/guide/overview-server-wallets), [server-delegated actions](https://docs.privy.io/guide/server-delegated-actions)<br/>\n      Auth: [passkey](https://docs.privy.io/guide/authentication), [social](https://docs.privy.io/guide/authentication), [email](https://docs.privy.io/guide/authentication), [SMS](https://docs.privy.io/guide/authentication)</td>\n      <td>TEE + SSS</td>\n      <td>[Quickstart](https://docs.privy.io/guide/react/quickstart)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Reown](https://reown.com/) (formerly WalletConnect)</td>\n      <td>[Docs](https://docs.reown.com/)</td>\n      <td>Popular UI component for selecting a wallet<br/>\n      Embedded wallet with social/email sign-in</td>\n      <td></td>\n      <td>[Quickstart](https://docs.reown.com/quickstart)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[thirdweb](https://thirdweb.com/)</td>\n      <td>[Docs](https://portal.thirdweb.com/connect/wallet/overview)</td>\n      <td>Embedded wallets<br/>\n      Auth: [passkey](https://portal.thirdweb.com/connect/wallet/sign-in-methods/configure), [social](https://portal.thirdweb.com/connect/wallet/sign-in-methods/configure), [email](https://portal.thirdweb.com/connect/wallet/sign-in-methods/configure), [SMS](https://portal.thirdweb.com/connect/wallet/sign-in-methods/configure), OIDC, or generic auth</td>\n      <td></td>\n      <td>[Quickstart](https://portal.thirdweb.com/connect/wallet/get-started)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Turnkey](https://www.turnkey.com/)</td>\n      <td>[Docs](https://docs.turnkey.com/)</td>\n      <td>[Embedded wallet](https://docs.turnkey.com/reference/embedded-wallet-kit), [policy engine](https://docs.turnkey.com/concepts/policies/overview), [delegated access](https://docs.turnkey.com/concepts/policies/delegated-access), [signing automation](https://docs.turnkey.com/signing-automation/overview), [sessions](https://docs.turnkey.com/authentication/sessions)<br/>\n      [Server-side SDKs](https://docs.turnkey.com/sdks/introduction) for auth, wallet management, and policies<br/>\n      Auth: [passkey](https://docs.turnkey.com/authentication/passkeys/introduction), [social](https://docs.turnkey.com/authentication/social-logins), [email](https://docs.turnkey.com/authentication/email), [SMS](https://docs.turnkey.com/authentication/sms) login</td>\n      <td>TEE</td>\n      <td>[Quickstart](https://docs.turnkey.com/getting-started/quickstart)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Web3Auth](https://web3auth.io/)</td>\n      <td>[Docs](https://web3auth.io/docs)</td>\n      <td>Embedded wallet<br/>\n      Auth: [passkey](https://web3auth.io/docs/features/passkeys), [social](https://web3auth.io/docs/auth-provider-setup/social-providers/), [email](https://web3auth.io/docs/auth-provider-setup/email-provider/), [SMS](https://web3auth.io/docs/auth-provider-setup/sms-provider/)</td>\n      <td>MPC-SSS/TSS</td>\n      <td>[Quickstart](https://web3auth.io/docs/quick-start)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[ZeroDev](https://zerodev.app/)</td>\n      <td>[Docs](https://docs.zerodev.app/)</td>\n      <td>[Smart contract accounts](https://docs.zerodev.app/sdk/core-api/create-account)<br/>\n      [Session keys](https://docs.zerodev.app/sdk/permissions/intro) with several options for signature schemes (ECDSA, Passkey, Multisig), policies, and actions.</td>\n      <td></td>\n      <td>[Quickstart](https://docs.zerodev.app/sdk/getting-started/quickstart)</td>\n    </tr>\n  </tbody>\n</table>"
  },
  {
    "instruction": "What is covered in the 'Provider Details' section of the Developer Essentials guide?",
    "output": "### Alchemy\n\n[Account Kit](https://accountkit.alchemy.com/) is a complete solution for account abstraction. Using Account Kit, you can create a smart contract wallet for every user that leverages account abstraction to simplify every step of your app's onboarding experience. It also offers Gas Manager and Bundler APIs for sponsoring gas and batching transactions.\n\nTo get started, sign up for an [Alchemy account](https://www.alchemy.com/), visit the [documentation](https://accountkit.alchemy.com/), follow the [quickstart](https://accountkit.alchemy.com/react/quickstart) guide or check out the demo [here](https://demo.alchemy.com/).\n\nAlchemy helps you to replace 3rd-party pop-up wallets with native in-app auth. Drop in branded sign-in modals for email, passkeys, and social logins with plug-n-play components.\n\nTo get started, sign up for an [Alchemy account](https://dashboard.alchemy.com/accounts), visit the [documentation](https://accountkit.alchemy.com/), follow the [quickstart](https://accountkit.alchemy.com/react/quickstart) guide. To further streamline UX with no gas fees or signing for users, see Alchemy's [AA infra offering](infra-providers.md#alchemy) and a demo [here](https://demo.alchemy.com/).\n\nSupported Networks\n- Monad Testnet\n\n\n### Biconomy\n\n[Biconomy](https://biconomy.io) is the most comprehensive smart account and execution infrastructure platform that enables seamless, user-friendly experiences across single or multiple chains. With Biconomy, developers can build superior onchain UX through gas abstraction, sessions, batching, and one-click signatures for complex actions on any number of networks.\n\nTo get started, visit the [documentation](https://docs.biconomy.io/) or follow the [simple tutorial](https://docs.biconomy.io/tutorials/simple).\n\nSupported Networks\n- Monad Testnet\n\n\n### Dynamic\n\n[Dynamic](https://dynamic.xyz/) offers smart and beautiful login flows for crypto-native users, simple onboarding flows for everyone else, and powerful developer tools that go beyond authentication.\n\nTo get started, visit the [documentation](https://docs.dynamic.xyz/) or follow the [quickstart](https://docs.dynamic.xyz/docs/quickstart) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### MetaKeep\n\n[MetaKeep](https://www.metakeep.xyz/) is the #1 self-custody infra for users & AI. Onboard 300x more users in 1 API call, 5 mins.\n\nTo get started, setup an [onboarding call](https://mtkp.xyz/priority-meet) with the team.\n\nSupported Networks\n- Monad Testnet\n\n\n### Para\n\n[Para](https://www.getpara.com/) is the easiest and most secure way to onboard all your users and support them throughout their crypto journey. We support projects throughout their growth, ranging from personal projects to many of the most trusted teams in crypto and beyond.\n\nPara's cross-app embedded wallets work universally across apps, chains, and ecosystem, so whether users start transacting on EVM, Solana, or Cosmos, they can onboard once and transact forever, all with the same wallet.\n\nTo get started, visit the [documentation](https://docs.getpara.com/welcome) or follow the [quickstart](https://docs.getpara.com/welcome#adding-para-to-your-app) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### Phantom\n\n[Phantom](https://phantom.com/) is the world's leading crypto wallet for managing digital assets and accessing decentralized applications. \n\nPhantom embedded wallets enable seamless, seedless onboarding with in-app, non-custodial access--no app switching or seed phrases required.\n\nTo get started, visit the [documentation](https://docs.phantom.com/) or follow the [quickstart](https://docs.phantom.com/embedded/getting-started-with-phantom-embedded-wallets) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### Pimlico\n\n[Pimlico](https://pimlico.io/) is the world's most advanced ERC-4337 account abstraction infrastructure platform. Pimlico provides a suite of tools and services to help you build, deploy, and manage smart accounts on Ethereum and other EVM-compatible chains.\n\nTo get started, visit the [documentation](https://docs.pimlico.io/) or follow the [quickstart](https://docs.pimlico.io/permissionless/tutorial/tutorial-1) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### Privy\n\n[Privy](https://privy.io/) helps you onboard any user to crypto no matter how familiar they are with the space. Power flexible, powerful wallets under the hood for any application, securely.\n\nTo get started, visit the [documentation](https://docs.privy.io/) or follow the [quickstart](https://docs.privy.io/guide/react/quickstart) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### Reown\n\n[Reown](https://reown.com/) gives developers the tools to build user experiences that make digital ownership effortless, intuitive, and secure. \n\n#### AppKit\n\nAppKit is a powerful, free, and fully open-source SDK for developers looking to integrate wallet connections and other Web3 functionalities into their apps on any EVM and non-EVM chain. In just a few simple steps, you can provide your users with seamless wallet access, one-click authentication, social logins, and notifications\u2014streamlining their experience while enabling advanced features like on-ramp functionality, in-app token swaps and smart accounts.\n\nTo get started, visit the [documentation](https://docs.reown.com/) or follow the [quickstart](https://reown.com/blog/how-to-get-started-with-reown-appkit-on-monad-testnet) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### thirdweb\n\n[thirdweb](https://thirdweb.com/) provides client-side SDKs for user onboarding, identity and transactions.\n\n* Onboard new users to your apps with every wallet & login method\n* create a complete picture of all your users via user analytics & identity linking\n* facilitate onchain transactions via onramps, swaps & bridging\n\nTo get started:\n\n1. Sign up for a [free thirdweb account](https://thirdweb.com/team)\n2. Visit [Connect Documentation](https://portal.thirdweb.com/connect/sign-in/ConnectButton) and [Connect Playground](https://playground.thirdweb.com/connect/sign-in/button)\n\nSupported Networks\n- Monad Testnet\n\n\n### Turnkey\n\n[Turnkey](https://www.turnkey.com/) is secure, flexible, and scalable wallet infrastructure. Create millions of embedded wallets, eliminate manual transaction flows, and automate onchain actions - all without compromising on security.\n\nTo get started, visit the [documentation](https://docs.turnkey.com/) or follow the [quickstart](https://docs.turnkey.com/getting-started/embedded-wallet-quickstart) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### Web3Auth\n\n[Web3Auth](https://web3auth.io/) simplifies Web3 access with social logins, customisable wallet UI, and advanced security, with non custodial MPC wallet management.\n\nTo get started, visit the [documentation](https://web3auth.io/docs) or follow the [quickstart](https://web3auth.io/docs/quick-start) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### Zerodev\n\n[ZeroDev](https://zerodev.app) is the most powerful smart account development platform. With ZeroDev, you can build Web3 experiences without gas, confirmations, seed phrases, and bridging.\n\nTo get started, visit the [documentation](https://docs.zerodev.app/) or follow the [quickstart](https://docs.zerodev.app/sdk/getting-started/quickstart) guide.\n\nSupported Networks\n- Monad Testnet\n---\n\n# Analytics\n\nA number of analytics providers are supporting Monad testnet."
  },
  {
    "instruction": "What is covered in the 'Flipside' section of the Developer Essentials guide?",
    "output": "[Flipside](https://flipsidecrypto.xyz/home/) generates the most reliable and comprehensive blockchain data. All for free.\n\nTo get started, check out the [Flipside documentation](https://docs.flipsidecrypto.xyz/) or [Flipside 101 dashboard](https://flipsidecrypto.xyz/charliemarketplace/flipside-101-ll5imK) to learn more!\n\nSupported Networks\n- Monad Testnet\n---\n\n# Block Explorers"
  },
  {
    "instruction": "What is covered in the 'Provider Summary' section of the Developer Essentials guide?",
    "output": "The following block explorers support Monad Testnet:\n\n| Block explorer         | Powered by  | URL                                  | Verifier Type & URL                                                                   |\n| ---------------------- | ----------- | ------------------------------------ | ------------------------------------------------------------------------------------- |\n| **MonadExplorer**      | BlockVision | https://testnet.monadexplorer.com/   | Sourcify: `https://sourcify-api-monad.blockvision.org`                                |\n| **Monadscan**          | Etherscan   | https://testnet.monadscan.com/       | Etherscan: `https://api-testnet.monadscan.com/api`                                    |\n| **SocialScan - Monad** | Hemera      | https://monad-testnet.socialscan.io/ | Etherscan: `https://api.socialscan.io/monad-testnet/v1/explorer/command_api/contract` |"
  },
  {
    "instruction": "What is covered in the 'Provider Details' section of the Developer Essentials guide?",
    "output": "### BlockVision\n\n[MonadExplorer](https://monadexplorer.com) is built by [BlockVision](https://blockvision.org/), a leading provider of next-gen data infrastructure and enterprise solutions for the blockchain. BlockVision is supports the EVM and Sui and specializes in explorer service, RPC nodes, indexing APIs and validator service.\n\nTo get started, visit the [documentation](https://docs.blockvision.org/reference/monad-indexing-api).\n\nSupported Networks\n- Monad Testnet\n\n### Etherscan\n\n[Monadscan](https://testnet.monadscan.com) is built by [Etherscan](https://etherscan.io/) to deliver trusted and high-performance access to on-chain data. Leveraging Etherscan\u2019s industry-leading expertise, MonadScan provides robust explorer tools, developer-friendly APIs, and reliable infrastructure tailored for the Monad ecosystem.\n\nTo get started, visit the [documentation](https://docs.monadscan.com/).\n\nSupported Networks\n- Monad Testnet\n\n### SocialScan\n\n[Monad SocialScan](https://monad-testnet.socialscan.io/) is a high-performance block explorer built by the [SocialScan](https://socialscan.io/) team.\n\nTo get started, visit the [documentation](https://thehemera.gitbook.io/explorer-api).\n\nSupported Networks\n- Monad Testnet\n---\n\n# Cross-Chain"
  },
  {
    "instruction": "What is covered in the 'Definitions' section of the Developer Essentials guide?",
    "output": "At a high level, bridges offer the following features:\n\n<table>\n    <thead>\n    <tr>\n        <th>Feature</th>\n        <th>Description</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>**Arbitrary Messaging Bridge (AMB)**</td>\n        <td>Allows arbitrary messages to be securely relayed from a smart contract on chain 1 to a smart contract on chain 2.<br/><br/>\n        AMB provides guarantees that messages delivered to chain 2 represent events finalized on chain 1.</td>\n    </tr>\n    <tr>\n        <td>**Token Bridge**</td>\n        <td>Allows user to lock native tokens or ERC20 tokens on chain 1 and mint claim tokens on chain 2.<br/><br/>\n        Bridge maintains the invariant that, for each token minted on chain 2, there exists a corresponding token locked on chain 1.</td>\n    </tr>\n    </tbody>\n</table>"
  },
  {
    "instruction": "What is covered in the 'Provider Summary' section of the Developer Essentials guide?",
    "output": "The following providers support Monad Testnet:\n\n<table>\n    <thead>\n    <tr>\n        <th>Provider</th>\n        <th>Docs</th>\n        <th>Bridge Type</th>\n        <th>Contract Addresses</th>\n        <th>Explorer</th>\n    </tr>\n    </thead>\n    <tbody>\n    \n\n    <tr>\n        <td>Chainlink CCIP</td>\n        <td>[Docs](https://docs.chain.link/ccip)</td>\n        <td>AMB; Token Bridge</td>\n        <td>\n            - Router: [0x5f16e51e3Dcb255480F090157DD01bA962a53E54](https://testnet.monadexplorer.com/address/0x5f16e51e3Dcb255480F090157DD01bA962a53E54)\n            - Supported lanes can be found [here](https://docs.chain.link/ccip/directory/testnet/chain/monad-testnet)\n        </td>\n        <td>[CCIP Explorer](https://ccip.chain.link/)</td>\n    </tr>\n\n    <tr>\n        <td>Garden</td>\n        <td>[Docs](https://docs.garden.finance/)</td>\n        <td>Token Bridge</td>\n        <td>\n            Wrapped Assets:\n            - [cbBTC](https://testnet.monadexplorer.com/address/0x1dC94FdcAd8Aee13cfd34Db8a26d26E31572805c)\n            - [USDC](https://testnet.monadexplorer.com/address/0xE99D8A21d4F2ad2f90c279c869311503f9e25867)\n        </td>\n        <td></td>\n    </tr>\n\n    <tr>\n        <td>Hyperlane</td>\n        <td>[Docs](https://docs.hyperlane.xyz)</td>\n        <td>AMB; Token Bridge</td>\n        <td>\n            - ISM Operator: [0x734628f55694d2a5f4de3e755ccb40ecd72b16d9](https://testnet.monadexplorer.com/address/0x734628f55694d2a5f4de3e755ccb40ecd72b16d9)\n        </td>\n        <td>[Hyperlane Explorer](https://explorer.hyperlane.xyz)</td>\n    </tr>\n\n    <tr>\n        <td>LayerZero</td>\n        <td>[Docs](https://docs.layerzero.network)</td>\n        <td>AMB; Token Bridge</td>\n        <td>\n            [LayerZero V2 Address Reference](https://docs.layerzero.network/v2/deployments/deployed-contracts?chains=monad-testnet)\n\n            - Endpoint V2: [0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff](https://testnet.monadexplorer.com/address/0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff)\n            - Endpoint ID: 40204\n            - SendUln302: [0xd682ECF100f6F4284138AA925348633B0611Ae21](https://testnet.monadexplorer.com/address/0xd682ECF100f6F4284138AA925348633B0611Ae21)\n            - ReceiveUln302: [0xcF1B0F4106B0324F96fEfcC31bA9498caa80701C](https://testnet.monadexplorer.com/address/0xcF1B0F4106B0324F96fEfcC31bA9498caa80701C)\n            - BlockedMessageLib: [0x926984a57b10a3a5c4cfdbac04daaa0309e78932](https://testnet.monadexplorer.com/address/0x926984a57b10a3a5c4cfdbac04daaa0309e78932)\n            - LZ Executor: [0x9dB9Ca3305B48F196D18082e91cB64663b13d014](https://testnet.monadexplorer.com/address/0x9dB9Ca3305B48F196D18082e91cB64663b13d014)\n            - LZ Dead DVN: [0xF49d162484290EAeAd7bb8C2c7E3a6f8f52e32d6](https://testnet.monadexplorer.com/address/0xF49d162484290EAeAd7bb8C2c7E3a6f8f52e32d6)\n        </td>\n        <td>[LayerZeroScan](https://testnet.layerzeroscan.com/)</td>\n    </tr>\n\n    <tr>\n        <td>Polymer</td>\n        <td>[Docs](https://docs.polymerlabs.org/docs/build/PolymerAtaGlance)</td>\n        <td>AMB</td>\n        <td>\n            - CrossL2Prover: [0xcDa03d74DEc5B24071D1799899B2e0653C24e5Fa](https://testnet.monadexplorer.com/address/0xcDa03d74DEc5B24071D1799899B2e0653C24e5Fa)\n        </td>\n        <td>\n            [PolyScan](https://dashboard.sepolia.polymer.zone/)\n        </td>\n    </tr>\n\n    <tr>\n        <td>Wormhole</td>\n        <td>[Docs](https://wormhole.com/docs)</td>\n        <td>AMB; Token Bridge</td>\n        <td>\n            - Wormhole specific Chain ID: 48\n            - Core Contract: [0xBB73cB66C26740F31d1FabDC6b7A46a038A300dd](https://testnet.monadexplorer.com/address/0xBB73cB66C26740F31d1FabDC6b7A46a038A300dd)\n            - Token Bridge: [0xF323dcDe4d33efe83cf455F78F9F6cc656e6B659](https://testnet.monadexplorer.com/address/0xF323dcDe4d33efe83cf455F78F9F6cc656e6B659)\n            - Wormhole Relayer: [0x362fca37E45fe1096b42021b543f462D49a5C8df](https://testnet.monadexplorer.com/address/0x362fca37E45fe1096b42021b543f462D49a5C8df)\n        </td>\n        <td>[WormholeScan](https://wormholescan.io/#/?network=Testnet)</td>\n    </tr>\n    </tbody>\n</table>"
  },
  {
    "instruction": "What is covered in the 'Provider Details' section of the Developer Essentials guide?",
    "output": "### Chainlink CCIP\n\n[Chainlink](https://chain.link/) Cross-Chain Interoperability Protocol (CCIP) is the standard for cross-chain interoperability. CCIP enables developers to build secure cross-chain apps that can transfer tokens, send messages, and initiate actions across blockchains.\n\nThrough the [Cross-Chain Token (CCT)](https://blog.chain.link/ccip-v-1-5-upgrade/) standard, CCIP enables token developers to integrate new and existing tokens with CCIP in a self-serve manner in minutes, without requiring vendor lock-in, hard-coded functions, or external dependencies that may limit future optionality. CCTs support self-serve deployments, full control and ownership for developers, zero-slippage transfers, and enhanced programmability via configurable rate limits and reliability features such as Smart Execution. CCIP is powered by Chainlink decentralized oracle networks (DONs)\u2014a proven standard with a track record of securing tens of billions of dollars and enabling over $19 trillion in onchain transaction value.\n\nKey CCIP developer tools:\n- [CCIP official documentation](https://docs.chain.link/ccip): start integrating CCIP into your cross-chain application.\n- [CCIP Token Manager](https://tokenmanager.chain.link/): an intuitive front-end web interface for the deployment of new and management of existing CCTs by their developers, including no-code guided deployments and configuration tools.\n- [CCIP SDK](https://docs.chain.link/ccip/ccip-javascript-sdk): a software development kit that streamlines the process of integrating CCIP, allowing developers to use JavaScript to create a token transfer frontend dApp.\n\nContract Addresses for Monad Testnet:\n- [0x5f16e51e3Dcb255480F090157DD01bA962a53E54](https://testnet.monadexplorer.com/address/0x5f16e51e3Dcb255480F090157DD01bA962a53E54)\n\nSupported Networks:\n- Monad Testnet\n\n\n### Garden\n\n[Garden](https://garden.finance/) is transforming Bitcoin interoperability with its next-gen bridge. It is built by the renBTC team using an intents based architecture with trustless settlement, enabling cross-chain Bitcoin swaps in as little as 30 seconds with zero custody risk.\n\nIn its first year, Garden processed over $1 billion in volume\u2014proving the market's demand for seamless, cost-effective Bitcoin bridging solutions.\n\nNow, Garden is unlocking a new era of interoperability\u2014supporting non-likewise assets, external liquidity, and a wallet-friendly API\u2014to onboard the next wave of partners and users.\n\nTo get started, visit the [documentation](https://docs.garden.finance/).\n\nSupported Networks\n- Monad Testnet\n\n\n### Hyperlane\n\n[Hyperlane](https://hyperlane.xyz/) is a permissionless interoperability protocol for cross-chain communication. It enables message passing and asset transfers across different chains without relying on centralized intermediaries or requiring any permissions.\n\nTo get started, visit the [Hyperlane documentation](https://docs.hyperlane.xyz/).\n\n#### Hyperlane Explorer\n\nTo view status of your cross chain transactions, please visit the [Hyperlane Explorer](https://explorer.hyperlane.xyz/).\n\nSupported Networks:\n- Monad Testnet\n\n\n### LayerZero\n\n[LayerZero](https://layerzero.network/) is an omnichain interoperability protocol that enables cross-chain messaging. Applications built on Monad can use the LayerZero protocol to connect to 35+ supported blockchains seamlessly.\n\nTo get started with integrating LayerZero, visit the LayerZero [documentation](https://docs.layerzero.network/v1/developers/evm/evm-guides/send-messages) and provided examples on [GitHub](https://github.com/LayerZero-Labs/endpoint-v1-solidity-examples).\n\nSupported Networks:\n- Monad Testnet\n\n### Polymer\n\n[Polymer](https://www.polymerlabs.org/) is an interoperability protocol tailor made for multi-rollup applications. It places control in the hands of the builder, by combining cross-chain merkle proofs and a simple API to allow application builders to flexibly adopt Polymer's infrastructure for their own needs. Prove any action. Cross-chain.\n\n\nTo get started visit the [Polymer documentation](https://docs.polymerlabs.org/docs/build/start).\n\nSupported Networks:\n- Monad Testnet\n\n### Wormhole\n\n[Wormhole](https://wormhole.com/) is a generic messaging protocol that provides secure communication between blockchains.\n\nBy integrating Wormhole, a Monad application can access users and liquidity on > 30 chains and > 7 different platforms.\n\nSee this [quickstart](https://wormhole.com/docs/tutorials/by-product/contract-integrations/cross-chain-contracts/) to get started with integrating Wormhole in your Monad project.\n\nFor more information on integrating Wormhole, visit their [documentation](https://wormhole.com/docs/) and the [provided GitHub examples](https://github.com/wormhole-foundation/wormhole-examples).\n\nContract Addresses for Monad Testnet:\n- Core: [0xBB73cB66C26740F31d1FabDC6b7A46a038A300dd](https://testnet.monadexplorer.com/address/0xBB73cB66C26740F31d1FabDC6b7A46a038A300dd)\n- Relayer: [0x362fca37E45fe1096b42021b543f462D49a5C8df](https://testnet.monadexplorer.com/address/0x362fca37E45fe1096b42021b543f462D49a5C8df)\n\nSupported Networks:\n- Monad Testnet\n---\n\n# Debugging Onchain"
  },
  {
    "instruction": "What is covered in the 'Transaction introspection/tracing' section of the Developer Essentials guide?",
    "output": "* [Tenderly](https://dashboard.tenderly.co/explorer)\n* [EthTx Transaction Decoder](https://ethtx.info/)\n* [https://openchain.xyz/](https://openchain.xyz/)\n* [Bloxy](https://bloxy.info/)\n* [https://github.com/naddison36/tx2uml](https://github.com/naddison36/tx2uml) - OS tools for generating UML diagrams\n* [https://github.com/apeworx/evm-trace](https://github.com/apeworx/evm-trace) - tracing tools"
  },
  {
    "instruction": "What is covered in the 'Contract Decompilation' section of the Developer Essentials guide?",
    "output": "* [https://oko.palkeo.com/](https://oko.palkeo.com/): a hosted version of the [Panoramix](https://github.com/palkeo/panoramix) decompiler\n---\n\n# Indexers\n\nThe blockchain can be thought of as a list of blocks, transactions, and logs, as well as a series of global states. Indexers compute common transformations on this data to save downstream consumers the cost and complexity of doing so.\n\nThere are two main types of indexer services:\n1. **[Data for common use cases](common-data.md)**: raw data (blocks, transactions, logs, traces) and derived data for common use cases (token balances, NFT holdings, DEX trades), computed across the entire blockchain\n2. **[Indexing Frameworks](indexing-frameworks.md)** enable devleopers to build custom calculators for a specific smart contract"
  },
  {
    "instruction": "What is covered in the 'Data for common use cases' section of the Developer Essentials guide?",
    "output": "Data providers offer raw and transformed data for common use cases via API or by streaming to your local environment.\n\nRaw data includes:\n- blocks, transactions, logs, traces (potentially decoded using contract ABIs)\n\nTransformed data includes:\n- balances (native tokens, ERC20s, NFTs)\n- transfers (native tokens, ERC20s, NFTs)\n- DEX trades\n- market data\n- and more\n\nSee [Common Data](common-data.md) for a fuller list of features and providers."
  },
  {
    "instruction": "What is covered in the 'Indexing Frameworks' section of the Developer Essentials guide?",
    "output": "Smart contract indexers are custom off-chain calculators for a specific smart contract. They maintain additional off-chain state and perform additional computation. Since blockchain data is public, anyone may deploy a subgraph involving state or logs from any smart contract.\n\nSee [Indexing Frameworks](indexing-frameworks.md) for a list of features and providers.\n---\n\n# Common Data"
  },
  {
    "instruction": "What is covered in the 'Features' section of the Developer Essentials guide?",
    "output": "In order to improve developer understanding of feature coverage, we have collected the most common features offered by providers:\n\n| Feature         | Sub-Feature | Description |\n| --------------- | ----------- | ----------- |\n| **Chain data**  |             | Raw data (blocks, transactions, logs, traces) in SQL-like format. Transactions and logs may optionally be decoded based on ABI  |\n| **Balances**    | Native      | Native token holdings of an address, real-time or snapshot. May include price annotations |\n|                 | ERC20       | ERC20 holdings of an address, real-time or snapshot. May include price annotations |\n|                 | NFT         | NFT (ERC721 or ERC1155) holdings of an address, real-time or snapshot |\n| **Transfers**   | Native      | Native token transfers involving a particular address. May include price annotations |\n|                 | ERC20       | ERC20 transfers involving a particular address. May include price annotations |\n|                 | NFT         | NFT transfers involving a particular address |\n| **DEX trades**  |             | Normalized trade data across major DEXes |\n| **Market data** |             | Market data for ERC20s |\n\nBalances are nontrivial because each ERC20 and NFT collection stores its balances in contract storage. Transfers are nontrivial because they frequently occur as subroutines. Annotating with prices and normalizing across DEXes add additional convenience."
  },
  {
    "instruction": "What is covered in the 'Access models' section of the Developer Essentials guide?",
    "output": "- **APl**: Data lives on provider's servers; make queries via API\n- **Stream**: Data is replicated to your environment"
  },
  {
    "instruction": "What is covered in the 'Provider Summary' section of the Developer Essentials guide?",
    "output": "The following providers support Monad Testnet:\n\n<table>\n  <thead>\n    <tr>\n      <th>Provider</th>\n      <th>Docs</th>\n      <th>Supported services</th>\n      <th>Access model</th>\n    </tr>\n  </thead>\n  <tbody>\n    \n    <tr>\n      <td>[Alchemy](https://www.alchemy.com/)</td>\n      <td>[Docs](https://docs.alchemy.com/)</td>\n      <td>Balances: [native, ERC20](https://docs.alchemy.com/reference/token-api-quickstart) and [NFT](https://docs.alchemy.com/reference/nft-api-quickstart)<br/>\n      Transfers: [native, ERC20, and NFTs](https://docs.alchemy.com/reference/transfers-api-quickstart)<br/>\n      [Webhooks](https://docs.alchemy.com/reference/notify-api-quickstart)</td>\n      <td>API; Streaming (webhooks)</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Allium](https://www.allium.so/)</td>\n      <td>[Docs](https://docs.allium.so/)</td>\n      <td>Chain data (blocks, transactions, logs, traces, contracts) (via [Explorer](https://docs.allium.so/data-products-analytics/allium-explorer) (historical) and [Datastreams](https://docs.allium.so/realtime/kafka-blockchains-70+) (realtime) products)<br/>\n      Transfers (native, ERC20, and NFTs) (via [Developer](https://docs.allium.so/data-products-real-time/allium-developer/wallet-apis/activities) (realtime) product)</td>\n      <td>API, except streaming for Datastreams product</td>\n    </tr>\n    \n\n    \n    <tr>\n      <td>[Codex](https://www.codex.io/)</td>\n      <td>[Docs](https://docs.codex.io/reference/overview)</td>\n      <td>Token- and trading-centric data:<br/>\n      [Token](https://docs.codex.io/reference/tokens-quickstart) charts, metadata, prices, events, and detailed stats (see [dashboard](https://www.defined.fi/tokens/discover?network=mon-test))<br/>\n      [NFT](https://docs.codex.io/reference/nft-quickstart) metadata, events, and detailed stats</td>\n      <td>API</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Dune Echo](https://dune.com/echo/)</td>\n      <td>[Docs](https://docs.dune.com/echo/overview)</td>\n      <td>Transactions and logs (raw or decoded)<br/>\n      Native token and ERC20 balances</td>\n      <td>API</td>\n    </tr>\n\n    \n    <tr>\n      <td>[GoldRush](https://goldrush.dev/) (by Covalent)</td>\n      <td>[Docs](https://goldrush.dev/docs/quickstart)</td>\n      <td>Chain data: Blocks, enriched transactions and logs (raw and decoded)<br/>\n      Balances: native, ERC20, NFTs & Portfolio<br/>\n      Transactions: Full historical with decoded transfer events</td>\n      <td>API</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Goldsky](https://goldsky.com/)</td>\n      <td>[Docs](https://docs.goldsky.com/)</td>\n      <td>Chain data: blocks, enriched transactions, logs, and traces via [Mirror](https://docs.goldsky.com/mirror/introduction). [Fast scan](https://docs.goldsky.com/mirror/sources/direct-indexing#backfill-vs-fast-scan) is supported</td>\n      <td>API; Streaming</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Mobula](https://mobula.io/)</td>\n      <td>[Docs](https://docs.mobula.io/introduction)</td>\n      <td>Chain data<br/>\n      Balances: [native, ERC20](https://docs.mobula.io/rest-api-reference/endpoint/wallet-portfolio) and [NFT](https://docs.mobula.io/rest-api-reference/endpoint/wallet-nfts)<br/>\n      Transfers: [native, ERC20](https://docs.mobula.io/rest-api-reference/endpoint/wallet-transactions) and NFT<br/>\n      [DEX trades](https://docs.mobula.io/rest-api-reference/endpoint/market-trades-pair)<br/>\n      [Market data](https://docs.mobula.io/rest-api-reference/endpoint/market-data) for ERC20s</td>\n      <td>API</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Pangea](https://pangea.foundation/)</td>\n      <td>[Docs](https://docs.pangea.foundation/)</td>\n      <td>[Chain data](https://docs.pangea.foundation/chain-data/evm/blocks.html): blocks, transactions, logs<br/>\n      Transfers: [ERC20](https://docs.pangea.foundation/standard-contracts/erc20-transfers.html)<br/>\n      [DEX metadata and prices](https://docs.pangea.foundation/markets/uniswap-v3-reference.html): UniswapV3, UniswapV2, Curve</td>\n      <td>API</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Quicknode](https://www.quicknode.com/)</td>\n      <td>[Docs](https://www.quicknode.com/docs/streams/getting-started)</td>\n      <td>[Chain data](https://www.quicknode.com/docs/streams/getting-started): blocks, transactions, logs, traces (live or historical) (raw or filtered)</td>\n      <td>Streaming</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Reservoir](https://reservoir.tools/)</td>\n      <td>[Docs](https://nft.reservoir.tools/reference/overview)</td>\n      <td>Balances, transfers, trades, and market data for NFTs</td>\n      <td>API</td>\n    </tr>\n\n    \n    <tr>\n      <td>[thirdweb](https://thirdweb.com/)</td>\n      <td>[Docs](https://insight-api.thirdweb.com/guide/getting-started)</td>\n      <td>Chain data: [blocks](https://insight-api.thirdweb.com/reference#tag/blocks), [transactions](https://insight-api.thirdweb.com/guide/blueprints#transactions-blueprint), [logs](https://insight-api.thirdweb.com/guide/blueprints#events-blueprint), [contracts](https://insight-api.thirdweb.com/reference#tag/contracts)<br/>\n      [Balances](https://insight-api.thirdweb.com/guide/blueprints#tokens-blueprint): native, ERC20, NFTs<br/>\n      [NFTs](https://insight-api.thirdweb.com/reference#tag/nfts)</td>\n      <td>API</td>\n    </tr>\n    \n    <tr>\n      <td>[Unmarshal](https://unmarshal.io/)</td>\n      <td>[Docs](https://docs.unmarshal.io)</td>\n      <td>[Balances](https://docs.unmarshal.io/reference/fungibleerc20tokenbalances): ERC20 and NFT<br/>\n      [Transactions](https://docs.unmarshal.io/reference/get-v3-chain-address-address-transactions) with price annotations<br/>\n      [NFT API](https://docs.unmarshal.io/reference/get-v2-chain-address-address-nft-transactions) (transactions and metadata)</td>\n      <td>API</td>\n    </tr>\n    \n    \n    <tr>\n      <td>[Zerion](https://zerion.io/)</td>\n      <td>[Docs](https://zerion.io/api)</td>\n      <td>[Wallet info](https://developers.zerion.io/reference/wallets):<br/>\n        [Balances](https://developers.zerion.io/reference/listwalletpositions) (native, ERC20, and NFTs)<br/>\n        [Transactions](https://developers.zerion.io/reference/listwallettransactions) (multichain with prices)<br/>\n        [Portfolio](https://developers.zerion.io/reference/getwalletportfolio), [PNL](https://developers.zerion.io/reference/getwalletpnl#/) and [Historical Positions](https://developers.zerion.io/reference/getwalletchart)<br/>\n        [Notification Webhooks](https://developers.zerion.io/v1.0-subscriptions/reference/createsubscriptionwallettransactions)</td>\n      <td>API; Webhooks</td>\n    </tr>\n  </tbody>\n</table>"
  },
  {
    "instruction": "What is covered in the 'Provider Details' section of the Developer Essentials guide?",
    "output": "### Alchemy\n\n[Alchemy](https://www.alchemy.com) is a popular API provider and developer platform. Alchemy offers subgraphs as a hosted service, as well as offerings in other categories including smart wallets, AA infra, NFT APIs, Token APIs, Transfers APIs, Webhooks and RPC APIs.\n\nSupported Networks\n- Monad Testnet\n\n### Allium\n\n[Allium](https://www.allium.so/) is an Enterprise Data Platform that serves accurate, fast, and simple blockchain data. Allium offers near real-time Monad Testnet data for infrastructure needs and enriched Monad Testnet data (NFT, DEX, Decoded) for research and analytics.\n\nAllium supports data delivery to multiple [destinations](https://docs.allium.so/integrations/overview), including Snowflake, Bigquery, Databricks, and AWS S3. To get started, contact Allium [here](https://www.allium.so/contact).\n\n| Product        | Description / mechanism                                 | Monad Testnet data supported       |\n| -------------- | ------------------------------------------------------- | ----------- |\n| [Explorer](https://docs.allium.so/data-products-analytics/allium-explorer)       | Historical data (postgres/API)           | Chain data: blocks, transactions, logs, traces, contracts |\n| [Developer](https://docs.allium.so/data-products-real-time/allium-developer) | Real-time data (postgres/API)           | [Transfers](https://docs.allium.so/products/allium-developer/wallet-apis/activities) (native, ERC20, ERC721, ERC1155) |\n| [Datastreams](hhttps://docs.allium.so/data-products-real-time/allium-datastreams)   | Real-time data (streaming - Kafka, PubSub, or SNS) | Chain data: blocks, transactions, logs, traces, contracts |\n\n\nSupported Networks\n- Monad Testnet\n\n\n### Codex\n\n[Codex](https://www.codex.io/) API provides fast and accurate enriched data, meticulously structured to easily plug straight into your application.\n\nTo get started, visit the [documentation](https://docs.codex.io/reference/overview/) or sign up for an API key at [dashboard.codex.io](https://dashboard.codex.io/).\n\nSupported Networks\n- Monad Testnet\n\n\n### Dune Echo\n\n[Dune](https://dune.com/) Echo makes building multi-chain application seamless. These APIs power several of the best teams building on crypto.\n\n#### Available APIs:\n\u200b\n**Token Balances**: Access accurate and fast real time balances of native and ERC20 tokens of accounts on EVM blockchains.\n**Transactions**: Access transactions for accounts in real time across EVM blockchains.\n\nTo get started, visit the [documentation](https://docs.dune.com/echo/overview).\n\nSupported Networks\n- Monad Testnet\n\n\n### GoldRush (by Covalent)\n\n[GoldRush](https://goldrush.dev/) provides multichain data APIs and toolkits for easy web3 development across 100+ chains including Monad.\n\nGoldRush offers structured onchain data, including multichain wallet balances, full transaction histories and decoded log events, for building apps and powering AI Agents. Join hundreds of top teams that leverage GoldRush to cut down their development time and scale their multichain offerings with enterprise-grade onchain data.\n\nTo get started, visit the [documentation](https://goldrush.dev/docs/quickstart) or [sign up](https://goldrush.dev/platform/auth/register/) for an API key.\n\nSupported Networks\n- Monad Testnet\n\n\n### Goldsky\n\n[Goldsky](https://goldsky.com/) is the go-to data indexer for web3 builders, offering high-performance subgraph hosting and realtime data replication pipelines.\n\nGoldsky offers two core self-serve products that can be used independently or in conjunction to power your data stack.\n\n- **Subgraphs**: Flexible indexing with typescript, with support for webhooks and more.\n- **Mirror**: Get live blockchain data in your database or message queues with a single yaml config.\n\n\nTo get started, visit the [documentation](https://docs.goldsky.com/) or follow the [quickstart](https://docs.goldsky.com/subgraphs/guides/create-a-no-code-subgraph) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### Mobula\n\n[Mobula](https://mobula.io/) provides curated datasets for builders: market data with Octopus, wallets data, metadata with Metacore, alongside with REST, GraphSQL & SQL interfaces to query them.\n\nYou can get started playing around with the [API endpoints](https://docs.mobula.io/rest-api-reference/introduction) for free, and sign-up to the API dashboard once you need API keys (queries without API keys aren\u2019t production-ready).\n\nTo get started, visit the [documentation](https://docs.mobula.io/introduction).\n\nSupported Networks\n- Monad Testnet\n\n\n\n### Pangea\n\n[Pangea](https://pangea.foundation/)'s real-time data is ideal for anyone who needs fresh pricing data in DeFi and cross-chain.\n\nTo get started, visit the [documentation](https://docs.pangea.foundation/).\n\nSupported Networks\n- Monad Testnet\n\n\n### QuickNode\n\n[QuickNode Streams](https://www.quicknode.com/docs/streams/getting-started) is a managed, push-based blockchain streaming service that provides guaranteed delivery of both live and sequential historical data. With QuickNode Streams, you can choose to receive raw or filtered data\u2014such as specific contract events\u2014pushed directly to your stream destination (webhook, S3, Postgres, Snowflake, or Functions).\n\n- **Guaranteed Delivery**: Robust retry logic and guaranteed delivery ensures that you never miss critical events.\n- **Push-Based Streaming**: Events are pushed to your destination, eliminating the need for manual polling.\n- **Live & Sequential Historical Data**: Process new events as they occur, and seamlessly backfill older blocks in chronological order.\n- **Raw or Filtered Data**: Define filtering conditions (e.g., specific contract addresses or event signatures) using JavaScript to reduce noise and receive only the data you care about.\n- **Managed Service**: QuickNode handles all node infrastructure, allowing you to focus on building without worrying about uptime or scaling.\n\nTo get started, visit the [documentation](https://www.quicknode.com/docs/streams/getting-started) for detailed instructions on creating streams, setting filters, and choosing a delivery method. Or, check out the [quickstart guide](https://www.quicknode.com/guides/quicknode-products/streams/how-to-use-filters-with-streams) to deploy a simple webhook receiver and configure a stream in minutes.\n\nSupported Networks\n- Monad Testnet\n\n\n### Reservoir\n\n[Reservoir](https://reservoir.tools/) is a developer platform that lets you interact with the NFT market using a single toolkit. With the tools, you can build custom marketplaces, embed buying and selling into your app, and get distribution for your protocol's liquidity, among many other use cases.\n\nTo get started, visit the [documentation](https://nft.reservoir.tools/reference/dashboard-sign-up).\n\nSupported Networks\n- Monad Testnet\n\n\n### thirdweb\n\nthirdweb [Insight](https://portal.thirdweb.com/insight) is a fast, reliable and fully customizable way for developers to index, transform & query onchain data across 30+ chains. Insight includes out-of-the-box APIs for transactions, events, tokens. Developers can also define custom API schemas, or blueprints, without the need for ABIs, decoding, RPC, or web3 knowledge to fetch blockchain data.\n\nthirdweb Insight can be used to fetch:\n* all assets (ERC20, ERC721, ERC115) for a given wallet address\n* all sales of skins on your in-game marketplace\n* monthly protocol fees in the last 12 months\n* the total cost of all accounts created using ERC-4337\n* metadata for a given token (ERC20, ERC721, ERC115)\n* daily active wallets for your application or game\n* and so much more\n\nTo get started, sign up for a [free thirdweb account](https://thirdweb.com/team) and visit the [thirdweb Insight documentation](https://portal.thirdweb.com/insight/get-started)\n\n\n### Unmarshal\n\n[Unmarshal](https://unmarshal.io/) is a leading decentralized multi-chain data network, enabling Web3 projects to access accurate, real-time blockchain data across 55+ chains (including Monad Testnet). \n\nLeveraging AI-driven solutions, Unmarshal enhances data accessibility and insights for RWA, DePIN, AI Agents, DeFi, NFT, and GameFi platforms. Through robust APIs, notification services, and no-code indexers, it empowers dApps to deliver seamless user experiences while ensuring transparency, scalability, and innovation at the forefront of Web3 advancements.\n\nTo get started, visit the [documentation](https://docs.unmarshal.io).\n\nReach out at support@unmarshal.io\n\nSupported Networks\n- Monad Testnet\n\n\n### Zerion\n\nThe [Zerion API](https://zerion.io/api) can be used to build feature-rich web3 apps, wallets, and protocols with ease. Across all major blockchains, you can access wallets, assets, and chain data for web3 portfolios. Zerion's infrastructure supports all major chains!\n\nTo get started, visit the [documentation](https://zerion.io/api).\n\nSupported Networks\n- Monad Testnet\n---\n\n# Indexing Frameworks"
  },
  {
    "instruction": "What is covered in the 'Background' section of the Developer Essentials guide?",
    "output": "**Smart contract indexers** are off-chain calculators that compute additional metrics specific to one smart contract. Calculators can be thought of as extensions to a smart contract that do additional off-chain computation and maintain additional off-chain state.\n\n*Simple example:* the [UniswapV2Pair contract](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol) maintains minimal state for the pool and emits `Mint`, `Burn`, and `Swap` events. If we wanted to know the cumulative number and volume of swaps on the pair, we could write and deploy a custom indexer instead of adding additional state variables and computation to the contract.\n\nSmart contract indexers typically produce object schemas using the [GraphQL](https://graphql.org/) schema language.\n\nSmart contract indexing services usually provide a hosted service so that users can deploy their indexers without having to run their own infrastructure."
  },
  {
    "instruction": "What is covered in the 'Provider Summary' section of the Developer Essentials guide?",
    "output": "The following providers support Monad Testnet:\n\n<table>\n  <thead>\n    <tr>\n      <th>Provider</th>\n      <th>Docs</th>\n      <th>Language</th>\n      <th>Framework</th>\n      <th>Known for</th>\n      <th>Hosted service</th>\n      <th>Decen- tralized hosted service</th>\n      <th>Onchain & offchain data</th>\n      <th>Web- socket subscr- iptions</th>\n      <th>Query layer</th>\n    </tr>\n  </thead>\n  <tbody>\n    \n    <tr>\n      <td>[Alchemy](https://www.alchemy.com/subgraphs)</td>\n      <td>[Docs](https://docs.alchemy.com/reference/subgraphs-quickstart)</td>\n      <td>Assembly-Script</td>\n      <td>[subgraph](https://github.com/graphprotocol/graph-node)</td>\n      <td>Uptime guarantee</td>\n      <td>\u2705</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>GraphQL</td>\n    </tr>\n\n    \n    <tr>\n      <td>[DipDup](https://dipdup.io/)</td>\n      <td>[Docs](https://dipdup.io/docs/quickstart-evm)</td>\n      <td>Python</td>\n      <td>[dipdup](https://github.com/dipdup-io/dipdup)</td>\n      <td>Python development</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>\u2705</td>\n      <td>\u2705</td>\n      <td>GraphQL</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Envio](https://envio.dev/)</td>\n      <td>[Docs](https://docs.envio.dev/docs/HyperIndex/overview)</td>\n      <td>JavaScript, TypeScript, Rescript</td>\n      <td>[HyperIndex](https://github.com/enviodev/hyperindex)</td>\n      <td>Performance and scale</td> \n      <td>\u2705</td>\n      <td>\u274c</td>\n      <td>\u2705</td>\n      <td>\u2705</td>\n      <td>GraphQL</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Ghost](https://tryghost.xyz/)</td>\n      <td>[Docs](https://docs.tryghost.xyz/ghostgraph/overview)</td>\n      <td>Solidity</td>\n      <td>GhostGraph</td>\n      <td>Solidity development</td>\n      <td>\u2705</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>GraphQL</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Goldsky](https://goldsky.com/)</td>\n      <td>[Docs](https://docs.goldsky.com/)</td>\n      <td>Assembly- Script</td>\n      <td>[subgraph](https://github.com/graphprotocol/graph-node)</td>\n      <td></td>\n      <td>\u2705</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>Custom GraphQL</td>\n    </tr>\n\n    \n    <tr>\n      <td>[Sentio](https://www.sentio.xyz/)</td>\n      <td>[Docs](https://docs.sentio.xyz/docs/quickstart)</td>\n      <td>JavaScript, TypeScript</td>\n      <td>[sentio-sdk](https://github.com/sentioxyz/sentio-sdk)</td>\n      <td>Performance; integrated alerting and visualization</td>\n      <td>\u2705</td>\n      <td>\u274c</td>\n      <td>\u2705</td>\n      <td>\u274c</td>\n      <td>GraphQL & SQL</td>\n    </tr>\n        \n    \n    <tr>\n      <td>[SQD](https://sqd.ai/)</td>\n      <td>[Docs](https://docs.sqd.ai)</td>\n      <td>TypeScript</td>\n      <td>[squid-sdk](https://github.com/subsquid/squid-sdk)</td>\n      <td>Performance, decentralization</td>\n      <td>\u2705</td>\n      <td>Partial[^1]</td>\n      <td>\u2705</td>\n      <td>\u2705</td>\n      <td>GraphQL</td>\n    </tr>\n\n    \n    <tr>\n      <td>[SubQuery](https://subquery.network/)</td>\n      <td>[Docs](https://academy.subquery.network/)</td>\n      <td>TypeScript</td>\n      <td>[subql](https://github.com/subquery/subql)</td>\n      <td>Decentral- ization</td>\n      <td>\u2705</td>\n      <td>\u2705</td>\n      <td>\u2705</td>\n      <td>\u274c</td>\n      <td>GraphQL</td>\n    </tr>\n\n    \n    <tr>\n      <td>[The Graph](https://thegraph.com/)</td>\n      <td>[Docs](https://thegraph.com/docs/en/subgraphs/quick-start/)</td>\n      <td>Assembly- Script</td>\n      <td>[subgraph](https://github.com/graphprotocol/graph-node)</td>\n      <td>The original indexer</td>\n      <td>\u2705</td>\n      <td>\u2705</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>Custom GraphQL</td>\n    </tr>\n  </tbody>\n</table>\n\n[^1]: SQD hosted service is semi-decentralized: the data lake is decentralized, but indexers run on proprietary infra."
  },
  {
    "instruction": "What is covered in the 'Provider Details' section of the Developer Essentials guide?",
    "output": "### Alchemy\n\n[Alchemy](https://www.alchemy.com/) is a popular API provider and developer platform. Alchemy offers subgraphs as a hosted service, as well as offerings in other categories including smart wallets, AA infra, NFT and token APIs, and RPC APIs.\n\nSupported Networks\n- Monad Testnet\n\n\n### DipDup\n\n[DipDup](https://dipdup.io/) is a Python framework for building smart contract indexers.\n\nTo get started, visit the [documentation](https://dipdup.io/docs/quickstart-evm).\n\nSupported Networks\n- Monad Testnet\n\n\n### Envio\n\n[Envio](https://envio.dev/) is a full-featured data indexing solution that provides application developers with a seamless and efficient way to index and aggregate real-time and historical blockchain data for Monad Testnet. The indexed data is easily accessible through custom GraphQL queries, providing developers with the flexibility and power to retrieve specific information.\n\n[Envio HyperSync](https://docs.envio.dev/docs/HyperIndex/hypersync) is an indexed layer of the Monad Testnet blockchain for the hyper-speed syncing of historical data (JSON-RPC bypass). What would usually take hours to sync ~100,000 events can now be done in the order of less than a minute.\n\nDesigned to optimize the user experience, Envio offers automatic code generation, flexible language support, multi-chain data aggregation, and a reliable, cost-effective hosted service.\n\n\nTo get started, visit the [documentation](https://docs.envio.dev/docs/HyperIndex/overview) or follow the [quickstart](https://docs.envio.dev/docs/HyperIndex/contract-import) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### Ghost\n\nWith [GhostGraph](https://tryghost.xyz/graph), you can write your indexers in the same language as your contracts: Solidity. This means less context switching and faster time to market.\n\nTo get started, visit the [documentation](https://docs.tryghost.xyz/ghostgraph/overview/) or check out the [tutorial](../../guides/indexers/ghost.md).\n\nServices supported:\n- GhostGraph\n\nSupported Networks\n- Monad Testnet\n\n\n### Goldsky\n\n[Goldsky](https://goldsky.com/) is the go-to data indexer for web3 builders, offering high-performance subgraph hosting and realtime data replication pipelines.\n\nGoldsky offers two core self-serve products that can be used independently or in conjunction to power your data stack.\n\n- **Subgraphs**: Flexible indexing with typescript, with support for webhooks and more.\n- **Mirror**: Get live blockchain data in your database or message queues with a single yaml config.\n\n\nTo get started, visit the [documentation](https://docs.goldsky.com/) or follow the [quickstart](https://docs.goldsky.com/subgraphs/guides/create-a-no-code-subgraph) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### Sentio\n\n[Sentio](https://www.sentio.xyz/) offers blazing-fast native processors and seamless subgraph hosting on Monad. With powerful database capabilities, intuitive dashboards, and comprehensive API functionalities, Sentio is built to provide an exceptional developer experience.\n\nTo get started, check out the [docs](https://docs.sentio.xyz/docs/supported-networks#monad) or visit the [quickstart](https://docs.sentio.xyz/docs/quickstart) guide.\n\nSupported Networks\n- Monad Testnet\n\n\n### SQD\n\n[SQD](https://sqd.ai/) enables permissionless, cost-efficient access to petabytes of high-value Web3 data. \n\nSQD is a decentralized hyper-scalable data platform optimized for providing efficient, permissionless access to large volumes of data. It currently serves historical on-chain data, including event logs, transaction receipts, traces, and per-transaction state diffs.\n\nTo get started, visit the [documentation](https://docs.sqd.ai) or see this [quickstart](https://docs.sqd.ai/sdk/quickstart/) with [examples](https://docs.sqd.ai/sdk/examples) on how to easily create subgraphs via Subsquid.\n\nSupported Networks\n- Monad Testnet\n\n\n### SubQuery\n\n[SubQuery](https://subquery.network/) is a leading blockchain data indexer that provides developers with fast, flexible, universal, open source and decentralised APIs for web3 projects. SubQuery SDK allows developers to get rich indexed data and build intuitive and immersive decentralised applications in a faster and more efficient way. SubQuery supports many ecosystems including Monad, Ethereum, Cosmos, Near, Polygon, Polkadot, Algorand, and more.\n\nOne of SubQuery's advantages is the ability to aggregate data not only within a chain but across multiple blockchains all within a single project. This allows the creation of feature-rich dashboard analytics and multi-chain block scanners.\n\n#### Useful resources:\n\n- [SubQuery Academy (Documentation)](https://academy.subquery.network/)\n- [Monad Testnet Starter](https://github.com/subquery/ethereum-subql-starter/tree/main/Monad/monad-testnet-starter)\n- [Monad Testnet Quick Start Guide](https://academy.subquery.network/indexer/quickstart/quickstart_chains/monad.html)\n\nFor technical questions and support reach out to us `start@subquery.network`\n\nSupported Networks\n- Monad Testnet\n\n\n### The Graph\n\n[The Graph](https://thegraph.com/) is an indexing protocol that provides an easy way to query blockchain data through APIs known as subgraphs.\n\nWith The Graph, you can benefit from:\n\n- **Decentralized Indexing**: Enables indexing blockchain data through multiple indexers, thus eliminating any single point of failure\n- **GraphQL Queries**: Provides a powerful GraphQL interface for querying indexed data, making data retrieval super simple.\n- **Customization**: Define your own logic for transforming & storing blockchain data. Reuse subgraphs published by other developers on The Graph Network.\n\nFollow this [quick-start](https://thegraph.com/docs/en/subgraphs/quick-start/) guide to create, deploy, and query a subgraph within 5 minutes.\n\nSupported Networks\n- Monad Testnet\n\n---\n\n# Local Nodes\n\nDevelopers often find it helpful to be able to run a 1-node Ethereum network with modified parameters to test interaction with the blockchain:\n\n-   [Anvil](https://github.com/foundry-rs/foundry/tree/master/crates/anvil) is a local Ethereum node packaged in the Foundry toolkit\n-   [Hardhat Network](https://hardhat.org/hardhat-network/docs/overview) is a local Ethereum node packaged in the Hardhat toolkit\n\nInstallation is most easily done as part of installing the respective toolkit, described in the next section.\n---\n\n# Oracles\n\nOracles make off-chain data accessible on chain."
  },
  {
    "instruction": "What is covered in the 'Definitions' section of the Developer Essentials guide?",
    "output": "| Term                             | Description                                                          |\n| -------------------------------- | -------------------------------------------------------------------- |\n| Push oracle                      | Provider regularly pushes price data to the oracle contract on chain |\n| Pull (on-demand) oracle          | User triggers price data update while calling a smart contract       |\n| Custom oracle                    | A custom calculator                                                  |\n| VRF (Verifiable Random Function) | Provides random numbers on chain                                     |"
  },
  {
    "instruction": "What is covered in the 'Provider Summary' section of the Developer Essentials guide?",
    "output": "The following providers support Monad Testnet:\n\n<table>\n  <tr>\n    <th>Provider</th>\n    <th>Docs</th>\n    <th>Contract addresses</th>\n    <th>Live data</th>\n    <th>Support notes</th>\n  </tr>\n\n  \n  <tr>\n    <td>[Blocksense](https://blocksense.network/)</td>\n    <td>[Docs](https://docs.blocksense.network/)</td>\n    <td>Separate address per pair:<br />\n      WMON/USDT: [0x23eBeaDD97b4211525bcCe79014Dc68DD7C45F04](https://testnet.monadexplorer.com/address/0x23eBeaDD97b4211525bcCe79014Dc68DD7C45F04) <br />\n      WBTC: [0x0f970fB74F6030ebbf8Ede3a701f29544Ef0dcca](https://testnet.monadexplorer.com/address/0x0f970fB74F6030ebbf8Ede3a701f29544Ef0dcca) <br />\n      USDT: [0x23b7c30C0a85dbb1153FC0A087838B95aE20797A](https://testnet.monadexplorer.com/address/0x23b7c30C0a85dbb1153FC0A087838B95aE20797A) <br />\n      USDC: [0xc4675f86BE0bE2bf3c9Ac2829d9CeD6F6d36465A](https://testnet.monadexplorer.com/address/0xc4675f86BE0bE2bf3c9Ac2829d9CeD6F6d36465A) <br />\n      DAI: [0x1fb84Cb39e818816E4Ea5498A36937Fd9FeaC0d0](https://testnet.monadexplorer.com/address/0x1fb84Cb39e818816E4Ea5498A36937Fd9FeaC0d0)</td>\n    <td></td>\n    <td>Push oracle;<br/>\n    Custom oracles</td>\n  </tr>\n\n  \n  <tr>\n    <td>[Chainlink](https://chain.link/)</td>\n    <td>[Docs](https://docs.chain.link/)</td>\n    <td>Data stream verifier proxy address: [0xC539169910DE08D237Df0d73BcDa9074c787A4a1](https://testnet.monadexplorer.com/address/0xC539169910DE08D237Df0d73BcDa9074c787A4a1)</td>\n    <td></td>\n    <td>Pull oracle</td>\n  </tr>\n\n  \n  <tr>\n    <td>[ChainSight](https://chainsight.network/)</td>\n    <td>[Docs](https://docs.chainsight.network/)</td>\n    <td></td>\n    <td></td>\n    <td>Custom oracles. Migrating to a new version</td>\n  </tr>\n\n  \n  <tr>\n    <td>[Chronicle](https://chroniclelabs.org/)</td>\n    <td>[Docs](https://docs.chroniclelabs.org/)</td>\n    <td>[Address reference](https://docs.chroniclelabs.org/Developers/testnet)</td>\n    <td>[Dashboard](https://chroniclelabs.org/dashboard/oracles?blockchain=MON-TESTNET) (toggle dev mode)</td>\n    <td>Push oracle; custom oracles</td>\n  </tr>\n\n  \n  <tr>\n    <td>[Gelato VRF](https://docs.gelato.network/web3-services/vrf/quick-start)</td>\n    <td>[Docs](https://docs.gelato.network/web3-services/vrf/quick-start)</td>\n    <td></td>\n    <td></td>\n    <td>VRF</td>\n  </tr>\n\n  \n  <tr>\n    <td>[Orochi](https://www.orochi.network/)</td>\n    <td>[Docs](https://docs.orochi.network/)</td>\n    <td>[Orocle](https://docs.orochi.network/Orocle/testnet) [oracle] addresses<br/>\n      [Orand](https://docs.orochi.network/Orand/testnet) [VRF] addresses</td>\n    <td></td>\n    <td>[zkOracle](https://docs.orochi.network/Orocle/introduction);<br/>\n    [VRF](https://docs.orochi.network/Orand/introduction)</td>\n  </tr>\n\n  \n  <tr>\n    <td>[Pyth](https://www.pyth.network/)</td>\n    <td>[Docs](https://docs.pyth.network/)</td>\n    <td>Price feeds: [0x2880aB155794e7179c9eE2e38200202908C17B43](https://testnet.monadexplorer.com/address/0x2880aB155794e7179c9eE2e38200202908C17B43)<br/><br/>\n    Beta price feeds (incl MON/USDC): [0xad2B52D2af1a9bD5c561894Cdd84f7505e1CD0B5](https://testnet.monadexplorer.com/address/0xad2B52D2af1a9bD5c561894Cdd84f7505e1CD0B5)<br/><br/>\n    Entropy: [0x36825bf3Fbdf5a29E2d5148bfe7Dcf7B5639e320](https://testnet.monadexplorer.com/address/0x36825bf3Fbdf5a29E2d5148bfe7Dcf7B5639e320)</td>\n    <td>[Live data](https://www.pyth.network/price-feeds)<br/><br/>\n    [Beta live data](https://www.pyth.network/developers/price-feed-ids#beta) (includes MON/USDC)</td>\n    <td>[Pull oracle](https://docs.pyth.network/price-feeds/pull-updates);<br/>\n    [VRF](https://docs.pyth.network/entropy)</td>\n  </tr>\n\n  \n  <tr>\n    <td>[Redstone](https://www.redstone.finance/)</td>\n    <td>[Docs](https://docs.redstone.finance/)</td>\n    <td>Push oracle [addresses](https://app.redstone.finance/app/feeds/?networks=10143)<br/>\n    Update conditions for all: 0.5% deviation & 6h heartbeat</td>\n    <td>[Live data](https://app.redstone.finance/app/tokens/)</td>\n    <td>[Push oracle](https://app.redstone.finance/app/feeds/?networks=10143);<br/>\n    [pull oracle](https://app.redstone.finance/app/pull-model/redstone-primary-prod)</td>\n  </tr>\n\n  \n  <tr>\n    <td>[Stork](https://stork.network/)</td>\n    <td>[Docs](https://docs.stork.network/)</td>\n    <td>Pull oracle (includes MON/USD): [0xacC0a0cF13571d30B4b8637996F5D6D774d4fd62](https://testnet.monadexplorer.com/address/0xacC0a0cF13571d30B4b8637996F5D6D774d4fd62)<br/>\n    [Addresses](https://docs.stork.network/resources/contract-addresses/evm); [APIs](https://docs.stork.network/api-reference/contract-apis/evm); [Asset ID Registry](https://docs.stork.network/resources/asset-id-registry)</td>\n    <td></td>\n    <td>[Pull oracle](https://docs.stork.network/introduction/core-concepts)</td>\n  </tr>\n\n  \n  <tr>\n    <td>[Supra](https://supra.com/)</td>\n    <td>[Docs](https://docs.supra.com/)</td>\n    <td>Push oracle: [0x6Cd59830AAD978446e6cc7f6cc173aF7656Fb917](https://testnet.monadexplorer.com/address/0x6Cd59830AAD978446e6cc7f6cc173aF7656Fb917)<br/>\n      (5% deviation threshold & 1h update frequency;<br/>\n      Supported pairs: BTC/USDT, SOL/USDT, ETH/USDT)<br/><br/>\n      Pull oracle: [0x443A0f4Da5d2fdC47de3eeD45Af41d399F0E5702](https://testnet.monadexplorer.com/address/0x443A0f4Da5d2fdC47de3eeD45Af41d399F0E5702)<br/><br/>\n      dVRF: [0x6D46C098996AD584c9C40D6b4771680f54cE3726](https://testnet.monadexplorer.com/address/0x6D46C098996AD584c9C40D6b4771680f54cE3726)</td>\n    <td>[Live data](https://supra.com/data)</td>\n    <td>[Push oracle](https://docs.supra.com/oracles/data-feeds/push-oracle);<br/>\n      [Pull oracle](https://docs.supra.com/oracles/data-feeds/pull-oracle);<br/>\n      [dVRF](https://docs.supra.com/oracles/dvrf)</td>\n  </tr>\n\n  \n  <tr>\n    <td>[Switchboard](https://switchboard.xyz/)</td>\n    <td>[Docs](https://docs.switchboard.xyz/)</td>\n    <td>Pull oracle: [0x33A5066f65f66161bEb3f827A3e40fce7d7A2e6C](https://testnet.monadexplorer.com/address/0x33A5066f65f66161bEb3f827A3e40fce7d7A2e6C)<br/><br/>\n    More info: [Deployments](https://docs.switchboard.xyz/product-documentation/data-feeds/evm)</td>\n    <td>[Live data](https://ondemand.switchboard.xyz/monad/testnet)</td>\n    <td>[Pull oracle](https://docs.switchboard.xyz/product-documentation/data-feeds/evm);<br/>\n    [Oracle aggregator](https://docs.switchboard.xyz/product-documentation/aggregator);<br/>\n    [VRF](https://docs.switchboard.xyz/product-documentation/randomness)</td>\n  </tr>\n</table>"
  },
  {
    "instruction": "What is covered in the 'Provider Details' section of the Developer Essentials guide?",
    "output": "### Blocksense\n\n[Blocksense](https://blocksense.network/)'s programmable oracles let you access high performance price feeds plus any custom internet data, using familiar DeFi-compatible interfaces, all while enjoying super low costs powered by ZK technology.\n\nTo get started, check out the [documentation](https://docs.blocksense.network/) or reach out to the team on [Discord](https://discord.com/invite/mYujUXwrMr).\n\nSupported Networks:\n- Monad Testnet\n\n\n### Chainlink\n\n[Chainlink](https://chain.link/) Data Streams deliver low-latency market data offchain, which can be verified onchain. This approach provides decentralized applications (dApps) with on-demand access to high-frequency market data backed by decentralized, fault-tolerant, and transparent infrastructure.\n\nTraditional push-based oracles update onchain data at set intervals or when certain price thresholds are met. In contrast, Chainlink Data Streams uses a pull-based design that preserves trust-minimization with onchain verification.\n\nTo get started, check out the [documentation](https://docs.chain.link/data-streams).\n\nSupported Networks:\n- Monad Testnet\n\n\n\n### ChainSight\n\n[Chainsight](https://chainsight.network/) redefines oracles with no-code tools, lowering costs, reducing single-operator risks, and driving scalable, open innovation.\n\nTo get started, check out the [documentation](https://docs.chainsight.network/).\n\nSupported Networks:\n- Monad Testnet\n\n\n### Chronicle\n\nChronicle's decentralized oracle network was originally built within MakerDAO for the development of DAI and is now available to builders on Monad.\n\n- **Data Feeds**: Builders can choose from 90+ data feeds, including crypto assets, yield rates, and RWAs. Chronicle's data is sourced via custom-built data models, only utilizing Tier 1 sources.\n- **Transparency & Integrity**: Chronicle's oracle network is fully transparent and verifiable via the [Chronicle dashboard](https://chroniclelabs.org/dashboard/oracles?blockchain=MON-TESTNET). Users can cryptographically challenge the integrity of every oracle update using the 'verify' feature. Data is independently sourced by a [community of Validators](https://chroniclelabs.org/validators) including Gitcoin, Etherscan, Infura, DeFi Saver, and MakerDAO.\n- **Gas Efficiency**: Pioneering the Schnorr-based oracle architecture, Chronicle's oracles use 60-80% less gas per update than other oracle providers. This lowest cost per update allows Push oracle updates to be made more frequently, enabling granular data reporting.\n- Every oracle implementation is customized to fit your needs. Implement one of our existing data models or contact Chronicle to develop custom oracle data feeds via [Discord](https://discord.gg/CjgvJ9EspJ).\n\nDevelopers can dive deeper into Chronicle Protocol's architecture and unique design choices via the [docs](https://docs.chroniclelabs.org/).\n\nSupported Networks:\n- Monad Testnet\n\n\n\n### Gelato VRF\n\n[Gelato VRF](https://docs.gelato.network/web3-services/vrf) (Verifiable Random Function) provides a unique system offering trustable randomness on Monad Testnet.\n\nSee [this](https://docs.gelato.network/web3-services/vrf/quick-start) guide to learn how to get started with Gelato VRF.\n\nSupported Networks:\n- Monad Testnet\n\n### Orochi\n\n[Orochi Network](https://www.orochi.network/) is the world\u2019s first Verifiable Data Infrastructure, addressing scalability, privacy, and data integrity challenges.\n\nTo get started, visit the [Orochi documentation](https://docs.orochi.network/orochi-network/orand-orocle.html).\n\nSupported Networks:\n- Monad Testnet\n\n\n### Pyth\nThe [Pyth Network](https://www.pyth.network/) is one of the largest first-party oracle networks, delivering real-time data across a number of chains. Pyth introduces a low-latency [pull oracle](https://docs.pyth.network/price-feeds/pull-updates) design. Data providers push price updates to [Pythnet](https://docs.pyth.network/price-feeds/how-pyth-works/pythnet) every 400 ms. Users pull aggregated prices from Pythnet onto Monad when needed, enabling everyone in the onchain environment to access that data point most efficiently.\n\nPyth Price Feeds features:\n- 400ms latency\n- [First-party](https://www.pyth.network/publishers) data sourced directly from financial institutions\n- [Price feeds](https://www.pyth.network/developers/price-feed-ids) ranging from crypto, stocks, FX, and metals\n  - See also: [beta price feeds](https://www.pyth.network/developers/price-feed-ids#beta) (testnet MON/USD is a beta price feed)\n- Available on [many](https://docs.pyth.network/price-feeds/contract-addresses) major chains\n\nContract Addresses for Monad Testnet:\n- Price feeds: [0x2880aB155794e7179c9eE2e38200202908C17B43](https://testnet.monadexplorer.com/address/0x2880aB155794e7179c9eE2e38200202908C17B43)\n  - Beta price feeds: [0xad2B52D2af1a9bD5c561894Cdd84f7505e1CD0B5](https://testnet.monadexplorer.com/address/0xad2B52D2af1a9bD5c561894Cdd84f7505e1CD0B5) (testnet MON/USD is a beta price feed)\n- Entropy: [0x36825bf3Fbdf5a29E2d5148bfe7Dcf7B5639e320](https://testnet.monadexplorer.com/address/0x36825bf3Fbdf5a29E2d5148bfe7Dcf7B5639e320)\n\nSupported Networks:\n- Monad Testnet\n\n:::note\nThe testnet `MON/USD` price feed is currently a beta feed on Pyth Network. To use the MON/USD feed, integrate the [beta price feed](https://testnet.monadexplorer.com/address/0xad2B52D2af1a9bD5c561894Cdd84f7505e1CD0B5) contract instead of the primary price feed contract.\n\nTo get the MON/USD price feed offchain, use the beta hermes endpoint: [https://hermes-beta.pyth.network](https://hermes-beta.pyth.network)\n:::\n\n### Redstone\n\n[RedStone](https://www.redstone.finance/) is the fastest-growing modular oracle, specializing in yield-bearing collateral for lending markets, such as LSTs, LRTs and BTCFi.\n\nTo get started, visit the [Redstone documentation](https://docs.redstone.finance/docs/introduction).\n\nSupported Networks:\n- Monad Testnet\n\n\n### Stork\n\n[Stork](https://stork.network/) is an oracle protocol that enables ultra low latency connections between data providers and both on and off-chain applications. The most common use-case for Stork is pulling and consuming market data in the form of real time price feeds for DeFi.\n\nStork is implemented as a [pull oracle](https://docs.stork.network/introduction/core-concepts#docs-internal-guid-4b312e7b-7fff-1147-c04b-bbaadec1a82a). Stork continuously aggregates, verifies, and audits data from trusted publishers, and makes that aggregated data available at sub-second latency and frequency. This data can then be pulled into any on or off-chain application as often as needed.\n\nTo learn more about how Stork works, visit [Core Concepts](https://docs.stork.network/introduction/core-concepts) and [How It Works](https://docs.stork.network/introduction/how-it-works).\n\nSupported Networks:\n- Monad Testnet\n\n### Supra\n\n[Supra](https://supra.com) provides VRF and decentralized oracle price feeds (push and pull based) that can be used for onchain and offchain use-cases such as spot and perpetual DEXes, lending protocols, and payments protocols. \n\nTo get started, visit the [Supra documentation](https://docs.supra.com)\n\nSupported Networks:\n- Monad Testnet\n\n### Switchboard\n\n[Switchboard](https://switchboard.xyz/) is a customizable oracle network and oracle aggregator.\n\nTo get started, visit the [Switchboard documentation](https://docs.switchboard.xyz/introduction).\n\nSupported Networks:\n- Monad Testnet\n---\n\n# RPC Providers\n\nA number of RPC providers are supporting Monad testnet. \n\nSee also: [API reference](/reference/json-rpc)"
  },
  {
    "instruction": "What is covered in the 'Alchemy' section of the Developer Essentials guide?",
    "output": "[Alchemy](https://www.alchemy.com/) is a popular API provider and developer platform. Its robust, free tier offers access to JSON-RPC APIs, and hosted testnet nodes for Monad Testnet.\n\nSupported Networks \n- Monad Testnet"
  },
  {
    "instruction": "What is covered in the 'Blockdaemon' section of the Developer Essentials guide?",
    "output": "[Blockdaemon](https://www.blockdaemon.com/) provides enterprise-grade web3 infrastructure, including dedicated nodes, APIs, staking, liquid staking, MPC wallets, and more.\n\nTo get started, visit the [Blockdaemon documentation](https://docs.blockdaemon.com/).\n\nSupported Networks\n- Monad Testnet"
  },
  {
    "instruction": "What is covered in the 'dRPC' section of the Developer Essentials guide?",
    "output": "[dRPC](https://drpc.org/) is an off-chain routing protocol for delivering reliable API infrastructure leveraging a distributed network of nodes.\n\nTo get started, visit the [dRPC documentation](https://drpc.org/docs).\n\nSupported Networks\n- Monad Testnet"
  },
  {
    "instruction": "What is covered in the 'Envio' section of the Developer Essentials guide?",
    "output": "[Envio](https://envio.dev) has a free read only RPC that supports a subset of data intensive [methods](https://docs.envio.dev/docs/HyperSync/overview-hyperrpc#supported-methods), Envio's purpose built rust node supports historical data allowing you to query past 10,000 blocks into the past.\n\nTo get started, visit the [Envio documentation](https://docs.envio.dev/docs/HyperSync/overview-hyperrpc)\n\nSupported Networks\n- Monad Testnet"
  },
  {
    "instruction": "What is covered in the 'QuickNode' section of the Developer Essentials guide?",
    "output": "[QuickNode](https://www.quicknode.com/) offers access to their [Core RPC API](https://www.quicknode.com/core-api) for Monad Testnet.\n\n:::tip\nQuickNode is offering discounts for projects building on Monad, more details [here](https://quicknode.notion.site/QuickNode-Benefits-for-Monad-Developers-18215a82e84c80e6a322d2174d6a1a26)!\n:::\n\nSupported Networks\n- Monad Testnet"
  },
  {
    "instruction": "What is covered in the 'Thirdweb' section of the Developer Essentials guide?",
    "output": "[thirdweb](https://thirdweb.com/)'s [RPC Edge](https://portal.thirdweb.com/infrastructure/rpc-edge/overview) provides an RPC endpoint for developers building on Monad.\n\nTo get started, visit the [Thirdweb RPC Edge documentation](https://portal.thirdweb.com/infrastructure/rpc-edge/overview).\n\nSupported Networks\n- Monad Testnet"
  },
  {
    "instruction": "What is covered in the 'Triton One' section of the Developer Essentials guide?",
    "output": "[Triton One](https://triton.one/triton-rpc/) provides a robust RPC service optimized for front-end GUIs across multiple blockchains including Monad. Triton RPC weeds out the bots so your users can actually use your product reliably, at scale.\n\nSupported Networks\n- Monad Testnet\n---\n\n# Toolkits\n\nDevelopers often find it helpful to build their project in the context of a broader framework that organizes external dependencies (i.e. package management), organizes unit and integration tests, defines a deployment procedure (against local nodes, testnet, and mainnet), records gas costs, etc.\n\nHere are the two most popular toolkits for Solidity development:\n\n-   [Foundry](https://book.getfoundry.sh/) is a Solidity framework for both development and testing. Foundry manages your dependencies, compiles your project, runs tests, deploys, and lets you interact with the chain from the command-line and via Solidity scripts. Foundry users typically write their smart contracts and tests in the Solidity language.\n-   [Hardhat](https://hardhat.org/docs) is a Solidity development framework paired with a JavaScript testing framework. It allows for similar functionality as Foundry, and was the dominant toolchain for EVM developers prior to Foundry.\n---\n\n# Wallets\n\nA number of wallets are compatible with Monad testnet."
  },
  {
    "instruction": "What is covered in the 'Provider Summary' section of the Developer Essentials guide?",
    "output": "<table>\n  <thead>\n    <tr>\n      <th>Wallet</th>\n      <th>Available on</th>\n      <th>Blinks Support</th>\n      <th>Autodetect Tokens and NFTs</th>\n      <th>AA</th>\n      <th>Other Features</th>\n    </tr>\n  </thead>\n  <tbody>\n    \n    <tr>\n      <td>[Phantom](https://phantom.com)</td>\n      <td>Desktop, Mobile</td>\n      <td>\u2705</td>\n      <td>Tokens, NFTs</td>\n      <td>\u274c</td>\n      <td>NFT support, DApp browser, Token swaps, cross-chain swaps, staking options</td>\n    </tr>\n    \n    <tr>\n      <td>[Backpack](https://backpack.app)</td>\n      <td>Desktop, Mobile</td>\n      <td>\u2705</td>\n      <td>Tokens, NFTs</td>\n      <td>\u274c</td>\n      <td>DApp browser, Built-in exchange, Futures trading, Portfolio tracking</td>\n    </tr>\n    \n    <tr>\n      <td>[Bitget Wallet](https://web3.bitget.com/en?source=bitget)</td>\n      <td>Desktop, Mobile</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>DApp browser, NFT Market, DApp Browser, and Launchpad</td>\n    </tr>\n    \n    <tr>\n      <td>[HaHa](https://www.haha.me)</td>\n      <td>Desktop, Mobile</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>\u2705</td>\n      <td>DeFi integrations, AA, Monad Native, trading, hardware wallet support</td>\n    </tr>\n    \n    <tr>\n      <td>[Leap](https://www.leapwallet.io)</td>\n      <td>Desktop, Mobile</td>\n      <td>\u274c</td>\n      <td>NFTs</td>\n      <td>\u274c</td>\n      <td>Portfolio tracking, Open source, Cross-chain swaps, Staking</td>\n    </tr>\n    \n    <tr>\n      <td>[Nomas](https://nomaswallet.com)</td>\n      <td>Mobile</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>\u274c</td>\n      <td>AI features, Gas fee optimization</td>\n    </tr>\n    \n    <tr>\n      <td>[MetaMask](https://metamask.io)</td>\n      <td>Desktop, Mobile</td>\n      <td>\u274c</td>\n      <td>NFTs</td>\n      <td>\u274c</td>\n      <td>NFT support, DApp browser, Open source, Token swaps, portfolio tracking</td>\n    </tr>\n    \n    <tr>\n      <td>[OKX Wallet](https://www.okx.com/en-us/help/section/faq-web3-wallet)</td>\n      <td>Desktop, Mobile</td>\n      <td>\u2705</td>\n      <td>\u2705</td>\n      <td>\u2705</td>\n      <td>DApp browser, Portfolio tracking, Cross-chain swaps, Biometric Login</td>\n    </tr>\n  </tbody>\n</table>"
  },
  {
    "instruction": "What is covered in the 'Provider Details' section of the Developer Essentials guide?",
    "output": "### Phantom\n\n[Phantom](https://phantom.com) is a secure and easy-to-use wallet for the Monad Testnet.\n\nTo get started, download the phantom wallet [here](https://phantom.com/download) or visit the [documentation](https://phantom.com/learn/developers).\n\nSupported Networks\n- Monad Testnet\n\n### Backpack\n\n[Backpack](https://backpack.app) is a next-level wallet and exchange. Buy tokens, trade futures, and explore on-chain apps\u2014seamlessly and securely. \ud83c\udf92\n\nTo get started, download the Backpack wallet [here](https://backpack.app) or visit the [documentation](https://docs.backpack.app/).\n\nSupported Networks\n- Monad Testnet\n\n### Bitget Wallet\n\n[Bitget Wallet](https://web3.bitget.com/en?source=bitget) is a non-custodial wallet with advanced multi-chain capabilities and powerful swap function\n\nTo get started, download the Bitget wallet [here](https://web3.bitget.com/en/wallet-download?type=2) or visit the [documentation](https://web3.bitget.com/en/docs/).\n\nSupported Networks\n- Monad Testnet\n\n### HaHa Wallet\n\n[HaHa](https://www.haha.me) is a next-gen smart wallet with DeFi capabilities.\n\nTo get started, download the HaHa wallet [here](https://www.haha.me).\n\nSupported Networks\n- Monad Testnet\n\n### Leap Wallet\n\n[Leap](https://www.leapwallet.io) is a multi-chain wallet spanning across Cosmos, EVM & Bitcoin.\n\nTo get started, download the Leap wallet [here](https://www.leapwallet.io/download) or visit the [documentation](https://docs.leapwallet.io).\n\nSupported Networks\n- Monad Testnet\n\n### Nomas Wallet\n\n[Nomas](https://nomaswallet.com) is a Web3 Wallet Evolution Powered by AI.\n\nGet started with the Nomas wallet [here](https://t.me/nomas_wallet_dev_bot).\n\nSupported Networks\n- Monad Testnet\n\n### MetaMask\n\n[MetaMask](https://metamask.io) is a secure and easy-to-use wallet for the Monad Testnet.\n\nTo get started, download the MetaMask wallet [here](https://metamask.io/download) or visit the [documentation](https://docs.metamask.io).\n\nSupported Networks\n- Monad Testnet\n\n### OKX Wallet\n\n[OKX Wallet](https://www.okx.com/en-us/help/section/faq-web3-wallet) is your all-in-one gateway to the Web3 world.\n\nTo get started, download the OKX Wallet [here](https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge) or visit the [documentation](https://www.okx.com/web3/build/docs/sdks/okx-wallet-integration-introduction).\n\nSupported Networks\n- Monad Testnet"
  }
]
